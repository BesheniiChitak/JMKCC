import kotlinx.serialization.json.JsonArray
import kotlinx.serialization.json.JsonObject
import kotlinx.serialization.json.JsonPrimitive

fun codeCallFunction(functionName: Any) {
            val functionNameARG: JString = when (functionName) {
                is String -> JString(functionName)
is JString -> functionName
                else -> {
                    errorPrint("${currentScope.scope}: В codeCallFunction:functionName получен тип ${functionName.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("function_name"),
    "value" to functionNameARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("call_function"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun codeCallException(id: Any, message: Any, type: JString? = null) {
            val idARG: JString = when (id) {
                is String -> JString(id)
is JString -> id
                else -> {
                    errorPrint("${currentScope.scope}: В codeCallException:id получен тип ${id.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val messageARG: JString = when (message) {
                is String -> JString(message)
is JString -> message
                else -> {
                    errorPrint("${currentScope.scope}: В codeCallException:message получен тип ${message.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("id"),
    "value" to idARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("message"),
    "value" to messageARG.parse()
)))
if (type != null) {
    if (type.value !in setOf("ERROR", "FATAL", "WARNING")) {
        errorPrint("${currentScope.scope}: В функции codeCallException для аргумента type получено значение = \"${type.value}\", ожидалось одно из: \"ERROR\", \"FATAL\", \"WARNING\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to type.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("control_call_exception"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun codeBreak() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("control_end_thread"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun codeReturnFunction() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("control_return_function"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun codeSkipIteration() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("control_skip_iteration"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun codeStopRepeat() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("control_stop_repeat"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun codeWait(duration: Any, timeUnit: JString? = null) {
            val durationARG: JNumber = when (duration) {
                is Number -> JNumber(duration)
is JNumber -> duration
                else -> {
                    errorPrint("${currentScope.scope}: В codeWait:duration получен тип ${duration.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("duration"),
    "value" to durationARG.parse()
)))
if (timeUnit != null) {
    if (timeUnit.value !in setOf("MINUTES", "SECONDS", "TICKS")) {
        errorPrint("${currentScope.scope}: В функции codeWait для аргумента time_unit получено значение = \"${timeUnit.value}\", ожидалось одно из: \"MINUTES\", \"SECONDS\", \"TICKS\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("time_unit"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to timeUnit.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("control_wait"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun controllerAsyncRun() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("controller_async_run"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun controllerCatchException(variable: Any, exceptionType: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В controllerCatchException:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
if (exceptionType != null) {
    if (exceptionType.value !in setOf("ALL", "ERROR", "WARNING")) {
        errorPrint("${currentScope.scope}: В функции controllerCatchException для аргумента exception_type получено значение = \"${exceptionType.value}\", ожидалось одно из: \"ALL\", \"ERROR\", \"WARNING\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("exception_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to exceptionType.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("controller_exception"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun controllerMeasureTime(variable: Any, duration: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В controllerMeasureTime:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
if (duration != null) {
    if (duration.value !in setOf("MICROSECONDS", "MILLISECONDS", "NANOSECONDS")) {
        errorPrint("${currentScope.scope}: В функции controllerMeasureTime для аргумента duration получено значение = \"${duration.value}\", ожидалось одно из: \"MICROSECONDS\", \"MILLISECONDS\", \"NANOSECONDS\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("duration"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to duration.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("controller_measure_time"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun codeElse() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("else"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityAttachLead(nameOrUuid: Any, location: Any) {
            val nameOrUuidARG: JString = when (nameOrUuid) {
                is String -> JString(nameOrUuid)
is JString -> nameOrUuid
                else -> {
                    errorPrint("${currentScope.scope}: В entityAttachLead:nameOrUuid получен тип ${nameOrUuid.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В entityAttachLead:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("name_or_uuid"),
    "value" to nameOrUuidARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_attach_lead"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityClearPotionEffects() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_celar_potion_effects"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityClearMerchantRecipes() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_clear_merchant_recipes"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityDamage(damage: Any, source: Any) {
            val damageARG: JNumber = when (damage) {
                is Number -> JNumber(damage)
is JNumber -> damage
                else -> {
                    errorPrint("${currentScope.scope}: В entityDamage:damage получен тип ${damage.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val sourceARG: JString = when (source) {
                is String -> JString(source)
is JString -> source
                else -> {
                    errorPrint("${currentScope.scope}: В entityDamage:source получен тип ${source.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("damage"),
    "value" to damageARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("source"),
    "value" to sourceARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_damage"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityDisguiseAsBlock(block: Any) {
val blockARG: JBlock = when (block) {
    is JBlock -> block
    else -> {
        errorPrint("${currentScope.scope}: В entityDisguiseAsBlock:block получен тип ${block.javaClass.kotlin.simpleName}, ожидалось: JBlock")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("block"),
    "value" to blockARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_disguise_as_block"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityDisguiseAsEntity(entityType: Any) {
val entityTypeARG: JItem = when (entityType) {
    is JItem -> entityType
    else -> {
        errorPrint("${currentScope.scope}: В entityDisguiseAsEntity:entityType получен тип ${entityType.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("entity_type"),
    "value" to entityTypeARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_disguise_as_entity"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityDisguiseAsItem(item: Any) {
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В entityDisguiseAsItem:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_disguise_as_item"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityDisguiseAsPlayer(nameOrUuid: Any, displayName: Any, serverType: JString? = null) {
            val nameOrUuidARG: JString = when (nameOrUuid) {
                is String -> JString(nameOrUuid)
is JString -> nameOrUuid
                else -> {
                    errorPrint("${currentScope.scope}: В entityDisguiseAsPlayer:nameOrUuid получен тип ${nameOrUuid.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val displayNameARG: JString = when (displayName) {
                is String -> JString(displayName)
is JString -> displayName
                else -> {
                    errorPrint("${currentScope.scope}: В entityDisguiseAsPlayer:displayName получен тип ${displayName.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("name_or_uuid"),
    "value" to nameOrUuidARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("display_name"),
    "value" to displayNameARG.parse()
)))
if (serverType != null) {
    if (serverType.value !in setOf("MOJANG", "SERVER")) {
        errorPrint("${currentScope.scope}: В функции entityDisguiseAsPlayer для аргумента server_type получено значение = \"${serverType.value}\", ожидалось одно из: \"MOJANG\", \"SERVER\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("server_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to serverType.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_disguise_as_player"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityEatGrass() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_eat_grass"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityEatTarget(nameOrUuid: Any) {
            val nameOrUuidARG: JString = when (nameOrUuid) {
                is String -> JString(nameOrUuid)
is JString -> nameOrUuid
                else -> {
                    errorPrint("${currentScope.scope}: В entityEatTarget:nameOrUuid получен тип ${nameOrUuid.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("name_or_uuid"),
    "value" to nameOrUuidARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_eat_target"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityExplode() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_explode"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityFaceLocation(location: Any) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В entityFaceLocation:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_face_location"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityGetCustomTag(variable: Any, name: Any, default: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В entityGetCustomTag:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val nameARG: JString = when (name) {
                is String -> JString(name)
is JString -> name
                else -> {
                    errorPrint("${currentScope.scope}: В entityGetCustomTag:name получен тип ${name.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
val defaultARG: JAny = when (default) {
    is JAny -> default
    else -> {
        errorPrint("${currentScope.scope}: В entityGetCustomTag:default получен тип ${default.javaClass.kotlin.simpleName}, ожидалось: JAny")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("name"),
    "value" to nameARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("default"),
    "value" to defaultARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_get_custom_tag"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityGivePotionEffects(potions: Any, overwrite: JString? = null, showIcon: JString? = null, particleMode: JString? = null) {
val potionsARG: JPotion = when (potions) {
    is JPotion -> potions
    else -> {
        errorPrint("${currentScope.scope}: В entityGivePotionEffects:potions получен тип ${potions.javaClass.kotlin.simpleName}, ожидалось: JPotion")
        throw Exception()
    }
}



    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("potions"),
    "value" to potionsARG.parse()
)))
if (overwrite != null) {
    if (overwrite.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entityGivePotionEffects для аргумента overwrite получено значение = \"${overwrite.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("overwrite"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to overwrite.jsonValue()
        ))
    )))
}
if (showIcon != null) {
    if (showIcon.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entityGivePotionEffects для аргумента show_icon получено значение = \"${showIcon.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("show_icon"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to showIcon.jsonValue()
        ))
    )))
}
if (particleMode != null) {
    if (particleMode.value !in setOf("AMBIENT", "NONE", "REGULAR")) {
        errorPrint("${currentScope.scope}: В функции entityGivePotionEffects для аргумента particle_mode получено значение = \"${particleMode.value}\", ожидалось одно из: \"AMBIENT\", \"NONE\", \"REGULAR\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("particle_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to particleMode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_give_potion_effects"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityHeal(heal: Any) {
            val healARG: JNumber = when (heal) {
                is Number -> JNumber(heal)
is JNumber -> heal
                else -> {
                    errorPrint("${currentScope.scope}: В entityHeal:heal получен тип ${heal.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("heal"),
    "value" to healARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_heal"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityIgniteCreeper() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_ignite_creeper"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityJump() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_jump"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityLaunchForward(power: Any, increment: JString? = null, launchAxis: JString? = null) {
            val powerARG: JNumber = when (power) {
                is Number -> JNumber(power)
is JNumber -> power
                else -> {
                    errorPrint("${currentScope.scope}: В entityLaunchForward:power получен тип ${power.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }


    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("power"),
    "value" to powerARG.parse()
)))
if (increment != null) {
    if (increment.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entityLaunchForward для аргумента increment получено значение = \"${increment.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("increment"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to increment.jsonValue()
        ))
    )))
}
if (launchAxis != null) {
    if (launchAxis.value !in setOf("YAW", "YAW_AND_PITCH")) {
        errorPrint("${currentScope.scope}: В функции entityLaunchForward для аргумента launch_axis получено значение = \"${launchAxis.value}\", ожидалось одно из: \"YAW\", \"YAW_AND_PITCH\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("launch_axis"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to launchAxis.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_launch_forward"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityLaunchProjectile(projectile: Any, location: Any, name: Any, speed: Any, inaccuracy: Any, trail: Any) {
val projectileARG: JItem = when (projectile) {
    is JItem -> projectile
    else -> {
        errorPrint("${currentScope.scope}: В entityLaunchProjectile:projectile получен тип ${projectile.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В entityLaunchProjectile:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val nameARG: JString = when (name) {
                is String -> JString(name)
is JString -> name
                else -> {
                    errorPrint("${currentScope.scope}: В entityLaunchProjectile:name получен тип ${name.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val speedARG: JNumber = when (speed) {
                is Number -> JNumber(speed)
is JNumber -> speed
                else -> {
                    errorPrint("${currentScope.scope}: В entityLaunchProjectile:speed получен тип ${speed.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val inaccuracyARG: JNumber = when (inaccuracy) {
                is Number -> JNumber(inaccuracy)
is JNumber -> inaccuracy
                else -> {
                    errorPrint("${currentScope.scope}: В entityLaunchProjectile:inaccuracy получен тип ${inaccuracy.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
val trailARG: JParticle = when (trail) {
    is JParticle -> trail
    else -> {
        errorPrint("${currentScope.scope}: В entityLaunchProjectile:trail получен тип ${trail.javaClass.kotlin.simpleName}, ожидалось: JParticle")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("projectile"),
    "value" to projectileARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("name"),
    "value" to nameARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("speed"),
    "value" to speedARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("inaccuracy"),
    "value" to inaccuracyARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("trail"),
    "value" to trailARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_launch_projectile"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityLaunchToLocation(location: Any, power: Any, increment: JString? = null) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В entityLaunchToLocation:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val powerARG: JNumber = when (power) {
                is Number -> JNumber(power)
is JNumber -> power
                else -> {
                    errorPrint("${currentScope.scope}: В entityLaunchToLocation:power получен тип ${power.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("power"),
    "value" to powerARG.parse()
)))
if (increment != null) {
    if (increment.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entityLaunchToLocation для аргумента increment получено значение = \"${increment.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("increment"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to increment.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_launch_to_location"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityLaunchUp(power: Any, increment: JString? = null) {
            val powerARG: JNumber = when (power) {
                is Number -> JNumber(power)
is JNumber -> power
                else -> {
                    errorPrint("${currentScope.scope}: В entityLaunchUp:power получен тип ${power.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("power"),
    "value" to powerARG.parse()
)))
if (increment != null) {
    if (increment.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entityLaunchUp для аргумента increment получено значение = \"${increment.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("increment"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to increment.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_launch_up"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityLeaveVehicle() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_leave_vehicle"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityModifyPiglinBarterMaterials(materials: Any, modificationMode: JString? = null) {
val materialsARG: JItem = when (materials) {
    is JItem -> materials
    else -> {
        errorPrint("${currentScope.scope}: В entityModifyPiglinBarterMaterials:materials получен тип ${materials.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("materials"),
    "value" to materialsARG.parse()
)))
if (modificationMode != null) {
    if (modificationMode.value !in setOf("ADD", "REMOVE")) {
        errorPrint("${currentScope.scope}: В функции entityModifyPiglinBarterMaterials для аргумента modification_mode получено значение = \"${modificationMode.value}\", ожидалось одно из: \"ADD\", \"REMOVE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("modification_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to modificationMode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_modify_piglin_barter_materials"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityModifyPiglinInterestedMaterials(materials: Any, modificationMode: JString? = null) {
val materialsARG: JItem = when (materials) {
    is JItem -> materials
    else -> {
        errorPrint("${currentScope.scope}: В entityModifyPiglinInterestedMaterials:materials получен тип ${materials.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("materials"),
    "value" to materialsARG.parse()
)))
if (modificationMode != null) {
    if (modificationMode.value !in setOf("ADD", "REMOVE")) {
        errorPrint("${currentScope.scope}: В функции entityModifyPiglinInterestedMaterials для аргумента modification_mode получено значение = \"${modificationMode.value}\", ожидалось одно из: \"ADD\", \"REMOVE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("modification_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to modificationMode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_modify_piglin_interested_materials"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityMoveToLocation(location: Any, speed: Any) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В entityMoveToLocation:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val speedARG: JNumber = when (speed) {
                is Number -> JNumber(speed)
is JNumber -> speed
                else -> {
                    errorPrint("${currentScope.scope}: В entityMoveToLocation:speed получен тип ${speed.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("speed"),
    "value" to speedARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_move_to_location"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityMoveToLocationStop() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_move_to_location_stop"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityPlayDamageAnimation(damageType: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (damageType != null) {
    if (damageType.value !in setOf("CRITICAL_DAMAGE", "DAMAGE", "MAGICAL_DAMAGE")) {
        errorPrint("${currentScope.scope}: В функции entityPlayDamageAnimation для аргумента damage_type получено значение = \"${damageType.value}\", ожидалось одно из: \"CRITICAL_DAMAGE\", \"DAMAGE\", \"MAGICAL_DAMAGE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("damage_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to damageType.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_play_damage_animation"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityPlayHurtAnimation(yaw: Any) {
            val yawARG: JNumber = when (yaw) {
                is Number -> JNumber(yaw)
is JNumber -> yaw
                else -> {
                    errorPrint("${currentScope.scope}: В entityPlayHurtAnimation:yaw получен тип ${yaw.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("yaw"),
    "value" to yawARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_play_hurt_animation"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityRamTarget(nameOrUuid: Any) {
            val nameOrUuidARG: JString = when (nameOrUuid) {
                is String -> JString(nameOrUuid)
is JString -> nameOrUuid
                else -> {
                    errorPrint("${currentScope.scope}: В entityRamTarget:nameOrUuid получен тип ${nameOrUuid.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("name_or_uuid"),
    "value" to nameOrUuidARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_ram_target"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityRemove() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_remove"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityRemoveCustomTag(name: Any) {
            val nameARG: JString = when (name) {
                is String -> JString(name)
is JString -> name
                else -> {
                    errorPrint("${currentScope.scope}: В entityRemoveCustomTag:name получен тип ${name.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("name"),
    "value" to nameARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_remove_custom_tag"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityRemoveDisguise() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_remove_disguise"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityRemoveMerchantRecipe(recipeIndex: Any) {
            val recipeIndexARG: JNumber = when (recipeIndex) {
                is Number -> JNumber(recipeIndex)
is JNumber -> recipeIndex
                else -> {
                    errorPrint("${currentScope.scope}: В entityRemoveMerchantRecipe:recipeIndex получен тип ${recipeIndex.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("recipe_index"),
    "value" to recipeIndexARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_remove_merchant_recipe"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityRemovePotionEffect(effects: Any) {
val effectsARG: JPotion = when (effects) {
    is JPotion -> effects
    else -> {
        errorPrint("${currentScope.scope}: В entityRemovePotionEffect:effects получен тип ${effects.javaClass.kotlin.simpleName}, ожидалось: JPotion")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("effects"),
    "value" to effectsARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_remove_potion_effect"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityResetDisplayBrightness() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_reset_display_brightness"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityResetDisplayGlowColor() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_reset_display_glow_color"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityResetTextDisplayBackground() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_reset_text_display_background"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityRideEntity(nameOrUuid: Any) {
            val nameOrUuidARG: JString = when (nameOrUuid) {
                is String -> JString(nameOrUuid)
is JString -> nameOrUuid
                else -> {
                    errorPrint("${currentScope.scope}: В entityRideEntity:nameOrUuid получен тип ${nameOrUuid.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("name_or_uuid"),
    "value" to nameOrUuidARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_ride_entity"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetAbsorptionHealth(health: Any) {
            val healthARG: JNumber = when (health) {
                is Number -> JNumber(health)
is JNumber -> health
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetAbsorptionHealth:health получен тип ${health.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("health"),
    "value" to healthARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_absorption_health"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetAi(ai: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (ai != null) {
    if (ai.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entitySetAi для аргумента ai получено значение = \"${ai.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("ai"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to ai.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_ai"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetAllayDancing(dance: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (dance != null) {
    if (dance.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entitySetAllayDancing для аргумента dance получено значение = \"${dance.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("dance"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to dance.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_allay_dancing"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetAngry(target: Any, angry: JString? = null) {
            val targetARG: JString = when (target) {
                is String -> JString(target)
is JString -> target
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetAngry:target получен тип ${target.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("target"),
    "value" to targetARG.parse()
)))
if (angry != null) {
    if (angry.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entitySetAngry для аргумента angry получено значение = \"${angry.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("angry"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to angry.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_angry"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetAnimalAge(age: Any, lock: JString? = null) {
            val ageARG: JNumber = when (age) {
                is Number -> JNumber(age)
is JNumber -> age
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetAnimalAge:age получен тип ${age.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("age"),
    "value" to ageARG.parse()
)))
if (lock != null) {
    if (lock.value !in setOf("DISABLE", "DONT_CHANGE", "ENABLE")) {
        errorPrint("${currentScope.scope}: В функции entitySetAnimalAge для аргумента lock получено значение = \"${lock.value}\", ожидалось одно из: \"DISABLE\", \"DONT_CHANGE\", \"ENABLE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("lock"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to lock.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_animal_age"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetArmorItems(helmet: Any, chestplate: Any, leggings: Any, boots: Any) {
val helmetARG: JItem = when (helmet) {
    is JItem -> helmet
    else -> {
        errorPrint("${currentScope.scope}: В entitySetArmorItems:helmet получен тип ${helmet.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
val chestplateARG: JItem = when (chestplate) {
    is JItem -> chestplate
    else -> {
        errorPrint("${currentScope.scope}: В entitySetArmorItems:chestplate получен тип ${chestplate.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
val leggingsARG: JItem = when (leggings) {
    is JItem -> leggings
    else -> {
        errorPrint("${currentScope.scope}: В entitySetArmorItems:leggings получен тип ${leggings.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
val bootsARG: JItem = when (boots) {
    is JItem -> boots
    else -> {
        errorPrint("${currentScope.scope}: В entitySetArmorItems:boots получен тип ${boots.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("helmet"),
    "value" to helmetARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("chestplate"),
    "value" to chestplateARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("leggings"),
    "value" to leggingsARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("boots"),
    "value" to bootsARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_armor_items"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetArmorStandParts(arms: JString? = null, basePlate: JString? = null) {


    val funValues = mutableListOf<JsonObject>()
if (arms != null) {
    if (arms.value !in setOf("DISABLE", "DONT_CHANGE", "ENABLE")) {
        errorPrint("${currentScope.scope}: В функции entitySetArmorStandParts для аргумента arms получено значение = \"${arms.value}\", ожидалось одно из: \"DISABLE\", \"DONT_CHANGE\", \"ENABLE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("arms"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to arms.jsonValue()
        ))
    )))
}
if (basePlate != null) {
    if (basePlate.value !in setOf("DISABLE", "DONT_CHANGE", "ENABLE")) {
        errorPrint("${currentScope.scope}: В функции entitySetArmorStandParts для аргумента base_plate получено значение = \"${basePlate.value}\", ожидалось одно из: \"DISABLE\", \"DONT_CHANGE\", \"ENABLE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("base_plate"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to basePlate.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_armor_stand_parts"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetArmorStandPose(xRotation: Any, yRotation: Any, zRotation: Any, bodyPart: JString? = null) {
            val xRotationARG: JNumber = when (xRotation) {
                is Number -> JNumber(xRotation)
is JNumber -> xRotation
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetArmorStandPose:xRotation получен тип ${xRotation.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val yRotationARG: JNumber = when (yRotation) {
                is Number -> JNumber(yRotation)
is JNumber -> yRotation
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetArmorStandPose:yRotation получен тип ${yRotation.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val zRotationARG: JNumber = when (zRotation) {
                is Number -> JNumber(zRotation)
is JNumber -> zRotation
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetArmorStandPose:zRotation получен тип ${zRotation.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("x_rotation"),
    "value" to xRotationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("y_rotation"),
    "value" to yRotationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("z_rotation"),
    "value" to zRotationARG.parse()
)))
if (bodyPart != null) {
    if (bodyPart.value !in setOf("BODY", "HEAD", "LEFT_ARM", "LEFT_LEG", "RIGHT_ARM", "RIGHT_LEG")) {
        errorPrint("${currentScope.scope}: В функции entitySetArmorStandPose для аргумента body_part получено значение = \"${bodyPart.value}\", ожидалось одно из: \"BODY\", \"HEAD\", \"LEFT_ARM\", \"LEFT_LEG\", \"RIGHT_ARM\", \"RIGHT_LEG\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("body_part"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to bodyPart.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_armor_stand_pose"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetArrowHitSound(sound: Any) {
val soundARG: JSound = when (sound) {
    is JSound -> sound
    else -> {
        errorPrint("${currentScope.scope}: В entitySetArrowHitSound:sound получен тип ${sound.javaClass.kotlin.simpleName}, ожидалось: JSound")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("sound"),
    "value" to soundARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_arrow_hit_sound"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetArrowPierce(pierce: Any) {
            val pierceARG: JNumber = when (pierce) {
                is Number -> JNumber(pierce)
is JNumber -> pierce
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetArrowPierce:pierce получен тип ${pierce.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("pierce"),
    "value" to pierceARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_arrow_pierce"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetAttribute(value: Any, attributeType: JString? = null) {
            val valueARG: JNumber = when (value) {
                is Number -> JNumber(value)
is JNumber -> value
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetAttribute:value получен тип ${value.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("value"),
    "value" to valueARG.parse()
)))
if (attributeType != null) {
    if (attributeType.value !in setOf("GENERIC_ARMOR", "GENERIC_ARMOR_TOUGHNESS", "GENERIC_ATTACK_DAMAGE", "GENERIC_ATTACK_KNOCKBACK", "GENERIC_ATTACK_SPEED", "GENERIC_BURNING_TIME", "GENERIC_EXPLOSION_KNOCKBACK_RESISTANCE", "GENERIC_FALL_DAMAGE_MULTIPLIER", "GENERIC_FLYING_SPEED", "GENERIC_FOLLOW_RANGE", "GENERIC_GRAVITY", "GENERIC_JUMP_STRENGTH", "GENERIC_KNOCKBACK_RESISTANCE", "GENERIC_LUCK", "GENERIC_MAX_ABSORPTION", "GENERIC_MAX_HEALTH", "GENERIC_MOVEMENT_EFFICIENCY", "GENERIC_MOVEMENT_SPEED", "GENERIC_OXYGEN_BONUS", "GENERIC_SAFE_FALL_DISTANCE", "GENERIC_SCALE", "GENERIC_STEP_HEIGHT", "GENERIC_WATER_MOVEMENT_EFFICIENCY", "PLAYER_BLOCK_BREAK_SPEED", "PLAYER_BLOCK_INTERACTION_RANGE", "PLAYER_ENTITY_INTERACTION_RANGE", "PLAYER_MINING_EFFICIENCY", "PLAYER_SNEAKING_SPEED", "PLAYER_SUBMERGED_MINING_SPEED", "PLAYER_SWEEPING_DAMAGE_RATIO", "ZOMBIE_SPAWN_REINFORCEMENTS")) {
        errorPrint("${currentScope.scope}: В функции entitySetAttribute для аргумента attribute_type получено значение = \"${attributeType.value}\", ожидалось одно из: \"GENERIC_ARMOR\", \"GENERIC_ARMOR_TOUGHNESS\", \"GENERIC_ATTACK_DAMAGE\", \"GENERIC_ATTACK_KNOCKBACK\", \"GENERIC_ATTACK_SPEED\", \"GENERIC_BURNING_TIME\", \"GENERIC_EXPLOSION_KNOCKBACK_RESISTANCE\", \"GENERIC_FALL_DAMAGE_MULTIPLIER\", \"GENERIC_FLYING_SPEED\", \"GENERIC_FOLLOW_RANGE\", \"GENERIC_GRAVITY\", \"GENERIC_JUMP_STRENGTH\", \"GENERIC_KNOCKBACK_RESISTANCE\", \"GENERIC_LUCK\", \"GENERIC_MAX_ABSORPTION\", \"GENERIC_MAX_HEALTH\", \"GENERIC_MOVEMENT_EFFICIENCY\", \"GENERIC_MOVEMENT_SPEED\", \"GENERIC_OXYGEN_BONUS\", \"GENERIC_SAFE_FALL_DISTANCE\", \"GENERIC_SCALE\", \"GENERIC_STEP_HEIGHT\", \"GENERIC_WATER_MOVEMENT_EFFICIENCY\", \"PLAYER_BLOCK_BREAK_SPEED\", \"PLAYER_BLOCK_INTERACTION_RANGE\", \"PLAYER_ENTITY_INTERACTION_RANGE\", \"PLAYER_MINING_EFFICIENCY\", \"PLAYER_SNEAKING_SPEED\", \"PLAYER_SUBMERGED_MINING_SPEED\", \"PLAYER_SWEEPING_DAMAGE_RATIO\", \"ZOMBIE_SPAWN_REINFORCEMENTS\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("attribute_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to attributeType.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_attribute"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetAware(aware: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (aware != null) {
    if (aware.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entitySetAware для аргумента aware получено значение = \"${aware.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("aware"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to aware.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_aware"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetAxolotlType(axolotlType: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (axolotlType != null) {
    if (axolotlType.value !in setOf("BLUE", "CYAN", "GOLD", "LUCY", "WILD")) {
        errorPrint("${currentScope.scope}: В функции entitySetAxolotlType для аргумента axolotl_type получено значение = \"${axolotlType.value}\", ожидалось одно из: \"BLUE\", \"CYAN\", \"GOLD\", \"LUCY\", \"WILD\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("axolotl_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to axolotlType.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_axolotl_type"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetBaby(baby: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (baby != null) {
    if (baby.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entitySetBaby для аргумента baby получено значение = \"${baby.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("baby"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to baby.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_baby"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetBaseArrowDamage(damage: Any) {
            val damageARG: JNumber = when (damage) {
                is Number -> JNumber(damage)
is JNumber -> damage
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetBaseArrowDamage:damage получен тип ${damage.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("damage"),
    "value" to damageARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_base_arrow_damage"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetBeeHasStinger(stinger: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (stinger != null) {
    if (stinger.value !in setOf("TRUE", "FALSE")) {
        errorPrint("${currentScope.scope}: В функции entitySetBeeHasStinger для аргумента stinger получено значение = \"${stinger.value}\", ожидалось одно из: \"TRUE\", \"FALSE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("stinger"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to stinger.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_bee_has_stinger"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetBeeNectar(nectar: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (nectar != null) {
    if (nectar.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entitySetBeeNectar для аргумента nectar получено значение = \"${nectar.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("nectar"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to nectar.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_bee_nectar"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetBlockDisplayBlock(displayedBlock: Any) {
val displayedBlockARG: JBlock = when (displayedBlock) {
    is JBlock -> displayedBlock
    else -> {
        errorPrint("${currentScope.scope}: В entitySetBlockDisplayBlock:displayedBlock получен тип ${displayedBlock.javaClass.kotlin.simpleName}, ожидалось: JBlock")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("displayed_block"),
    "value" to displayedBlockARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_block_display_block"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetCamelDashing(dashing: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (dashing != null) {
    if (dashing.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entitySetCamelDashing для аргумента dashing получено значение = \"${dashing.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("dashing"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to dashing.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_camel_dashing"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetCarryingChest(carrying: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (carrying != null) {
    if (carrying.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entitySetCarryingChest для аргумента carrying получено значение = \"${carrying.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("carrying"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to carrying.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_carrying_chest"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetCatLyingDown(lyingDown: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (lyingDown != null) {
    if (lyingDown.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entitySetCatLyingDown для аргумента lying_down получено значение = \"${lyingDown.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("lying_down"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to lyingDown.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_cat_lying_down"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetCatType(catType: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (catType != null) {
    if (catType.value !in setOf("ALL_BLACK", "BLACK", "BRITISH_SHORTHAIR", "CALICO", "JELLIE", "PERSIAN", "RAGDOLL", "RED", "SIAMESE", "TABBY", "WHITE")) {
        errorPrint("${currentScope.scope}: В функции entitySetCatType для аргумента cat_type получено значение = \"${catType.value}\", ожидалось одно из: \"ALL_BLACK\", \"BLACK\", \"BRITISH_SHORTHAIR\", \"CALICO\", \"JELLIE\", \"PERSIAN\", \"RAGDOLL\", \"RED\", \"SIAMESE\", \"TABBY\", \"WHITE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("cat_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to catType.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_cat_type"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetCelebrating(celebrating: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (celebrating != null) {
    if (celebrating.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entitySetCelebrating для аргумента celebrating получено значение = \"${celebrating.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("celebrating"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to celebrating.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_celebrating"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetCollidable(collidable: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (collidable != null) {
    if (collidable.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entitySetCollidable для аргумента collidable получено значение = \"${collidable.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("collidable"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to collidable.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_collidable"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetCreeperCharge(charged: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (charged != null) {
    if (charged.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entitySetCreeperCharge для аргумента charged получено значение = \"${charged.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("charged"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to charged.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_creeper_charge"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetCreeperFuse(fuseTicks: Any) {
            val fuseTicksARG: JNumber = when (fuseTicks) {
                is Number -> JNumber(fuseTicks)
is JNumber -> fuseTicks
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetCreeperFuse:fuseTicks получен тип ${fuseTicks.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("fuse_ticks"),
    "value" to fuseTicksARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_creeper_fuse"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetCurrentHealth(health: Any) {
            val healthARG: JNumber = when (health) {
                is Number -> JNumber(health)
is JNumber -> health
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetCurrentHealth:health получен тип ${health.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("health"),
    "value" to healthARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_current_health"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetCustomName(customName: Any) {
            val customNameARG: JString = when (customName) {
                is String -> JString(customName)
is JString -> customName
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetCustomName:customName получен тип ${customName.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("custom_name"),
    "value" to customNameARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_custom_name"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetCustomNameVisibility(visibility: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (visibility != null) {
    if (visibility.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entitySetCustomNameVisibility для аргумента visibility получено значение = \"${visibility.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("visibility"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to visibility.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_custom_name_visibility"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetCustomTag(name: Any, value: Any) {
            val nameARG: JString = when (name) {
                is String -> JString(name)
is JString -> name
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetCustomTag:name получен тип ${name.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val valueARG: JString = when (value) {
                is String -> JString(value)
is JString -> value
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetCustomTag:value получен тип ${value.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("name"),
    "value" to nameARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("value"),
    "value" to valueARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_custom_tag"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetDeathDrops(drops: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (drops != null) {
    if (drops.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entitySetDeathDrops для аргумента drops получено значение = \"${drops.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("drops"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to drops.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_death_drops"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetDeathTime(deathTime: Any) {
            val deathTimeARG: JNumber = when (deathTime) {
                is Number -> JNumber(deathTime)
is JNumber -> deathTime
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetDeathTime:deathTime получен тип ${deathTime.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("death_time"),
    "value" to deathTimeARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_death_time"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetDefaultVisible(defaultVisible: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (defaultVisible != null) {
    if (defaultVisible.value !in setOf("TRUE", "FALSE")) {
        errorPrint("${currentScope.scope}: В функции entitySetDefaultVisible для аргумента default_visible получено значение = \"${defaultVisible.value}\", ожидалось одно из: \"TRUE\", \"FALSE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("default_visible"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to defaultVisible.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_default_visible"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetDespawning(despawning: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (despawning != null) {
    if (despawning.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entitySetDespawning для аргумента despawning получено значение = \"${despawning.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("despawning"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to despawning.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_despawning"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetDisplayBillboard(billboardType: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (billboardType != null) {
    if (billboardType.value !in setOf("CENTER", "FIXED", "HORIZONTAL", "VERTICAL")) {
        errorPrint("${currentScope.scope}: В функции entitySetDisplayBillboard для аргумента billboard_type получено значение = \"${billboardType.value}\", ожидалось одно из: \"CENTER\", \"FIXED\", \"HORIZONTAL\", \"VERTICAL\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("billboard_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to billboardType.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_display_billboard"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetDisplayBrightness(blockLightLevel: Any, skyLightLevel: Any) {
            val blockLightLevelARG: JNumber = when (blockLightLevel) {
                is Number -> JNumber(blockLightLevel)
is JNumber -> blockLightLevel
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetDisplayBrightness:blockLightLevel получен тип ${blockLightLevel.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val skyLightLevelARG: JNumber = when (skyLightLevel) {
                is Number -> JNumber(skyLightLevel)
is JNumber -> skyLightLevel
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetDisplayBrightness:skyLightLevel получен тип ${skyLightLevel.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("block_light_level"),
    "value" to blockLightLevelARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("sky_light_level"),
    "value" to skyLightLevelARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_display_brightness"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetDisplayCullingSize(width: Any, height: Any) {
            val widthARG: JNumber = when (width) {
                is Number -> JNumber(width)
is JNumber -> width
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetDisplayCullingSize:width получен тип ${width.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val heightARG: JNumber = when (height) {
                is Number -> JNumber(height)
is JNumber -> height
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetDisplayCullingSize:height получен тип ${height.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("width"),
    "value" to widthARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("height"),
    "value" to heightARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_display_culling_suze"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetDisplayGlowColor(colorHexadecimal: Any) {
            val colorHexadecimalARG: JString = when (colorHexadecimal) {
                is String -> JString(colorHexadecimal)
is JString -> colorHexadecimal
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetDisplayGlowColor:colorHexadecimal получен тип ${colorHexadecimal.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("color_hexadecimal"),
    "value" to colorHexadecimalARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_display_glow_color"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetDisplayInterpolation(interpolationDuration: Any, interpolationDelay: Any) {
            val interpolationDurationARG: JNumber = when (interpolationDuration) {
                is Number -> JNumber(interpolationDuration)
is JNumber -> interpolationDuration
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetDisplayInterpolation:interpolationDuration получен тип ${interpolationDuration.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val interpolationDelayARG: JNumber = when (interpolationDelay) {
                is Number -> JNumber(interpolationDelay)
is JNumber -> interpolationDelay
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetDisplayInterpolation:interpolationDelay получен тип ${interpolationDelay.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("interpolation_duration"),
    "value" to interpolationDurationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("interpolation_delay"),
    "value" to interpolationDelayARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_display_interpolation"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetDisplayRotationFromAxisAngle(axisVector: Any, angle: Any, mode: JString? = null, input: JString? = null, rotation: JString? = null) {
val axisVectorARG: JVector = when (axisVector) {
    is JVector -> axisVector
    else -> {
        errorPrint("${currentScope.scope}: В entitySetDisplayRotationFromAxisAngle:axisVector получен тип ${axisVector.javaClass.kotlin.simpleName}, ожидалось: JVector")
        throw Exception()
    }
}
            val angleARG: JNumber = when (angle) {
                is Number -> JNumber(angle)
is JNumber -> angle
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetDisplayRotationFromAxisAngle:angle получен тип ${angle.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }



    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("axis_vector"),
    "value" to axisVectorARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("angle"),
    "value" to angleARG.parse()
)))
if (mode != null) {
    if (mode.value !in setOf("ADD", "SET")) {
        errorPrint("${currentScope.scope}: В функции entitySetDisplayRotationFromAxisAngle для аргумента mode получено значение = \"${mode.value}\", ожидалось одно из: \"ADD\", \"SET\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to mode.jsonValue()
        ))
    )))
}
if (input != null) {
    if (input.value !in setOf("DEGREES", "RADIANS")) {
        errorPrint("${currentScope.scope}: В функции entitySetDisplayRotationFromAxisAngle для аргумента input получено значение = \"${input.value}\", ожидалось одно из: \"DEGREES\", \"RADIANS\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("input"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to input.jsonValue()
        ))
    )))
}
if (rotation != null) {
    if (rotation.value !in setOf("LEFT_ROTATION", "RIGHT_ROTATION")) {
        errorPrint("${currentScope.scope}: В функции entitySetDisplayRotationFromAxisAngle для аргумента rotation получено значение = \"${rotation.value}\", ожидалось одно из: \"LEFT_ROTATION\", \"RIGHT_ROTATION\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("rotation"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to rotation.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_display_rotation_from_axis_angle"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetDisplayRotationFromEulerAngles(pitch: Any, yaw: Any, roll: Any, mode: JString? = null, input: JString? = null, rotation: JString? = null) {
            val pitchARG: JNumber = when (pitch) {
                is Number -> JNumber(pitch)
is JNumber -> pitch
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetDisplayRotationFromEulerAngles:pitch получен тип ${pitch.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val yawARG: JNumber = when (yaw) {
                is Number -> JNumber(yaw)
is JNumber -> yaw
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetDisplayRotationFromEulerAngles:yaw получен тип ${yaw.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val rollARG: JNumber = when (roll) {
                is Number -> JNumber(roll)
is JNumber -> roll
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetDisplayRotationFromEulerAngles:roll получен тип ${roll.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }



    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("pitch"),
    "value" to pitchARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("yaw"),
    "value" to yawARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("roll"),
    "value" to rollARG.parse()
)))
if (mode != null) {
    if (mode.value !in setOf("ADD", "SET")) {
        errorPrint("${currentScope.scope}: В функции entitySetDisplayRotationFromEulerAngles для аргумента mode получено значение = \"${mode.value}\", ожидалось одно из: \"ADD\", \"SET\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to mode.jsonValue()
        ))
    )))
}
if (input != null) {
    if (input.value !in setOf("DEGREES", "RADIANS")) {
        errorPrint("${currentScope.scope}: В функции entitySetDisplayRotationFromEulerAngles для аргумента input получено значение = \"${input.value}\", ожидалось одно из: \"DEGREES\", \"RADIANS\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("input"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to input.jsonValue()
        ))
    )))
}
if (rotation != null) {
    if (rotation.value !in setOf("LEFT_ROTATION", "RIGHT_ROTATION")) {
        errorPrint("${currentScope.scope}: В функции entitySetDisplayRotationFromEulerAngles для аргумента rotation получено значение = \"${rotation.value}\", ожидалось одно из: \"LEFT_ROTATION\", \"RIGHT_ROTATION\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("rotation"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to rotation.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_display_rotation_from_euler_angles"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetDisplayScale(scaleVector: Any, mode: JString? = null) {
val scaleVectorARG: JVector = when (scaleVector) {
    is JVector -> scaleVector
    else -> {
        errorPrint("${currentScope.scope}: В entitySetDisplayScale:scaleVector получен тип ${scaleVector.javaClass.kotlin.simpleName}, ожидалось: JVector")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("scale_vector"),
    "value" to scaleVectorARG.parse()
)))
if (mode != null) {
    if (mode.value !in setOf("ADD", "SET")) {
        errorPrint("${currentScope.scope}: В функции entitySetDisplayScale для аргумента mode получено значение = \"${mode.value}\", ожидалось одно из: \"ADD\", \"SET\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to mode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_display_scale"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetDisplayShadow(shadowRadius: Any, shadowOpacityPercentage: Any) {
            val shadowRadiusARG: JNumber = when (shadowRadius) {
                is Number -> JNumber(shadowRadius)
is JNumber -> shadowRadius
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetDisplayShadow:shadowRadius получен тип ${shadowRadius.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val shadowOpacityPercentageARG: JNumber = when (shadowOpacityPercentage) {
                is Number -> JNumber(shadowOpacityPercentage)
is JNumber -> shadowOpacityPercentage
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetDisplayShadow:shadowOpacityPercentage получен тип ${shadowOpacityPercentage.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("shadow_radius"),
    "value" to shadowRadiusARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("shadow_opacity_percentage"),
    "value" to shadowOpacityPercentageARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_display_shadow"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetDisplayTeleportDuration(duration: Any) {
            val durationARG: JNumber = when (duration) {
                is Number -> JNumber(duration)
is JNumber -> duration
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetDisplayTeleportDuration:duration получен тип ${duration.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("duration"),
    "value" to durationARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_display_teleport_duration"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetDisplayTransformationMatrix(rowMajorMatrix: Any) {
            val rowMajorMatrixARG: JNumber = when (rowMajorMatrix) {
                is Number -> JNumber(rowMajorMatrix)
is JNumber -> rowMajorMatrix
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetDisplayTransformationMatrix:rowMajorMatrix получен тип ${rowMajorMatrix.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("row_major_matrix"),
    "value" to rowMajorMatrixARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_display_transformation_matrix"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetDisplayTranslation(translationVector: Any, mode: JString? = null) {
val translationVectorARG: JVector = when (translationVector) {
    is JVector -> translationVector
    else -> {
        errorPrint("${currentScope.scope}: В entitySetDisplayTranslation:translationVector получен тип ${translationVector.javaClass.kotlin.simpleName}, ожидалось: JVector")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("translation_vector"),
    "value" to translationVectorARG.parse()
)))
if (mode != null) {
    if (mode.value !in setOf("ADD", "SET")) {
        errorPrint("${currentScope.scope}: В функции entitySetDisplayTranslation для аргумента mode получено значение = \"${mode.value}\", ожидалось одно из: \"ADD\", \"SET\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to mode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_display_translation"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetDisplayViewRange(viewRange: Any) {
            val viewRangeARG: JNumber = when (viewRange) {
                is Number -> JNumber(viewRange)
is JNumber -> viewRange
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetDisplayViewRange:viewRange получен тип ${viewRange.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("view_range"),
    "value" to viewRangeARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_display_view_range"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetDragonPhase(phase: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (phase != null) {
    if (phase.value !in setOf("BREATH_ATTACK", "CHARGE_PLAYER", "CIRCLING", "DYING", "FLY_TO_PORTAL", "HOVER", "LAND_ON_PORTAL", "LEAVE_PORTAL", "ROAR_BEFORE_ATTACK", "SEARCH_FOR_BREATH_ATTACK_TARGET", "STRAFING")) {
        errorPrint("${currentScope.scope}: В функции entitySetDragonPhase для аргумента phase получено значение = \"${phase.value}\", ожидалось одно из: \"BREATH_ATTACK\", \"CHARGE_PLAYER\", \"CIRCLING\", \"DYING\", \"FLY_TO_PORTAL\", \"HOVER\", \"LAND_ON_PORTAL\", \"LEAVE_PORTAL\", \"ROAR_BEFORE_ATTACK\", \"SEARCH_FOR_BREATH_ATTACK_TARGET\", \"STRAFING\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("phase"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to phase.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_dragon_phase"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetDyeColor(color: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (color != null) {
    if (color.value !in setOf("BLACK", "BLUE", "BROWN", "CYAN", "GRAY", "GREEN", "LIGHT_BLUE", "LIGHT_GRAY", "LIME", "MAGENTA", "ORANGE", "PINK", "PURPLE", "RED", "WHITE", "YELLOW")) {
        errorPrint("${currentScope.scope}: В функции entitySetDyeColor для аргумента color получено значение = \"${color.value}\", ожидалось одно из: \"BLACK\", \"BLUE\", \"BROWN\", \"CYAN\", \"GRAY\", \"GREEN\", \"LIGHT_BLUE\", \"LIGHT_GRAY\", \"LIME\", \"MAGENTA\", \"ORANGE\", \"PINK\", \"PURPLE\", \"RED\", \"WHITE\", \"YELLOW\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("color"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to color.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_dye_color"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetEndCrystalBeam(beam: Any) {
val beamARG: JLocation = when (beam) {
    is JLocation -> beam
    else -> {
        errorPrint("${currentScope.scope}: В entitySetEndCrystalBeam:beam получен тип ${beam.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("beam"),
    "value" to beamARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_end_crystal_beam"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetEndermanBlock(block: Any) {
val blockARG: JBlock = when (block) {
    is JBlock -> block
    else -> {
        errorPrint("${currentScope.scope}: В entitySetEndermanBlock:block получен тип ${block.javaClass.kotlin.simpleName}, ожидалось: JBlock")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("block"),
    "value" to blockARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_enderman_block"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetEquipmentItem(item: Any, slot: JString? = null) {
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В entitySetEquipmentItem:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
if (slot != null) {
    if (slot.value !in setOf("CHEST", "FEET", "HAND", "HEAD", "LEGS", "OFF_HAND")) {
        errorPrint("${currentScope.scope}: В функции entitySetEquipmentItem для аргумента slot получено значение = \"${slot.value}\", ожидалось одно из: \"CHEST\", \"FEET\", \"HAND\", \"HEAD\", \"LEGS\", \"OFF_HAND\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("slot"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to slot.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_equipment_item"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetExplosivePower(power: Any) {
            val powerARG: JNumber = when (power) {
                is Number -> JNumber(power)
is JNumber -> power
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetExplosivePower:power получен тип ${power.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("power"),
    "value" to powerARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_explosive_power"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetFallDistance(fallDistance: Any) {
            val fallDistanceARG: JNumber = when (fallDistance) {
                is Number -> JNumber(fallDistance)
is JNumber -> fallDistance
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetFallDistance:fallDistance получен тип ${fallDistance.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("fall_distance"),
    "value" to fallDistanceARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_fall_distance"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetFallingBlockType(block: Any) {
val blockARG: JBlock = when (block) {
    is JBlock -> block
    else -> {
        errorPrint("${currentScope.scope}: В entitySetFallingBlockType:block получен тип ${block.javaClass.kotlin.simpleName}, ожидалось: JBlock")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("block"),
    "value" to blockARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_falling_block_type"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetFireTicks(ticks: Any) {
            val ticksARG: JNumber = when (ticks) {
                is Number -> JNumber(ticks)
is JNumber -> ticks
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetFireTicks:ticks получен тип ${ticks.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("ticks"),
    "value" to ticksARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_fire_ticks"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetFishingWait(time: Any) {
            val timeARG: JNumber = when (time) {
                is Number -> JNumber(time)
is JNumber -> time
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetFishingWait:time получен тип ${time.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("time"),
    "value" to timeARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_fishing_wait"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetFoxLeaping(leaping: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (leaping != null) {
    if (leaping.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entitySetFoxLeaping для аргумента leaping получено значение = \"${leaping.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("leaping"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to leaping.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_fox_leaping"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetFoxType(foxType: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (foxType != null) {
    if (foxType.value !in setOf("RED", "SNOW")) {
        errorPrint("${currentScope.scope}: В функции entitySetFoxType для аргумента fox_type получено значение = \"${foxType.value}\", ожидалось одно из: \"RED\", \"SNOW\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("fox_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to foxType.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_fox_type"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetFreezeTicks(ticks: Any, tickingLocked: JString? = null) {
            val ticksARG: JNumber = when (ticks) {
                is Number -> JNumber(ticks)
is JNumber -> ticks
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetFreezeTicks:ticks получен тип ${ticks.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("ticks"),
    "value" to ticksARG.parse()
)))
if (tickingLocked != null) {
    if (tickingLocked.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entitySetFreezeTicks для аргумента ticking_locked получено значение = \"${tickingLocked.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("ticking_locked"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to tickingLocked.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_freeze_ticks"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetFriction(friction: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (friction != null) {
    if (friction.value !in setOf("NOT_SET", "TRUE", "FALSE")) {
        errorPrint("${currentScope.scope}: В функции entitySetFriction для аргумента friction получено значение = \"${friction.value}\", ожидалось одно из: \"NOT_SET\", \"TRUE\", \"FALSE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("friction"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to friction.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_friction"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetFrogType(frogVariant: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (frogVariant != null) {
    if (frogVariant.value !in setOf("COLD", "TEMPERATE", "WARM")) {
        errorPrint("${currentScope.scope}: В функции entitySetFrogType для аргумента frog_variant получено значение = \"${frogVariant.value}\", ожидалось одно из: \"COLD\", \"TEMPERATE\", \"WARM\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("frog_variant"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to frogVariant.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_frog_type"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetGliding(isGliding: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (isGliding != null) {
    if (isGliding.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entitySetGliding для аргумента is_gliding получено значение = \"${isGliding.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("is_gliding"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to isGliding.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_gliding"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetGlowSquidDark(darkTicks: Any) {
            val darkTicksARG: JNumber = when (darkTicks) {
                is Number -> JNumber(darkTicks)
is JNumber -> darkTicks
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetGlowSquidDark:darkTicks получен тип ${darkTicks.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("dark_ticks"),
    "value" to darkTicksARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_glow_squid_dark"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetGlowing(glowing: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (glowing != null) {
    if (glowing.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entitySetGlowing для аргумента glowing получено значение = \"${glowing.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("glowing"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to glowing.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_glowing"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetGoatScreaming(screams: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (screams != null) {
    if (screams.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entitySetGoatScreaming для аргумента screams получено значение = \"${screams.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("screams"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to screams.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_goat_screaming"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetGravity(gravity: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (gravity != null) {
    if (gravity.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entitySetGravity для аргумента gravity получено значение = \"${gravity.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("gravity"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to gravity.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_gravity"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetHorseJump(power: Any) {
            val powerARG: JNumber = when (power) {
                is Number -> JNumber(power)
is JNumber -> power
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetHorseJump:power получен тип ${power.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("power"),
    "value" to powerARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_horse_jump"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetHorsePattern(horseColor: JString? = null, horseStyle: JString? = null) {


    val funValues = mutableListOf<JsonObject>()
if (horseColor != null) {
    if (horseColor.value !in setOf("BLACK", "BROWN", "CHESTNUT", "CREAMY", "DARK_BROWN", "DO_NOT_CHANGE", "GRAY", "WHITE")) {
        errorPrint("${currentScope.scope}: В функции entitySetHorsePattern для аргумента horse_color получено значение = \"${horseColor.value}\", ожидалось одно из: \"BLACK\", \"BROWN\", \"CHESTNUT\", \"CREAMY\", \"DARK_BROWN\", \"DO_NOT_CHANGE\", \"GRAY\", \"WHITE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("horse_color"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to horseColor.jsonValue()
        ))
    )))
}
if (horseStyle != null) {
    if (horseStyle.value !in setOf("BLACK_DOTS", "DO_NOT_CHANGE", "NONE", "WHITE", "WHITEFIELD", "WHITE_DOTS")) {
        errorPrint("${currentScope.scope}: В функции entitySetHorsePattern для аргумента horse_style получено значение = \"${horseStyle.value}\", ожидалось одно из: \"BLACK_DOTS\", \"DO_NOT_CHANGE\", \"NONE\", \"WHITE\", \"WHITEFIELD\", \"WHITE_DOTS\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("horse_style"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to horseStyle.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_horse_pattern"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetImmuneToZombification(isImmune: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (isImmune != null) {
    if (isImmune.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entitySetImmuneToZombification для аргумента is_immune получено значение = \"${isImmune.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("is_immune"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to isImmune.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_immune_to_zombification"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetInteractionResponsive(responsive: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (responsive != null) {
    if (responsive.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entitySetInteractionResponsive для аргумента responsive получено значение = \"${responsive.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("responsive"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to responsive.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_interaction_responsive"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetInteractionSize(width: Any, height: Any) {
            val widthARG: JNumber = when (width) {
                is Number -> JNumber(width)
is JNumber -> width
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetInteractionSize:width получен тип ${width.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val heightARG: JNumber = when (height) {
                is Number -> JNumber(height)
is JNumber -> height
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetInteractionSize:height получен тип ${height.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("width"),
    "value" to widthARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("height"),
    "value" to heightARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_interaction_size"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetInvisible(invisible: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (invisible != null) {
    if (invisible.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entitySetInvisible для аргумента invisible получено значение = \"${invisible.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("invisible"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to invisible.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_invisible"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetInvulnerabilityTicks(ticks: Any) {
            val ticksARG: JNumber = when (ticks) {
                is Number -> JNumber(ticks)
is JNumber -> ticks
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetInvulnerabilityTicks:ticks получен тип ${ticks.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("ticks"),
    "value" to ticksARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_invulnerability_ticks"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetInvulnerable(invulnerable: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (invulnerable != null) {
    if (invulnerable.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entitySetInvulnerable для аргумента invulnerable получено значение = \"${invulnerable.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("invulnerable"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to invulnerable.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_invulnerable"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetItem(item: Any) {
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В entitySetItem:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_item"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetItemDisplayItem(displayedItem: Any) {
val displayedItemARG: JItem = when (displayedItem) {
    is JItem -> displayedItem
    else -> {
        errorPrint("${currentScope.scope}: В entitySetItemDisplayItem:displayedItem получен тип ${displayedItem.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("displayed_item"),
    "value" to displayedItemARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_item_display_item"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetItemDisplayModelType(displayModelType: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (displayModelType != null) {
    if (displayModelType.value !in setOf("FIRSTPERSON_LEFTHAND", "FIRSTPERSON_RIGHTHAND", "FIXED", "GROUND", "GUI", "HEAD", "NONE", "THIRDPERSON_LEFTHAND", "THIRDPERSON_RIGHTHAND")) {
        errorPrint("${currentScope.scope}: В функции entitySetItemDisplayModelType для аргумента display_model_type получено значение = \"${displayModelType.value}\", ожидалось одно из: \"FIRSTPERSON_LEFTHAND\", \"FIRSTPERSON_RIGHTHAND\", \"FIXED\", \"GROUND\", \"GUI\", \"HEAD\", \"NONE\", \"THIRDPERSON_LEFTHAND\", \"THIRDPERSON_RIGHTHAND\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("display_model_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to displayModelType.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_item_display_model_type"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetItemInFrame(item: Any) {
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В entitySetItemInFrame:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_item_in_frame"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetLlamaType(type: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (type != null) {
    if (type.value !in setOf("BROWN", "CREAMY", "GRAY", "WHITE")) {
        errorPrint("${currentScope.scope}: В функции entitySetLlamaType для аргумента type получено значение = \"${type.value}\", ожидалось одно из: \"BROWN\", \"CREAMY\", \"GRAY\", \"WHITE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to type.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_llama_type"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetLocation(velocity: Any, increment: JString? = null) {
val velocityARG: JVector = when (velocity) {
    is JVector -> velocity
    else -> {
        errorPrint("${currentScope.scope}: В entitySetLocation:velocity получен тип ${velocity.javaClass.kotlin.simpleName}, ожидалось: JVector")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("velocity"),
    "value" to velocityARG.parse()
)))
if (increment != null) {
    if (increment.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entitySetLocation для аргумента increment получено значение = \"${increment.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("increment"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to increment.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_location"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetMarker(marker: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (marker != null) {
    if (marker.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entitySetMarker для аргумента marker получено значение = \"${marker.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("marker"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to marker.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_marker"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetMaxHealth(maxHealth: Any, healToMax: JString? = null) {
            val maxHealthARG: JNumber = when (maxHealth) {
                is Number -> JNumber(maxHealth)
is JNumber -> maxHealth
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetMaxHealth:maxHealth получен тип ${maxHealth.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("max_health"),
    "value" to maxHealthARG.parse()
)))
if (healToMax != null) {
    if (healToMax.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entitySetMaxHealth для аргумента heal_to_max получено значение = \"${healToMax.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("heal_to_max"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to healToMax.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_max_health"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetMerchantRecipe(result: Any, ingredientOne: Any, ingredientTwo: Any, uses: Any, maxUses: Any, index: Any, villagerExperience: Any, priceMultiplifier: Any, demand: Any, specialPrice: Any, mode: JString? = null, experienceReward: JString? = null, ignoreDiscounts: JString? = null) {
val resultARG: JItem = when (result) {
    is JItem -> result
    else -> {
        errorPrint("${currentScope.scope}: В entitySetMerchantRecipe:result получен тип ${result.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
val ingredientOneARG: JItem = when (ingredientOne) {
    is JItem -> ingredientOne
    else -> {
        errorPrint("${currentScope.scope}: В entitySetMerchantRecipe:ingredientOne получен тип ${ingredientOne.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
val ingredientTwoARG: JItem = when (ingredientTwo) {
    is JItem -> ingredientTwo
    else -> {
        errorPrint("${currentScope.scope}: В entitySetMerchantRecipe:ingredientTwo получен тип ${ingredientTwo.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
            val usesARG: JNumber = when (uses) {
                is Number -> JNumber(uses)
is JNumber -> uses
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetMerchantRecipe:uses получен тип ${uses.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val maxUsesARG: JNumber = when (maxUses) {
                is Number -> JNumber(maxUses)
is JNumber -> maxUses
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetMerchantRecipe:maxUses получен тип ${maxUses.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val indexARG: JNumber = when (index) {
                is Number -> JNumber(index)
is JNumber -> index
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetMerchantRecipe:index получен тип ${index.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val villagerExperienceARG: JNumber = when (villagerExperience) {
                is Number -> JNumber(villagerExperience)
is JNumber -> villagerExperience
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetMerchantRecipe:villagerExperience получен тип ${villagerExperience.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val priceMultiplifierARG: JNumber = when (priceMultiplifier) {
                is Number -> JNumber(priceMultiplifier)
is JNumber -> priceMultiplifier
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetMerchantRecipe:priceMultiplifier получен тип ${priceMultiplifier.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val demandARG: JNumber = when (demand) {
                is Number -> JNumber(demand)
is JNumber -> demand
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetMerchantRecipe:demand получен тип ${demand.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val specialPriceARG: JNumber = when (specialPrice) {
                is Number -> JNumber(specialPrice)
is JNumber -> specialPrice
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetMerchantRecipe:specialPrice получен тип ${specialPrice.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }



    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("result"),
    "value" to resultARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("ingredient_one"),
    "value" to ingredientOneARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("ingredient_two"),
    "value" to ingredientTwoARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("uses"),
    "value" to usesARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("max_uses"),
    "value" to maxUsesARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("index"),
    "value" to indexARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("villager_experience"),
    "value" to villagerExperienceARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("price_multiplifier"),
    "value" to priceMultiplifierARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("demand"),
    "value" to demandARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("special_price"),
    "value" to specialPriceARG.parse()
)))
if (mode != null) {
    if (mode.value !in setOf("APPEND", "MERGE")) {
        errorPrint("${currentScope.scope}: В функции entitySetMerchantRecipe для аргумента mode получено значение = \"${mode.value}\", ожидалось одно из: \"APPEND\", \"MERGE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to mode.jsonValue()
        ))
    )))
}
if (experienceReward != null) {
    if (experienceReward.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entitySetMerchantRecipe для аргумента experience_reward получено значение = \"${experienceReward.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("experience_reward"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to experienceReward.jsonValue()
        ))
    )))
}
if (ignoreDiscounts != null) {
    if (ignoreDiscounts.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entitySetMerchantRecipe для аргумента ignore_discounts получено значение = \"${ignoreDiscounts.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("ignore_discounts"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to ignoreDiscounts.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_merchant_recipe"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetMinecartBlock(block: Any, blockOffset: Any) {
val blockARG: JBlock = when (block) {
    is JBlock -> block
    else -> {
        errorPrint("${currentScope.scope}: В entitySetMinecartBlock:block получен тип ${block.javaClass.kotlin.simpleName}, ожидалось: JBlock")
        throw Exception()
    }
}
            val blockOffsetARG: JNumber = when (blockOffset) {
                is Number -> JNumber(blockOffset)
is JNumber -> blockOffset
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetMinecartBlock:blockOffset получен тип ${blockOffset.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("block"),
    "value" to blockARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("block_offset"),
    "value" to blockOffsetARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_minecart_block"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetMobAggressive(aggressive: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (aggressive != null) {
    if (aggressive.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entitySetMobAggressive для аргумента aggressive получено значение = \"${aggressive.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("aggressive"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to aggressive.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_mob_aggressive"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetMushroomCowType(cowType: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (cowType != null) {
    if (cowType.value !in setOf("BROWN", "RED")) {
        errorPrint("${currentScope.scope}: В функции entitySetMushroomCowType для аргумента cow_type получено значение = \"${cowType.value}\", ожидалось одно из: \"BROWN\", \"RED\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("cow_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to cowType.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_mushroom_cow_type"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityNoPhysics(noPhysics: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (noPhysics != null) {
    if (noPhysics.value !in setOf("TRUE", "FALSE")) {
        errorPrint("${currentScope.scope}: В функции entityNoPhysics для аргумента no_physics получено значение = \"${noPhysics.value}\", ожидалось одно из: \"TRUE\", \"FALSE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("no_physics"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to noPhysics.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_no_physics"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetPandaGene(gene: JString? = null, geneType: JString? = null) {


    val funValues = mutableListOf<JsonObject>()
if (gene != null) {
    if (gene.value !in setOf("BOTH", "HIDDEN", "MAIN")) {
        errorPrint("${currentScope.scope}: В функции entitySetPandaGene для аргумента gene получено значение = \"${gene.value}\", ожидалось одно из: \"BOTH\", \"HIDDEN\", \"MAIN\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("gene"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to gene.jsonValue()
        ))
    )))
}
if (geneType != null) {
    if (geneType.value !in setOf("AGGRESSIVE", "BROWN", "LAZY", "NORMAL", "PLAYFUL", "WEAK", "WORRIED")) {
        errorPrint("${currentScope.scope}: В функции entitySetPandaGene для аргумента gene_type получено значение = \"${geneType.value}\", ожидалось одно из: \"AGGRESSIVE\", \"BROWN\", \"LAZY\", \"NORMAL\", \"PLAYFUL\", \"WEAK\", \"WORRIED\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("gene_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to geneType.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_panda_gene"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetPandaOnBack(onBack: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (onBack != null) {
    if (onBack.value !in setOf("TRUE", "FALSE")) {
        errorPrint("${currentScope.scope}: В функции entitySetPandaOnBack для аргумента on_back получено значение = \"${onBack.value}\", ожидалось одно из: \"TRUE\", \"FALSE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("on_back"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to onBack.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_panda_on_back"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetPandaRolling(rolling: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (rolling != null) {
    if (rolling.value !in setOf("TRUE", "FALSE")) {
        errorPrint("${currentScope.scope}: В функции entitySetPandaRolling для аргумента rolling получено значение = \"${rolling.value}\", ожидалось одно из: \"TRUE\", \"FALSE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("rolling"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to rolling.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_panda_rolling"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetPandaSadTicks(sadTicks: Any) {
            val sadTicksARG: JNumber = when (sadTicks) {
                is Number -> JNumber(sadTicks)
is JNumber -> sadTicks
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetPandaSadTicks:sadTicks получен тип ${sadTicks.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("sad_ticks"),
    "value" to sadTicksARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_panda_sad_ticks"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetParrotType(parrotType: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (parrotType != null) {
    if (parrotType.value !in setOf("BLUE", "CYAN", "GRAY", "GREEN", "RED")) {
        errorPrint("${currentScope.scope}: В функции entitySetParrotType для аргумента parrot_type получено значение = \"${parrotType.value}\", ожидалось одно из: \"BLUE\", \"CYAN\", \"GRAY\", \"GREEN\", \"RED\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("parrot_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to parrotType.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_parrot_type"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetPersistence(persistence: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (persistence != null) {
    if (persistence.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entitySetPersistence для аргумента persistence получено значение = \"${persistence.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("persistence"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to persistence.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_persistence"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetPickup(canMobPickup: JString? = null, canPlayerPickup: JString? = null) {


    val funValues = mutableListOf<JsonObject>()
if (canMobPickup != null) {
    if (canMobPickup.value !in setOf("TRUE", "FALSE")) {
        errorPrint("${currentScope.scope}: В функции entitySetPickup для аргумента can_mob_pickup получено значение = \"${canMobPickup.value}\", ожидалось одно из: \"TRUE\", \"FALSE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("can_mob_pickup"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to canMobPickup.jsonValue()
        ))
    )))
}
if (canPlayerPickup != null) {
    if (canPlayerPickup.value !in setOf("TRUE", "FALSE")) {
        errorPrint("${currentScope.scope}: В функции entitySetPickup для аргумента can_player_pickup получено значение = \"${canPlayerPickup.value}\", ожидалось одно из: \"TRUE\", \"FALSE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("can_player_pickup"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to canPlayerPickup.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_pickup"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetPickupDelay(delay: Any) {
            val delayARG: JNumber = when (delay) {
                is Number -> JNumber(delay)
is JNumber -> delay
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetPickupDelay:delay получен тип ${delay.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("delay"),
    "value" to delayARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_pickup_delay"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetPiglinAbleToHunt(able: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (able != null) {
    if (able.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entitySetPiglinAbleToHunt для аргумента able получено значение = \"${able.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("able"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to able.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_piglin_able_to_hunt"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetPiglinChargingCrossbow(charging: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (charging != null) {
    if (charging.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entitySetPiglinChargingCrossbow для аргумента charging получено значение = \"${charging.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("charging"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to charging.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_piglin_charging_crossbow"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetPiglinDancing(dancingTime: Any) {
            val dancingTimeARG: JNumber = when (dancingTime) {
                is Number -> JNumber(dancingTime)
is JNumber -> dancingTime
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetPiglinDancing:dancingTime получен тип ${dancingTime.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("dancing_time"),
    "value" to dancingTimeARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_piglin_dancing"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetPose(pose: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (pose != null) {
    if (pose.value !in setOf("CROAKING", "CROUCHING", "DIGGING", "DYING", "EMERGING", "FALL_FLYING", "LONG_JUMPING", "ROARING", "SITTING", "SLEEPING", "SNEAKING", "SNIFFING", "SPIN_ATTACK", "STANDING", "SWIMMING", "USING_TONGUE")) {
        errorPrint("${currentScope.scope}: В функции entitySetPose для аргумента pose получено значение = \"${pose.value}\", ожидалось одно из: \"CROAKING\", \"CROUCHING\", \"DIGGING\", \"DYING\", \"EMERGING\", \"FALL_FLYING\", \"LONG_JUMPING\", \"ROARING\", \"SITTING\", \"SLEEPING\", \"SNEAKING\", \"SNIFFING\", \"SPIN_ATTACK\", \"STANDING\", \"SWIMMING\", \"USING_TONGUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("pose"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to pose.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_pose"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetPotionCloudRadius(radius: Any, shrinkingSpeed: Any) {
            val radiusARG: JNumber = when (radius) {
                is Number -> JNumber(radius)
is JNumber -> radius
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetPotionCloudRadius:radius получен тип ${radius.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val shrinkingSpeedARG: JNumber = when (shrinkingSpeed) {
                is Number -> JNumber(shrinkingSpeed)
is JNumber -> shrinkingSpeed
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetPotionCloudRadius:shrinkingSpeed получен тип ${shrinkingSpeed.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("radius"),
    "value" to radiusARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("shrinking_speed"),
    "value" to shrinkingSpeedARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_potion_cloud_radius"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetPrimedTntBlock(block: Any) {
val blockARG: JBlock = when (block) {
    is JBlock -> block
    else -> {
        errorPrint("${currentScope.scope}: В entitySetPrimedTntBlock:block получен тип ${block.javaClass.kotlin.simpleName}, ожидалось: JBlock")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("block"),
    "value" to blockARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_primed_tnt_block"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetProjectileDisplayItem(item: Any) {
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В entitySetProjectileDisplayItem:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_projectile_display_item"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetProjectilePower(power: Any) {
val powerARG: JVector = when (power) {
    is JVector -> power
    else -> {
        errorPrint("${currentScope.scope}: В entitySetProjectilePower:power получен тип ${power.javaClass.kotlin.simpleName}, ожидалось: JVector")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("power"),
    "value" to powerARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_projectile_power"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetProjectileShooter(uuid: Any) {
            val uuidARG: JString = when (uuid) {
                is String -> JString(uuid)
is JString -> uuid
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetProjectileShooter:uuid получен тип ${uuid.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("uuid"),
    "value" to uuidARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_projectile_shooter"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetRabbitType(rabbitType: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (rabbitType != null) {
    if (rabbitType.value !in setOf("BLACK", "BLACK_AND_WHITE", "BROWN", "GOLD", "SALT_AND_PEPPER", "THE_KILLER_BUNNY", "WHITE")) {
        errorPrint("${currentScope.scope}: В функции entitySetRabbitType для аргумента rabbit_type получено значение = \"${rabbitType.value}\", ожидалось одно из: \"BLACK\", \"BLACK_AND_WHITE\", \"BROWN\", \"GOLD\", \"SALT_AND_PEPPER\", \"THE_KILLER_BUNNY\", \"WHITE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("rabbit_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to rabbitType.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_rabbit_type"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetRearing(rearing: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (rearing != null) {
    if (rearing.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entitySetRearing для аргумента rearing получено значение = \"${rearing.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("rearing"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to rearing.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_rearing"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetRiptiding(riptiding: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (riptiding != null) {
    if (riptiding.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entitySetRiptiding для аргумента riptiding получено значение = \"${riptiding.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("riptiding"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to riptiding.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_riptiding"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetRotation(yaw: Any, pitch: Any) {
            val yawARG: JNumber = when (yaw) {
                is Number -> JNumber(yaw)
is JNumber -> yaw
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetRotation:yaw получен тип ${yaw.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val pitchARG: JNumber = when (pitch) {
                is Number -> JNumber(pitch)
is JNumber -> pitch
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetRotation:pitch получен тип ${pitch.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("yaw"),
    "value" to yawARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("pitch"),
    "value" to pitchARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_rotation"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetRotationByVector(vector: Any) {
val vectorARG: JVector = when (vector) {
    is JVector -> vector
    else -> {
        errorPrint("${currentScope.scope}: В entitySetRotationByVector:vector получен тип ${vector.javaClass.kotlin.simpleName}, ожидалось: JVector")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("vector"),
    "value" to vectorARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_rotation_by_vector"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetSheepSheared(sheared: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (sheared != null) {
    if (sheared.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entitySetSheepSheared для аргумента sheared получено значение = \"${sheared.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("sheared"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to sheared.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_sheep_sheared"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetShulkerBulletTarget(target: Any) {
            val targetARG: JString = when (target) {
                is String -> JString(target)
is JString -> target
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetShulkerBulletTarget:target получен тип ${target.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("target"),
    "value" to targetARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_shulker_bullet_target"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetShulkerPeek(rolling: Any, silent: JString? = null) {
            val rollingARG: JNumber = when (rolling) {
                is Number -> JNumber(rolling)
is JNumber -> rolling
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetShulkerPeek:rolling получен тип ${rolling.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("rolling"),
    "value" to rollingARG.parse()
)))
if (silent != null) {
    if (silent.value !in setOf("TRUE", "FALSE")) {
        errorPrint("${currentScope.scope}: В функции entitySetShulkerPeek для аргумента silent получено значение = \"${silent.value}\", ожидалось одно из: \"TRUE\", \"FALSE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("silent"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to silent.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_shulker_peek"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetSilenced(silenced: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (silenced != null) {
    if (silenced.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entitySetSilenced для аргумента silenced получено значение = \"${silenced.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("silenced"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to silenced.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_silenced"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetSitting(sitting: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (sitting != null) {
    if (sitting.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entitySetSitting для аргумента sitting получено значение = \"${sitting.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("sitting"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to sitting.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_sitting"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetSize(size: Any) {
            val sizeARG: JNumber = when (size) {
                is Number -> JNumber(size)
is JNumber -> size
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetSize:size получен тип ${size.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("size"),
    "value" to sizeARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_size"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetSnifferState(state: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (state != null) {
    if (state.value !in setOf("DIGGING", "FEELING_HAPPY", "IDLING", "RISING", "SCENTING", "SEARCHING", "SNIFFING")) {
        errorPrint("${currentScope.scope}: В функции entitySetSnifferState для аргумента state получено значение = \"${state.value}\", ожидалось одно из: \"DIGGING\", \"FEELING_HAPPY\", \"IDLING\", \"RISING\", \"SCENTING\", \"SEARCHING\", \"SNIFFING\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("state"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to state.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_sniffer_state"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetSnowmanPumpkin(pumpkin: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (pumpkin != null) {
    if (pumpkin.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entitySetSnowmanPumpkin для аргумента pumpkin получено значение = \"${pumpkin.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("pumpkin"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to pumpkin.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_snowman_pumpkin"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetTame(nameOrUuid: Any) {
            val nameOrUuidARG: JString = when (nameOrUuid) {
                is String -> JString(nameOrUuid)
is JString -> nameOrUuid
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetTame:nameOrUuid получен тип ${nameOrUuid.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("name_or_uuid"),
    "value" to nameOrUuidARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_tame"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetTarget(nameOrUuid: Any) {
            val nameOrUuidARG: JString = when (nameOrUuid) {
                is String -> JString(nameOrUuid)
is JString -> nameOrUuid
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetTarget:nameOrUuid получен тип ${nameOrUuid.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("name_or_uuid"),
    "value" to nameOrUuidARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_target"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetTextDisplayAlignment(textAlignment: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (textAlignment != null) {
    if (textAlignment.value !in setOf("CENTER", "LEFT", "RIGHT")) {
        errorPrint("${currentScope.scope}: В функции entitySetTextDisplayAlignment для аргумента text_alignment получено значение = \"${textAlignment.value}\", ожидалось одно из: \"CENTER\", \"LEFT\", \"RIGHT\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("text_alignment"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to textAlignment.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_text_display_alignment"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetTextDisplayBackground(colorHexadecimal: Any, opacity: Any) {
            val colorHexadecimalARG: JString = when (colorHexadecimal) {
                is String -> JString(colorHexadecimal)
is JString -> colorHexadecimal
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetTextDisplayBackground:colorHexadecimal получен тип ${colorHexadecimal.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val opacityARG: JNumber = when (opacity) {
                is Number -> JNumber(opacity)
is JNumber -> opacity
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetTextDisplayBackground:opacity получен тип ${opacity.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("color_hexadecimal"),
    "value" to colorHexadecimalARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("opacity"),
    "value" to opacityARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_text_display_background"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetTextDisplayLineWidth(lineWidth: Any) {
            val lineWidthARG: JNumber = when (lineWidth) {
                is Number -> JNumber(lineWidth)
is JNumber -> lineWidth
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetTextDisplayLineWidth:lineWidth получен тип ${lineWidth.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("line_width"),
    "value" to lineWidthARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_text_display_line_width"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetTextDisplayOpacity(textOpacity: Any) {
            val textOpacityARG: JNumber = when (textOpacity) {
                is Number -> JNumber(textOpacity)
is JNumber -> textOpacity
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetTextDisplayOpacity:textOpacity получен тип ${textOpacity.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("text_opacity"),
    "value" to textOpacityARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_text_display_opacity"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetTextDisplaySeeThrough(enableSeeThrough: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (enableSeeThrough != null) {
    if (enableSeeThrough.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entitySetTextDisplaySeeThrough для аргумента enable_see_through получено значение = \"${enableSeeThrough.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("enable_see_through"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to enableSeeThrough.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_text_display_see_through"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetTextDisplayText(displayedText: Any, mergingMode: JString? = null) {
            val displayedTextARG: JString = when (displayedText) {
                is String -> JString(displayedText)
is JString -> displayedText
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetTextDisplayText:displayedText получен тип ${displayedText.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("displayed_text"),
    "value" to displayedTextARG.parse()
)))
if (mergingMode != null) {
    if (mergingMode.value !in setOf("CONCATENATION", "SEPARATE_LINES", "SPACES")) {
        errorPrint("${currentScope.scope}: В функции entitySetTextDisplayText для аргумента merging_mode получено значение = \"${mergingMode.value}\", ожидалось одно из: \"CONCATENATION\", \"SEPARATE_LINES\", \"SPACES\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("merging_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to mergingMode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_text_display_text"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetTextDisplayTextShadow(enableTextShadow: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (enableTextShadow != null) {
    if (enableTextShadow.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entitySetTextDisplayTextShadow для аргумента enable_text_shadow получено значение = \"${enableTextShadow.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("enable_text_shadow"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to enableTextShadow.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_text_display_text_shadow"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetTropicalFishPattern(patternColor: JString? = null, bodyColor: JString? = null, pattern: JString? = null) {



    val funValues = mutableListOf<JsonObject>()
if (patternColor != null) {
    if (patternColor.value !in setOf("BLACK", "BLUE", "BROWN", "CYAN", "DO_NOT_CHANGE", "GRAY", "GREEN", "LIGHT_BLUE", "LIGHT_GRAY", "LIME", "MAGENTA", "ORANGE", "PINK", "PURPLE", "RED", "WHITE", "YELLOW")) {
        errorPrint("${currentScope.scope}: В функции entitySetTropicalFishPattern для аргумента pattern_color получено значение = \"${patternColor.value}\", ожидалось одно из: \"BLACK\", \"BLUE\", \"BROWN\", \"CYAN\", \"DO_NOT_CHANGE\", \"GRAY\", \"GREEN\", \"LIGHT_BLUE\", \"LIGHT_GRAY\", \"LIME\", \"MAGENTA\", \"ORANGE\", \"PINK\", \"PURPLE\", \"RED\", \"WHITE\", \"YELLOW\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("pattern_color"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to patternColor.jsonValue()
        ))
    )))
}
if (bodyColor != null) {
    if (bodyColor.value !in setOf("BLACK", "BLUE", "BROWN", "CYAN", "DO_NOT_CHANGE", "GRAY", "GREEN", "LIGHT_BLUE", "LIGHT_GRAY", "LIME", "MAGENTA", "ORANGE", "PINK", "PURPLE", "RED", "WHITE", "YELLOW")) {
        errorPrint("${currentScope.scope}: В функции entitySetTropicalFishPattern для аргумента body_color получено значение = \"${bodyColor.value}\", ожидалось одно из: \"BLACK\", \"BLUE\", \"BROWN\", \"CYAN\", \"DO_NOT_CHANGE\", \"GRAY\", \"GREEN\", \"LIGHT_BLUE\", \"LIGHT_GRAY\", \"LIME\", \"MAGENTA\", \"ORANGE\", \"PINK\", \"PURPLE\", \"RED\", \"WHITE\", \"YELLOW\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("body_color"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to bodyColor.jsonValue()
        ))
    )))
}
if (pattern != null) {
    if (pattern.value !in setOf("BETTY", "BLOCKFISH", "BRINELY", "CLAYFISH", "DASHER", "DO_NOT_CHANGE", "FLOPPER", "GLITTER", "KOB", "SNOOPER", "SPOTTY", "STRIPEY", "SUNSTREAK")) {
        errorPrint("${currentScope.scope}: В функции entitySetTropicalFishPattern для аргумента pattern получено значение = \"${pattern.value}\", ожидалось одно из: \"BETTY\", \"BLOCKFISH\", \"BRINELY\", \"CLAYFISH\", \"DASHER\", \"DO_NOT_CHANGE\", \"FLOPPER\", \"GLITTER\", \"KOB\", \"SNOOPER\", \"SPOTTY\", \"STRIPEY\", \"SUNSTREAK\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("pattern"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to pattern.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_tropical_fish_pattern"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetVexCharging(charging: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (charging != null) {
    if (charging.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entitySetVexCharging для аргумента charging получено значение = \"${charging.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("charging"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to charging.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_vex_charging"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetVexLimitedLifetimeTicks(lifetime: Any) {
            val lifetimeARG: JNumber = when (lifetime) {
                is Number -> JNumber(lifetime)
is JNumber -> lifetime
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetVexLimitedLifetimeTicks:lifetime получен тип ${lifetime.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("lifetime"),
    "value" to lifetimeARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_vex_limited_lifetime_ticks"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetVillagerBiome(biome: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (biome != null) {
    if (biome.value !in setOf("DESERT", "JUNGLE", "PLAINS", "SAVANNA", "SNOW", "SWAMP", "TAIGA")) {
        errorPrint("${currentScope.scope}: В функции entitySetVillagerBiome для аргумента biome получено значение = \"${biome.value}\", ожидалось одно из: \"DESERT\", \"JUNGLE\", \"PLAINS\", \"SAVANNA\", \"SNOW\", \"SWAMP\", \"TAIGA\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("biome"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to biome.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_villager_biome"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetVillagerExperience(experience: Any) {
            val experienceARG: JNumber = when (experience) {
                is Number -> JNumber(experience)
is JNumber -> experience
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetVillagerExperience:experience получен тип ${experience.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("experience"),
    "value" to experienceARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_villager_experience"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetVillagerProfession(profession: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (profession != null) {
    if (profession.value !in setOf("ARMORER", "BUTCHER", "CARTOGRAPHER", "CLERIC", "FARMER", "FISHERMAN", "FLETCHER", "LEATHERWORKER", "LIBRARIAN", "MASON", "NITWIT", "NONE", "SHEPHERD", "TOOLSMITH", "WEAPONSMITH")) {
        errorPrint("${currentScope.scope}: В функции entitySetVillagerProfession для аргумента profession получено значение = \"${profession.value}\", ожидалось одно из: \"ARMORER\", \"BUTCHER\", \"CARTOGRAPHER\", \"CLERIC\", \"FARMER\", \"FISHERMAN\", \"FLETCHER\", \"LEATHERWORKER\", \"LIBRARIAN\", \"MASON\", \"NITWIT\", \"NONE\", \"SHEPHERD\", \"TOOLSMITH\", \"WEAPONSMITH\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("profession"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to profession.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_villager_profession"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetVisualFire(visualFire: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (visualFire != null) {
    if (visualFire.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entitySetVisualFire для аргумента visual_fire получено значение = \"${visualFire.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("visual_fire"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to visualFire.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_visual_fire"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetWardenAngerLevel(nameOrUuid: Any, anger: Any) {
            val nameOrUuidARG: JString = when (nameOrUuid) {
                is String -> JString(nameOrUuid)
is JString -> nameOrUuid
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetWardenAngerLevel:nameOrUuid получен тип ${nameOrUuid.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val angerARG: JNumber = when (anger) {
                is Number -> JNumber(anger)
is JNumber -> anger
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetWardenAngerLevel:anger получен тип ${anger.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("name_or_uuid"),
    "value" to nameOrUuidARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("anger"),
    "value" to angerARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_warden_anger_level"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetWardenDigging(digging: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (digging != null) {
    if (digging.value !in setOf("DIG_DOWN", "EMERGE")) {
        errorPrint("${currentScope.scope}: В функции entitySetWardenDigging для аргумента digging получено значение = \"${digging.value}\", ожидалось одно из: \"DIG_DOWN\", \"EMERGE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("digging"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to digging.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_warden_digging"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetWearingSaddle(wearing: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (wearing != null) {
    if (wearing.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entitySetWearingSaddle для аргумента wearing получено значение = \"${wearing.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("wearing"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to wearing.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_wearing_saddle"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetWitherInvulnerabilityTicks(ticks: Any) {
            val ticksARG: JNumber = when (ticks) {
                is Number -> JNumber(ticks)
is JNumber -> ticks
                else -> {
                    errorPrint("${currentScope.scope}: В entitySetWitherInvulnerabilityTicks:ticks получен тип ${ticks.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("ticks"),
    "value" to ticksARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_wither_invulnerability_ticks"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetWolfType(wolfType: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (wolfType != null) {
    if (wolfType.value !in setOf("ASHEN", "SNOWY", "RUSTY", "BLACK", "CHESTNUT", "SPOTTED", "STRIPED", "PALE")) {
        errorPrint("${currentScope.scope}: В функции entitySetWolfType для аргумента wolf_type получено значение = \"${wolfType.value}\", ожидалось одно из: \"ASHEN\", \"SNOWY\", \"RUSTY\", \"BLACK\", \"CHESTNUT\", \"SPOTTED\", \"STRIPED\", \"PALE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("wolf_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to wolfType.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_wolf_type"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySetZombieArmsRaised(armsRaised: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (armsRaised != null) {
    if (armsRaised.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entitySetZombieArmsRaised для аргумента arms_raised получено значение = \"${armsRaised.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("arms_raised"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to armsRaised.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_set_zombie_arms_raised"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityShear() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_shear"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityShearSheep() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_shear_sheep"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySleep(sleep: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (sleep != null) {
    if (sleep.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entitySleep для аргумента sleep получено значение = \"${sleep.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("sleep"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to sleep.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_sleep"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySwingHand(handType: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (handType != null) {
    if (handType.value !in setOf("MAIN", "OFF")) {
        errorPrint("${currentScope.scope}: В функции entitySwingHand для аргумента hand_type получено значение = \"${handType.value}\", ожидалось одно из: \"MAIN\", \"OFF\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("hand_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to handType.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_swing_hand"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityTeleport(location: Any, keepRotation: JString? = null) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В entityTeleport:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
if (keepRotation != null) {
    if (keepRotation.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entityTeleport для аргумента keep_rotation получено значение = \"${keepRotation.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("keep_rotation"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to keepRotation.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_teleport"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityUseItem(hand: JString? = null, enable: JString? = null) {


    val funValues = mutableListOf<JsonObject>()
if (hand != null) {
    if (hand.value !in setOf("MAIN_HAND", "OFF_HAND")) {
        errorPrint("${currentScope.scope}: В функции entityUseItem для аргумента hand получено значение = \"${hand.value}\", ожидалось одно из: \"MAIN_HAND\", \"OFF_HAND\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("hand"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to hand.jsonValue()
        ))
    )))
}
if (enable != null) {
    if (enable.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entityUseItem для аргумента enable получено значение = \"${enable.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("enable"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to enable.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("entity_use_item"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldBlockGrowth(location: Any, growthStage: Any, growthType: JString? = null) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldBlockGrowth:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val growthStageARG: JNumber = when (growthStage) {
                is Number -> JNumber(growthStage)
is JNumber -> growthStage
                else -> {
                    errorPrint("${currentScope.scope}: В worldBlockGrowth:growthStage получен тип ${growthStage.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("growth_stage"),
    "value" to growthStageARG.parse()
)))
if (growthType != null) {
    if (growthType.value !in setOf("PERCENTAGE", "STAGE_NUMBER")) {
        errorPrint("${currentScope.scope}: В функции worldBlockGrowth для аргумента growth_type получено значение = \"${growthType.value}\", ожидалось одно из: \"PERCENTAGE\", \"STAGE_NUMBER\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("growth_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to growthType.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_block_growth"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldBloomSkulkCatalyst(location: Any, bloomLocation: Any, charge: Any) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldBloomSkulkCatalyst:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
val bloomLocationARG: JLocation = when (bloomLocation) {
    is JLocation -> bloomLocation
    else -> {
        errorPrint("${currentScope.scope}: В worldBloomSkulkCatalyst:bloomLocation получен тип ${bloomLocation.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val chargeARG: JNumber = when (charge) {
                is Number -> JNumber(charge)
is JNumber -> charge
                else -> {
                    errorPrint("${currentScope.scope}: В worldBloomSkulkCatalyst:charge получен тип ${charge.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("bloom_location"),
    "value" to bloomLocationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("charge"),
    "value" to chargeARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_bloom_skulk_catalyst"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldBoneMealBlock(location: Any, count: Any) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldBoneMealBlock:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val countARG: JNumber = when (count) {
                is Number -> JNumber(count)
is JNumber -> count
                else -> {
                    errorPrint("${currentScope.scope}: В worldBoneMealBlock:count получен тип ${count.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("count"),
    "value" to countARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_bone_meal_block"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldBreakBlock(locations: Any, tool: Any, dropExp: JString? = null) {
val locationsARG: JLocation = when (locations) {
    is JLocation -> locations
    else -> {
        errorPrint("${currentScope.scope}: В worldBreakBlock:locations получен тип ${locations.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
val toolARG: JItem = when (tool) {
    is JItem -> tool
    else -> {
        errorPrint("${currentScope.scope}: В worldBreakBlock:tool получен тип ${tool.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("locations"),
    "value" to locationsARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("tool"),
    "value" to toolARG.parse()
)))
if (dropExp != null) {
    if (dropExp.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции worldBreakBlock для аргумента drop_exp получено значение = \"${dropExp.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("drop_exp"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to dropExp.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_break_block"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldCancelEvent() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_cancel_event"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldClearContainer(location: Any) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldClearContainer:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_clear_container"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldClearContainerItems(items: Any, location: Any) {
val itemsARG: JItem = when (items) {
    is JItem -> items
    else -> {
        errorPrint("${currentScope.scope}: В worldClearContainerItems:items получен тип ${items.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldClearContainerItems:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("items"),
    "value" to itemsARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_clear_container_items"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldClearExplodedBlocks(location: Any) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldClearExplodedBlocks:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_clear_exploded_blocks"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldClearRegion(pos1: Any, pos2: Any) {
val pos1ARG: JLocation = when (pos1) {
    is JLocation -> pos1
    else -> {
        errorPrint("${currentScope.scope}: В worldClearRegion:pos1 получен тип ${pos1.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
val pos2ARG: JLocation = when (pos2) {
    is JLocation -> pos2
    else -> {
        errorPrint("${currentScope.scope}: В worldClearRegion:pos2 получен тип ${pos2.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("pos_1"),
    "value" to pos1ARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("pos_2"),
    "value" to pos2ARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_clear_region"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldClearScoreboardScores(id: Any) {
            val idARG: JString = when (id) {
                is String -> JString(id)
is JString -> id
                else -> {
                    errorPrint("${currentScope.scope}: В worldClearScoreboardScores:id получен тип ${id.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("id"),
    "value" to idARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_clear_scoreboard_scores"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldCloneRegion(pos1: Any, pos2: Any, targetPos: Any, pastePos: Any, ignoreAir: JString? = null, copyEntity: JString? = null) {
val pos1ARG: JLocation = when (pos1) {
    is JLocation -> pos1
    else -> {
        errorPrint("${currentScope.scope}: В worldCloneRegion:pos1 получен тип ${pos1.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
val pos2ARG: JLocation = when (pos2) {
    is JLocation -> pos2
    else -> {
        errorPrint("${currentScope.scope}: В worldCloneRegion:pos2 получен тип ${pos2.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
val targetPosARG: JLocation = when (targetPos) {
    is JLocation -> targetPos
    else -> {
        errorPrint("${currentScope.scope}: В worldCloneRegion:targetPos получен тип ${targetPos.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
val pastePosARG: JLocation = when (pastePos) {
    is JLocation -> pastePos
    else -> {
        errorPrint("${currentScope.scope}: В worldCloneRegion:pastePos получен тип ${pastePos.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}


    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("pos_1"),
    "value" to pos1ARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("pos_2"),
    "value" to pos2ARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("target_pos"),
    "value" to targetPosARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("paste_pos"),
    "value" to pastePosARG.parse()
)))
if (ignoreAir != null) {
    if (ignoreAir.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции worldCloneRegion для аргумента ignore_air получено значение = \"${ignoreAir.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("ignore_air"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to ignoreAir.jsonValue()
        ))
    )))
}
if (copyEntity != null) {
    if (copyEntity.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции worldCloneRegion для аргумента copy_entity получено значение = \"${copyEntity.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("copy_entity"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to copyEntity.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_clone_region"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldCreateExplosion(location: Any, power: Any) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldCreateExplosion:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val powerARG: JNumber = when (power) {
                is Number -> JNumber(power)
is JNumber -> power
                else -> {
                    errorPrint("${currentScope.scope}: В worldCreateExplosion:power получен тип ${power.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("power"),
    "value" to powerARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_create_explosion"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldCreateScoreboard(id: Any, displayName: Any) {
            val idARG: JString = when (id) {
                is String -> JString(id)
is JString -> id
                else -> {
                    errorPrint("${currentScope.scope}: В worldCreateScoreboard:id получен тип ${id.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val displayNameARG: JString = when (displayName) {
                is String -> JString(displayName)
is JString -> displayName
                else -> {
                    errorPrint("${currentScope.scope}: В worldCreateScoreboard:displayName получен тип ${displayName.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("id"),
    "value" to idARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("display_name"),
    "value" to displayNameARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_create_scoreboard"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldFillContainer(items: Any, location: Any) {
val itemsARG: JItem = when (items) {
    is JItem -> items
    else -> {
        errorPrint("${currentScope.scope}: В worldFillContainer:items получен тип ${items.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldFillContainer:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("items"),
    "value" to itemsARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_fill_container"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldGenerateTree(location: Any, treeType: JString? = null) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldGenerateTree:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
if (treeType != null) {
    if (treeType.value !in setOf("ACACIA", "AZALEA", "BIG_TREE", "BIRCH", "BROWN_MUSHROOM", "CHERRY", "CHORUS_PLANT", "COCOA_TREE", "CRIMSON_FUNGUS", "DARK_OAK", "JUNGLE", "JUNGLE_BUSH", "MANGROVE", "MEGA_REDWOOD", "REDWOOD", "RED_MUSHROOM", "SMALL_JUNGLE", "SWAMP", "TALL_BIRCH", "TALL_MANGROVE", "TALL_REDWOOD", "TREE", "WARPED_FUNGUS")) {
        errorPrint("${currentScope.scope}: В функции worldGenerateTree для аргумента tree_type получено значение = \"${treeType.value}\", ожидалось одно из: \"ACACIA\", \"AZALEA\", \"BIG_TREE\", \"BIRCH\", \"BROWN_MUSHROOM\", \"CHERRY\", \"CHORUS_PLANT\", \"COCOA_TREE\", \"CRIMSON_FUNGUS\", \"DARK_OAK\", \"JUNGLE\", \"JUNGLE_BUSH\", \"MANGROVE\", \"MEGA_REDWOOD\", \"REDWOOD\", \"RED_MUSHROOM\", \"SMALL_JUNGLE\", \"SWAMP\", \"TALL_BIRCH\", \"TALL_MANGROVE\", \"TALL_REDWOOD\", \"TREE\", \"WARPED_FUNGUS\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("tree_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to treeType.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_generate_tree"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldHideEventMessage(hide: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (hide != null) {
    if (hide.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции worldHideEventMessage для аргумента hide получено значение = \"${hide.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("hide"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to hide.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_hide_event_message"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldLaunchFirework(firework: Any, location: Any, movement: JString? = null, instant: JString? = null) {
val fireworkARG: JItem = when (firework) {
    is JItem -> firework
    else -> {
        errorPrint("${currentScope.scope}: В worldLaunchFirework:firework получен тип ${firework.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldLaunchFirework:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}


    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("firework"),
    "value" to fireworkARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
if (movement != null) {
    if (movement.value !in setOf("DIRECTIONAL", "UPWARDS")) {
        errorPrint("${currentScope.scope}: В функции worldLaunchFirework для аргумента movement получено значение = \"${movement.value}\", ожидалось одно из: \"DIRECTIONAL\", \"UPWARDS\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("movement"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to movement.jsonValue()
        ))
    )))
}
if (instant != null) {
    if (instant.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции worldLaunchFirework для аргумента instant получено значение = \"${instant.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("instant"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to instant.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_launch_firework"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldLaunchProjectile(projectile: Any, location: Any, speed: Any, inaccuracy: Any, customName: Any, trail: Any) {
val projectileARG: JItem = when (projectile) {
    is JItem -> projectile
    else -> {
        errorPrint("${currentScope.scope}: В worldLaunchProjectile:projectile получен тип ${projectile.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldLaunchProjectile:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val speedARG: JNumber = when (speed) {
                is Number -> JNumber(speed)
is JNumber -> speed
                else -> {
                    errorPrint("${currentScope.scope}: В worldLaunchProjectile:speed получен тип ${speed.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val inaccuracyARG: JNumber = when (inaccuracy) {
                is Number -> JNumber(inaccuracy)
is JNumber -> inaccuracy
                else -> {
                    errorPrint("${currentScope.scope}: В worldLaunchProjectile:inaccuracy получен тип ${inaccuracy.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val customNameARG: JString = when (customName) {
                is String -> JString(customName)
is JString -> customName
                else -> {
                    errorPrint("${currentScope.scope}: В worldLaunchProjectile:customName получен тип ${customName.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
val trailARG: JParticle = when (trail) {
    is JParticle -> trail
    else -> {
        errorPrint("${currentScope.scope}: В worldLaunchProjectile:trail получен тип ${trail.javaClass.kotlin.simpleName}, ожидалось: JParticle")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("projectile"),
    "value" to projectileARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("speed"),
    "value" to speedARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("inaccuracy"),
    "value" to inaccuracyARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("custom_name"),
    "value" to customNameARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("trail"),
    "value" to trailARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_launch_projectile"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldRandomTickBlock(location: Any, times: Any) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldRandomTickBlock:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val timesARG: JNumber = when (times) {
                is Number -> JNumber(times)
is JNumber -> times
                else -> {
                    errorPrint("${currentScope.scope}: В worldRandomTickBlock:times получен тип ${times.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("times"),
    "value" to timesARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_random_tick_block"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldRemoveContainerItems(items: Any, location: Any) {
val itemsARG: JItem = when (items) {
    is JItem -> items
    else -> {
        errorPrint("${currentScope.scope}: В worldRemoveContainerItems:items получен тип ${items.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldRemoveContainerItems:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("items"),
    "value" to itemsARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_remove_container_items"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldRemoveScoreboard(id: Any) {
            val idARG: JString = when (id) {
                is String -> JString(id)
is JString -> id
                else -> {
                    errorPrint("${currentScope.scope}: В worldRemoveScoreboard:id получен тип ${id.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("id"),
    "value" to idARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_remove_scoreboard"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldRemoveScoreboardScoreByName(id: Any, text: Any) {
            val idARG: JString = when (id) {
                is String -> JString(id)
is JString -> id
                else -> {
                    errorPrint("${currentScope.scope}: В worldRemoveScoreboardScoreByName:id получен тип ${id.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val textARG: JString = when (text) {
                is String -> JString(text)
is JString -> text
                else -> {
                    errorPrint("${currentScope.scope}: В worldRemoveScoreboardScoreByName:text получен тип ${text.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("id"),
    "value" to idARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("text"),
    "value" to textARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_remove_scoreboard_score_by_name"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldRemoveScoreboardScoreByScore(id: Any, score: Any) {
            val idARG: JString = when (id) {
                is String -> JString(id)
is JString -> id
                else -> {
                    errorPrint("${currentScope.scope}: В worldRemoveScoreboardScoreByScore:id получен тип ${id.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val scoreARG: JNumber = when (score) {
                is Number -> JNumber(score)
is JNumber -> score
                else -> {
                    errorPrint("${currentScope.scope}: В worldRemoveScoreboardScoreByScore:score получен тип ${score.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("id"),
    "value" to idARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("score"),
    "value" to scoreARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_remove_scoreboard_score_by_score"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldReplaceBlocksInRegion(oldBlock: Any, pos1: Any, pos2: Any, newBlock: Any) {
val oldBlockARG: JBlock = when (oldBlock) {
    is JBlock -> oldBlock
    else -> {
        errorPrint("${currentScope.scope}: В worldReplaceBlocksInRegion:oldBlock получен тип ${oldBlock.javaClass.kotlin.simpleName}, ожидалось: JBlock")
        throw Exception()
    }
}
val pos1ARG: JLocation = when (pos1) {
    is JLocation -> pos1
    else -> {
        errorPrint("${currentScope.scope}: В worldReplaceBlocksInRegion:pos1 получен тип ${pos1.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
val pos2ARG: JLocation = when (pos2) {
    is JLocation -> pos2
    else -> {
        errorPrint("${currentScope.scope}: В worldReplaceBlocksInRegion:pos2 получен тип ${pos2.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
val newBlockARG: JBlock = when (newBlock) {
    is JBlock -> newBlock
    else -> {
        errorPrint("${currentScope.scope}: В worldReplaceBlocksInRegion:newBlock получен тип ${newBlock.javaClass.kotlin.simpleName}, ожидалось: JBlock")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("old_block"),
    "value" to oldBlockARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("pos_1"),
    "value" to pos1ARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("pos_2"),
    "value" to pos2ARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("new_block"),
    "value" to newBlockARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_replace_blocks_in_region"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldReplaceContainerItems(items: Any, location: Any, replace: Any, count: Any) {
val itemsARG: JItem = when (items) {
    is JItem -> items
    else -> {
        errorPrint("${currentScope.scope}: В worldReplaceContainerItems:items получен тип ${items.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldReplaceContainerItems:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
val replaceARG: JItem = when (replace) {
    is JItem -> replace
    else -> {
        errorPrint("${currentScope.scope}: В worldReplaceContainerItems:replace получен тип ${replace.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
            val countARG: JNumber = when (count) {
                is Number -> JNumber(count)
is JNumber -> count
                else -> {
                    errorPrint("${currentScope.scope}: В worldReplaceContainerItems:count получен тип ${count.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("items"),
    "value" to itemsARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("replace"),
    "value" to replaceARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("count"),
    "value" to countARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_replace_container_items"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSendWebRequest(url: Any, contentBody: Any, requestType: JString? = null, contentType: JString? = null) {
            val urlARG: JString = when (url) {
                is String -> JString(url)
is JString -> url
                else -> {
                    errorPrint("${currentScope.scope}: В worldSendWebRequest:url получен тип ${url.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val contentBodyARG: JString = when (contentBody) {
                is String -> JString(contentBody)
is JString -> contentBody
                else -> {
                    errorPrint("${currentScope.scope}: В worldSendWebRequest:contentBody получен тип ${contentBody.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }


    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("url"),
    "value" to urlARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("content_body"),
    "value" to contentBodyARG.parse()
)))
if (requestType != null) {
    if (requestType.value !in setOf("DELETE", "GET", "POST", "PUT")) {
        errorPrint("${currentScope.scope}: В функции worldSendWebRequest для аргумента request_type получено значение = \"${requestType.value}\", ожидалось одно из: \"DELETE\", \"GET\", \"POST\", \"PUT\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("request_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to requestType.jsonValue()
        ))
    )))
}
if (contentType != null) {
    if (contentType.value !in setOf("APPLICATION_JSON", "TEXT_PLAIN")) {
        errorPrint("${currentScope.scope}: В функции worldSendWebRequest для аргумента content_type получено значение = \"${contentType.value}\", ожидалось одно из: \"APPLICATION_JSON\", \"TEXT_PLAIN\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("content_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to contentType.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_send_web_request"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSetAge(location: Any, tick: Any) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldSetAge:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val tickARG: JNumber = when (tick) {
                is Number -> JNumber(tick)
is JNumber -> tick
                else -> {
                    errorPrint("${currentScope.scope}: В worldSetAge:tick получен тип ${tick.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("tick"),
    "value" to tickARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_set_age"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSetBlock(locations: Any, block: Any, updateBlocks: JString? = null) {
val locationsARG: JLocation = when (locations) {
    is JLocation -> locations
    else -> {
        errorPrint("${currentScope.scope}: В worldSetBlock:locations получен тип ${locations.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
val blockARG: JBlock = when (block) {
    is JBlock -> block
    else -> {
        errorPrint("${currentScope.scope}: В worldSetBlock:block получен тип ${block.javaClass.kotlin.simpleName}, ожидалось: JBlock")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("locations"),
    "value" to locationsARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("block"),
    "value" to blockARG.parse()
)))
if (updateBlocks != null) {
    if (updateBlocks.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции worldSetBlock для аргумента update_blocks получено значение = \"${updateBlocks.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("update_blocks"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to updateBlocks.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_set_block"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSetBlockAnaloguePower(location: Any, powerLevel: Any) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldSetBlockAnaloguePower:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val powerLevelARG: JNumber = when (powerLevel) {
                is Number -> JNumber(powerLevel)
is JNumber -> powerLevel
                else -> {
                    errorPrint("${currentScope.scope}: В worldSetBlockAnaloguePower:powerLevel получен тип ${powerLevel.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("power_level"),
    "value" to powerLevelARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_set_block_analogue_power"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSetBlockCustomTag(location: Any, tagName: Any, tagValue: Any) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldSetBlockCustomTag:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val tagNameARG: JString = when (tagName) {
                is String -> JString(tagName)
is JString -> tagName
                else -> {
                    errorPrint("${currentScope.scope}: В worldSetBlockCustomTag:tagName получен тип ${tagName.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val tagValueARG: JString = when (tagValue) {
                is String -> JString(tagValue)
is JString -> tagValue
                else -> {
                    errorPrint("${currentScope.scope}: В worldSetBlockCustomTag:tagValue получен тип ${tagValue.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("tag_name"),
    "value" to tagNameARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("tag_value"),
    "value" to tagValueARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_set_block_custom_tag"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSetBlockData(location: Any, blockData: Any) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldSetBlockData:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val blockDataARG: JString = when (blockData) {
                is String -> JString(blockData)
is JString -> blockData
                else -> {
                    errorPrint("${currentScope.scope}: В worldSetBlockData:blockData получен тип ${blockData.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("block_data"),
    "value" to blockDataARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_set_block_data"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSetBlockDropsEnabled(enable: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (enable != null) {
    if (enable.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции worldSetBlockDropsEnabled для аргумента enable получено значение = \"${enable.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("enable"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to enable.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_set_block_drops_enabled"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSetBlockPowered(location: Any, powered: JString? = null) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldSetBlockPowered:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
if (powered != null) {
    if (powered.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции worldSetBlockPowered для аргумента powered получено значение = \"${powered.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("powered"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to powered.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_set_block_powered"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSetBlockSingleData(location: Any, data: Any, value: Any) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldSetBlockSingleData:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val dataARG: JString = when (data) {
                is String -> JString(data)
is JString -> data
                else -> {
                    errorPrint("${currentScope.scope}: В worldSetBlockSingleData:data получен тип ${data.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val valueARG: JString = when (value) {
                is String -> JString(value)
is JString -> value
                else -> {
                    errorPrint("${currentScope.scope}: В worldSetBlockSingleData:value получен тип ${value.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("data"),
    "value" to dataARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("value"),
    "value" to valueARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_set_block_single_data"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSetBrushableBlockItem(location: Any, item: Any) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldSetBrushableBlockItem:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В worldSetBrushableBlockItem:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_set_brushable_block_item"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSetCampfireItem(location: Any, item: Any, cookingTime: Any, slot: JString? = null) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldSetCampfireItem:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В worldSetCampfireItem:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
            val cookingTimeARG: JNumber = when (cookingTime) {
                is Number -> JNumber(cookingTime)
is JNumber -> cookingTime
                else -> {
                    errorPrint("${currentScope.scope}: В worldSetCampfireItem:cookingTime получен тип ${cookingTime.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("cooking_time"),
    "value" to cookingTimeARG.parse()
)))
if (slot != null) {
    if (slot.value !in setOf("FIRST", "FOURTH", "SECOND", "THIRD")) {
        errorPrint("${currentScope.scope}: В функции worldSetCampfireItem для аргумента slot получено значение = \"${slot.value}\", ожидалось одно из: \"FIRST\", \"FOURTH\", \"SECOND\", \"THIRD\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("slot"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to slot.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_set_campfire_item"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSetContainer(items: Any, location: Any) {
val itemsARG: JItem = when (items) {
    is JItem -> items
    else -> {
        errorPrint("${currentScope.scope}: В worldSetContainer:items получен тип ${items.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldSetContainer:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("items"),
    "value" to itemsARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_set_container"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSetContainerLock(location: Any, containerKey: Any) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldSetContainerLock:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val containerKeyARG: JString = when (containerKey) {
                is String -> JString(containerKey)
is JString -> containerKey
                else -> {
                    errorPrint("${currentScope.scope}: В worldSetContainerLock:containerKey получен тип ${containerKey.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("container_key"),
    "value" to containerKeyARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_set_container_lock"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSetContainerName(location: Any, name: Any) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldSetContainerName:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val nameARG: JString = when (name) {
                is String -> JString(name)
is JString -> name
                else -> {
                    errorPrint("${currentScope.scope}: В worldSetContainerName:name получен тип ${name.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("name"),
    "value" to nameARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_set_container_name"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSetDecoratePotSherd(location: Any, item: Any, side: JString? = null) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldSetDecoratePotSherd:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В worldSetDecoratePotSherd:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
if (side != null) {
    if (side.value !in setOf("BACK", "FRONT", "LEFT", "RIGHT")) {
        errorPrint("${currentScope.scope}: В функции worldSetDecoratePotSherd для аргумента side получено значение = \"${side.value}\", ожидалось одно из: \"BACK\", \"FRONT\", \"LEFT\", \"RIGHT\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("side"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to side.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_set_decorate_pot_sherd"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSetEventDamage(damage: Any) {
            val damageARG: JNumber = when (damage) {
                is Number -> JNumber(damage)
is JNumber -> damage
                else -> {
                    errorPrint("${currentScope.scope}: В worldSetEventDamage:damage получен тип ${damage.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("damage"),
    "value" to damageARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_set_event_damage"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSetEventExhaustion(exhaustion: Any) {
            val exhaustionARG: JNumber = when (exhaustion) {
                is Number -> JNumber(exhaustion)
is JNumber -> exhaustion
                else -> {
                    errorPrint("${currentScope.scope}: В worldSetEventExhaustion:exhaustion получен тип ${exhaustion.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("exhaustion"),
    "value" to exhaustionARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_set_event_exhaustion"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSetEventExperience(experience: Any) {
            val experienceARG: JNumber = when (experience) {
                is Number -> JNumber(experience)
is JNumber -> experience
                else -> {
                    errorPrint("${currentScope.scope}: В worldSetEventExperience:experience получен тип ${experience.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("experience"),
    "value" to experienceARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_set_event_experience"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSetEventHeal(heal: Any) {
            val healARG: JNumber = when (heal) {
                is Number -> JNumber(heal)
is JNumber -> heal
                else -> {
                    errorPrint("${currentScope.scope}: В worldSetEventHeal:heal получен тип ${heal.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("heal"),
    "value" to healARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_set_event_heal"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSetEventItem(item: Any) {
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В worldSetEventItem:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_set_event_item"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSetEventItems(items: Any) {
val itemsARG: JItem = when (items) {
    is JItem -> items
    else -> {
        errorPrint("${currentScope.scope}: В worldSetEventItems:items получен тип ${items.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("items"),
    "value" to itemsARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_set_event_items"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSetEventMoveAllowed(allowed: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (allowed != null) {
    if (allowed.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции worldSetEventMoveAllowed для аргумента allowed получено значение = \"${allowed.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("allowed"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to allowed.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_set_event_move_allowed"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSetEventProjectile(projectile: Any, name: Any) {
val projectileARG: JItem = when (projectile) {
    is JItem -> projectile
    else -> {
        errorPrint("${currentScope.scope}: В worldSetEventProjectile:projectile получен тип ${projectile.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
            val nameARG: JString = when (name) {
                is String -> JString(name)
is JString -> name
                else -> {
                    errorPrint("${currentScope.scope}: В worldSetEventProjectile:name получен тип ${name.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("projectile"),
    "value" to projectileARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("name"),
    "value" to nameARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_set_event_projectile"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSetEventSound(sound: Any) {
val soundARG: JSound = when (sound) {
    is JSound -> sound
    else -> {
        errorPrint("${currentScope.scope}: В worldSetEventSound:sound получен тип ${sound.javaClass.kotlin.simpleName}, ожидалось: JSound")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("sound"),
    "value" to soundARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_set_event_sound"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSetEventSourceSlot(sourceSlot: Any) {
            val sourceSlotARG: JNumber = when (sourceSlot) {
                is Number -> JNumber(sourceSlot)
is JNumber -> sourceSlot
                else -> {
                    errorPrint("${currentScope.scope}: В worldSetEventSourceSlot:sourceSlot получен тип ${sourceSlot.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("source_slot"),
    "value" to sourceSlotARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_set_event_source_slot"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSetEventTargetSlot(target: Any) {
            val targetARG: JNumber = when (target) {
                is Number -> JNumber(target)
is JNumber -> target
                else -> {
                    errorPrint("${currentScope.scope}: В worldSetEventTargetSlot:target получен тип ${target.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("target"),
    "value" to targetARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_set_event_target_slot"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSetEventUeryInfo(information: Any) {
            val informationARG: JString = when (information) {
                is String -> JString(information)
is JString -> information
                else -> {
                    errorPrint("${currentScope.scope}: В worldSetEventUeryInfo:information получен тип ${information.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("information"),
    "value" to informationARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_set_event_uery_info"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSetFurnaceCookTime(location: Any, time: Any) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldSetFurnaceCookTime:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val timeARG: JNumber = when (time) {
                is Number -> JNumber(time)
is JNumber -> time
                else -> {
                    errorPrint("${currentScope.scope}: В worldSetFurnaceCookTime:time получен тип ${time.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("time"),
    "value" to timeARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_set_furnace_cook_time"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSetItemInContainerSlot(location: Any, item: Any, slot: Any) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldSetItemInContainerSlot:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В worldSetItemInContainerSlot:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
            val slotARG: JNumber = when (slot) {
                is Number -> JNumber(slot)
is JNumber -> slot
                else -> {
                    errorPrint("${currentScope.scope}: В worldSetItemInContainerSlot:slot получен тип ${slot.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("slot"),
    "value" to slotARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_set_item_in_container_slot"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSetLecternBook(location: Any, item: Any, page: Any) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldSetLecternBook:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В worldSetLecternBook:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
            val pageARG: JNumber = when (page) {
                is Number -> JNumber(page)
is JNumber -> page
                else -> {
                    errorPrint("${currentScope.scope}: В worldSetLecternBook:page получен тип ${page.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("page"),
    "value" to pageARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_set_lectern_book"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSetPlayerHead(location: Any, nameOrUuid: Any, receiveType: JString? = null) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldSetPlayerHead:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val nameOrUuidARG: JString = when (nameOrUuid) {
                is String -> JString(nameOrUuid)
is JString -> nameOrUuid
                else -> {
                    errorPrint("${currentScope.scope}: В worldSetPlayerHead:nameOrUuid получен тип ${nameOrUuid.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("name_or_uuid"),
    "value" to nameOrUuidARG.parse()
)))
if (receiveType != null) {
    if (receiveType.value !in setOf("NAME_OR_UUID", "VALUE")) {
        errorPrint("${currentScope.scope}: В функции worldSetPlayerHead для аргумента receive_type получено значение = \"${receiveType.value}\", ожидалось одно из: \"NAME_OR_UUID\", \"VALUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("receive_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to receiveType.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_set_player_head"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSetRegion(block: Any, pos1: Any, pos2: Any) {
val blockARG: JBlock = when (block) {
    is JBlock -> block
    else -> {
        errorPrint("${currentScope.scope}: В worldSetRegion:block получен тип ${block.javaClass.kotlin.simpleName}, ожидалось: JBlock")
        throw Exception()
    }
}
val pos1ARG: JLocation = when (pos1) {
    is JLocation -> pos1
    else -> {
        errorPrint("${currentScope.scope}: В worldSetRegion:pos1 получен тип ${pos1.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
val pos2ARG: JLocation = when (pos2) {
    is JLocation -> pos2
    else -> {
        errorPrint("${currentScope.scope}: В worldSetRegion:pos2 получен тип ${pos2.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("block"),
    "value" to blockARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("pos_1"),
    "value" to pos1ARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("pos_2"),
    "value" to pos2ARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_set_region"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSetScoreboardLine(id: Any, line: Any, display: Any, score: Any, formatContent: Any, format: JString? = null) {
            val idARG: JString = when (id) {
                is String -> JString(id)
is JString -> id
                else -> {
                    errorPrint("${currentScope.scope}: В worldSetScoreboardLine:id получен тип ${id.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val lineARG: JString = when (line) {
                is String -> JString(line)
is JString -> line
                else -> {
                    errorPrint("${currentScope.scope}: В worldSetScoreboardLine:line получен тип ${line.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val displayARG: JString = when (display) {
                is String -> JString(display)
is JString -> display
                else -> {
                    errorPrint("${currentScope.scope}: В worldSetScoreboardLine:display получен тип ${display.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val scoreARG: JNumber = when (score) {
                is Number -> JNumber(score)
is JNumber -> score
                else -> {
                    errorPrint("${currentScope.scope}: В worldSetScoreboardLine:score получен тип ${score.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val formatContentARG: JString = when (formatContent) {
                is String -> JString(formatContent)
is JString -> formatContent
                else -> {
                    errorPrint("${currentScope.scope}: В worldSetScoreboardLine:formatContent получен тип ${formatContent.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("id"),
    "value" to idARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("line"),
    "value" to lineARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("display"),
    "value" to displayARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("score"),
    "value" to scoreARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("format_content"),
    "value" to formatContentARG.parse()
)))
if (format != null) {
    if (format.value !in setOf("BLANK", "FIXED", "RESET", "STYLED")) {
        errorPrint("${currentScope.scope}: В функции worldSetScoreboardLine для аргумента format получено значение = \"${format.value}\", ожидалось одно из: \"BLANK\", \"FIXED\", \"RESET\", \"STYLED\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("format"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to format.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_set_scoreboard_line"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSetScoreboardLineDisplay(id: Any, line: Any, display: Any) {
            val idARG: JString = when (id) {
                is String -> JString(id)
is JString -> id
                else -> {
                    errorPrint("${currentScope.scope}: В worldSetScoreboardLineDisplay:id получен тип ${id.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val lineARG: JString = when (line) {
                is String -> JString(line)
is JString -> line
                else -> {
                    errorPrint("${currentScope.scope}: В worldSetScoreboardLineDisplay:line получен тип ${line.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val displayARG: JString = when (display) {
                is String -> JString(display)
is JString -> display
                else -> {
                    errorPrint("${currentScope.scope}: В worldSetScoreboardLineDisplay:display получен тип ${display.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("id"),
    "value" to idARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("line"),
    "value" to lineARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("display"),
    "value" to displayARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_set_scoreboard_line_display"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSetScoreboardLineFormat(id: Any, line: Any, formatContent: Any, format: JString? = null) {
            val idARG: JString = when (id) {
                is String -> JString(id)
is JString -> id
                else -> {
                    errorPrint("${currentScope.scope}: В worldSetScoreboardLineFormat:id получен тип ${id.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val lineARG: JString = when (line) {
                is String -> JString(line)
is JString -> line
                else -> {
                    errorPrint("${currentScope.scope}: В worldSetScoreboardLineFormat:line получен тип ${line.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val formatContentARG: JString = when (formatContent) {
                is String -> JString(formatContent)
is JString -> formatContent
                else -> {
                    errorPrint("${currentScope.scope}: В worldSetScoreboardLineFormat:formatContent получен тип ${formatContent.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("id"),
    "value" to idARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("line"),
    "value" to lineARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("format_content"),
    "value" to formatContentARG.parse()
)))
if (format != null) {
    if (format.value !in setOf("BLANK", "FIXED", "RESET", "STYLED")) {
        errorPrint("${currentScope.scope}: В функции worldSetScoreboardLineFormat для аргумента format получено значение = \"${format.value}\", ожидалось одно из: \"BLANK\", \"FIXED\", \"RESET\", \"STYLED\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("format"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to format.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_set_scoreboard_line_format"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSetScoreboardNumberFormat(id: Any, formatContent: Any, format: JString? = null) {
            val idARG: JString = when (id) {
                is String -> JString(id)
is JString -> id
                else -> {
                    errorPrint("${currentScope.scope}: В worldSetScoreboardNumberFormat:id получен тип ${id.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val formatContentARG: JString = when (formatContent) {
                is String -> JString(formatContent)
is JString -> formatContent
                else -> {
                    errorPrint("${currentScope.scope}: В worldSetScoreboardNumberFormat:formatContent получен тип ${formatContent.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("id"),
    "value" to idARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("format_content"),
    "value" to formatContentARG.parse()
)))
if (format != null) {
    if (format.value !in setOf("BLANK", "FIXED", "RESET", "STYLED")) {
        errorPrint("${currentScope.scope}: В функции worldSetScoreboardNumberFormat для аргумента format получено значение = \"${format.value}\", ожидалось одно из: \"BLANK\", \"FIXED\", \"RESET\", \"STYLED\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("format"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to format.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_set_scoreboard_number_format"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSetScoreboardScore(id: Any, text: Any, score: Any) {
            val idARG: JString = when (id) {
                is String -> JString(id)
is JString -> id
                else -> {
                    errorPrint("${currentScope.scope}: В worldSetScoreboardScore:id получен тип ${id.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val textARG: JString = when (text) {
                is String -> JString(text)
is JString -> text
                else -> {
                    errorPrint("${currentScope.scope}: В worldSetScoreboardScore:text получен тип ${text.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val scoreARG: JNumber = when (score) {
                is Number -> JNumber(score)
is JNumber -> score
                else -> {
                    errorPrint("${currentScope.scope}: В worldSetScoreboardScore:score получен тип ${score.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("id"),
    "value" to idARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("text"),
    "value" to textARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("score"),
    "value" to scoreARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_set_scoreboard_score"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSetScoreboardTitle(id: Any, title: Any) {
            val idARG: JString = when (id) {
                is String -> JString(id)
is JString -> id
                else -> {
                    errorPrint("${currentScope.scope}: В worldSetScoreboardTitle:id получен тип ${id.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val titleARG: JString = when (title) {
                is String -> JString(title)
is JString -> title
                else -> {
                    errorPrint("${currentScope.scope}: В worldSetScoreboardTitle:title получен тип ${title.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("id"),
    "value" to idARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("title"),
    "value" to titleARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_set_scoreboard_title"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSetSculkShriekerCanSummon(location: Any, canSummon: JString? = null) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldSetSculkShriekerCanSummon:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
if (canSummon != null) {
    if (canSummon.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции worldSetSculkShriekerCanSummon для аргумента can_summon получено значение = \"${canSummon.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("can_summon"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to canSummon.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_set_sculk_shrieker_can_summon"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSetSculkShriekerShrieking(location: Any, shrieking: JString? = null) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldSetSculkShriekerShrieking:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
if (shrieking != null) {
    if (shrieking.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции worldSetSculkShriekerShrieking для аргумента shrieking получено значение = \"${shrieking.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("shrieking"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to shrieking.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_set_sculk_shrieker_shrieking"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSetSculkShriekerWarningLevel(location: Any, warningLevel: Any) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldSetSculkShriekerWarningLevel:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val warningLevelARG: JNumber = when (warningLevel) {
                is Number -> JNumber(warningLevel)
is JNumber -> warningLevel
                else -> {
                    errorPrint("${currentScope.scope}: В worldSetSculkShriekerWarningLevel:warningLevel получен тип ${warningLevel.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("warning_level"),
    "value" to warningLevelARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_set_sculk_shrieker_warning_level"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSetSignText(location: Any, text: Any, line: Any, side: JString? = null) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldSetSignText:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val textARG: JString = when (text) {
                is String -> JString(text)
is JString -> text
                else -> {
                    errorPrint("${currentScope.scope}: В worldSetSignText:text получен тип ${text.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val lineARG: JNumber = when (line) {
                is Number -> JNumber(line)
is JNumber -> line
                else -> {
                    errorPrint("${currentScope.scope}: В worldSetSignText:line получен тип ${line.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("text"),
    "value" to textARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("line"),
    "value" to lineARG.parse()
)))
if (side != null) {
    if (side.value !in setOf("ALL", "BACK", "FRONT")) {
        errorPrint("${currentScope.scope}: В функции worldSetSignText для аргумента side получено значение = \"${side.value}\", ожидалось одно из: \"ALL\", \"BACK\", \"FRONT\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("side"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to side.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_set_sign_text"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSetSignTextColor(location: Any, side: JString? = null, signTextColor: JString? = null, glowing: JString? = null) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldSetSignTextColor:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}



    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
if (side != null) {
    if (side.value !in setOf("ALL", "BACK", "FRONT")) {
        errorPrint("${currentScope.scope}: В функции worldSetSignTextColor для аргумента side получено значение = \"${side.value}\", ожидалось одно из: \"ALL\", \"BACK\", \"FRONT\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("side"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to side.jsonValue()
        ))
    )))
}
if (signTextColor != null) {
    if (signTextColor.value !in setOf("BLACK", "BLUE", "BROWN", "CYAN", "GRAY", "GREEN", "LIGHT_BLUE", "LIGHT_GRAY", "LIME", "MAGENTA", "ORANGE", "PINK", "PURPLE", "RED", "WHITE", "YELLOW")) {
        errorPrint("${currentScope.scope}: В функции worldSetSignTextColor для аргумента sign_text_color получено значение = \"${signTextColor.value}\", ожидалось одно из: \"BLACK\", \"BLUE\", \"BROWN\", \"CYAN\", \"GRAY\", \"GREEN\", \"LIGHT_BLUE\", \"LIGHT_GRAY\", \"LIME\", \"MAGENTA\", \"ORANGE\", \"PINK\", \"PURPLE\", \"RED\", \"WHITE\", \"YELLOW\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("sign_text_color"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to signTextColor.jsonValue()
        ))
    )))
}
if (glowing != null) {
    if (glowing.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции worldSetSignTextColor для аргумента glowing получено значение = \"${glowing.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("glowing"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to glowing.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_set_sign_text_color"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSetSignWaxed(location: Any, waxed: JString? = null) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldSetSignWaxed:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
if (waxed != null) {
    if (waxed.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции worldSetSignWaxed для аргумента waxed получено значение = \"${waxed.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("waxed"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to waxed.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_set_sign_waxed"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSetSpawnerEntity(location: Any, entity: Any) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldSetSpawnerEntity:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
val entityARG: JItem = when (entity) {
    is JItem -> entity
    else -> {
        errorPrint("${currentScope.scope}: В worldSetSpawnerEntity:entity получен тип ${entity.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("entity"),
    "value" to entityARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_set_spawner_entity"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSetWorldDifficulty(difficulty: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (difficulty != null) {
    if (difficulty.value !in setOf("EASY", "HARD", "NORMAL", "PEACEFUL")) {
        errorPrint("${currentScope.scope}: В функции worldSetWorldDifficulty для аргумента difficulty получено значение = \"${difficulty.value}\", ожидалось одно из: \"EASY\", \"HARD\", \"NORMAL\", \"PEACEFUL\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("difficulty"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to difficulty.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_set_world_difficulty"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSetWorldSimulationDistance(distance: Any) {
            val distanceARG: JNumber = when (distance) {
                is Number -> JNumber(distance)
is JNumber -> distance
                else -> {
                    errorPrint("${currentScope.scope}: В worldSetWorldSimulationDistance:distance получен тип ${distance.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("distance"),
    "value" to distanceARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_set_world_simulation_distance"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSetWorldTime(time: Any) {
            val timeARG: JNumber = when (time) {
                is Number -> JNumber(time)
is JNumber -> time
                else -> {
                    errorPrint("${currentScope.scope}: В worldSetWorldTime:time получен тип ${time.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("time"),
    "value" to timeARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_set_world_time"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSetWorldWeather(weatherDuration: Any, weatherType: JString? = null) {
            val weatherDurationARG: JNumber = when (weatherDuration) {
                is Number -> JNumber(weatherDuration)
is JNumber -> weatherDuration
                else -> {
                    errorPrint("${currentScope.scope}: В worldSetWorldWeather:weatherDuration получен тип ${weatherDuration.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("weather_duration"),
    "value" to weatherDurationARG.parse()
)))
if (weatherType != null) {
    if (weatherType.value !in setOf("CLEAR", "RAINING", "THUNDER")) {
        errorPrint("${currentScope.scope}: В функции worldSetWorldWeather для аргумента weather_type получено значение = \"${weatherType.value}\", ожидалось одно из: \"CLEAR\", \"RAINING\", \"THUNDER\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("weather_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to weatherType.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_set_world_weather"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSpawnArmorStand(helmet: Any, chestplate: Any, boots: Any, leggings: Any, rightHand: Any, leftHand: Any, location: Any, customName: Any, gravity: JString? = null, marker: JString? = null, small: JString? = null, showArms: JString? = null, basePlate: JString? = null, invisible: JString? = null) {
val helmetARG: JItem = when (helmet) {
    is JItem -> helmet
    else -> {
        errorPrint("${currentScope.scope}: В worldSpawnArmorStand:helmet получен тип ${helmet.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
val chestplateARG: JItem = when (chestplate) {
    is JItem -> chestplate
    else -> {
        errorPrint("${currentScope.scope}: В worldSpawnArmorStand:chestplate получен тип ${chestplate.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
val bootsARG: JItem = when (boots) {
    is JItem -> boots
    else -> {
        errorPrint("${currentScope.scope}: В worldSpawnArmorStand:boots получен тип ${boots.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
val leggingsARG: JItem = when (leggings) {
    is JItem -> leggings
    else -> {
        errorPrint("${currentScope.scope}: В worldSpawnArmorStand:leggings получен тип ${leggings.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
val rightHandARG: JItem = when (rightHand) {
    is JItem -> rightHand
    else -> {
        errorPrint("${currentScope.scope}: В worldSpawnArmorStand:rightHand получен тип ${rightHand.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
val leftHandARG: JItem = when (leftHand) {
    is JItem -> leftHand
    else -> {
        errorPrint("${currentScope.scope}: В worldSpawnArmorStand:leftHand получен тип ${leftHand.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldSpawnArmorStand:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val customNameARG: JString = when (customName) {
                is String -> JString(customName)
is JString -> customName
                else -> {
                    errorPrint("${currentScope.scope}: В worldSpawnArmorStand:customName получен тип ${customName.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }






    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("helmet"),
    "value" to helmetARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("chestplate"),
    "value" to chestplateARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("boots"),
    "value" to bootsARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("leggings"),
    "value" to leggingsARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("right_hand"),
    "value" to rightHandARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("left_hand"),
    "value" to leftHandARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("custom_name"),
    "value" to customNameARG.parse()
)))
if (gravity != null) {
    if (gravity.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции worldSpawnArmorStand для аргумента gravity получено значение = \"${gravity.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("gravity"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to gravity.jsonValue()
        ))
    )))
}
if (marker != null) {
    if (marker.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции worldSpawnArmorStand для аргумента marker получено значение = \"${marker.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("marker"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to marker.jsonValue()
        ))
    )))
}
if (small != null) {
    if (small.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции worldSpawnArmorStand для аргумента small получено значение = \"${small.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("small"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to small.jsonValue()
        ))
    )))
}
if (showArms != null) {
    if (showArms.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции worldSpawnArmorStand для аргумента show_arms получено значение = \"${showArms.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("show_arms"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to showArms.jsonValue()
        ))
    )))
}
if (basePlate != null) {
    if (basePlate.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции worldSpawnArmorStand для аргумента base_plate получено значение = \"${basePlate.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("base_plate"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to basePlate.jsonValue()
        ))
    )))
}
if (invisible != null) {
    if (invisible.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции worldSpawnArmorStand для аргумента invisible получено значение = \"${invisible.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("invisible"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to invisible.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_spawn_armor_stand"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSpawnBlockDisplay(spawnLocation: Any, customName: Any, block: Any) {
val spawnLocationARG: JLocation = when (spawnLocation) {
    is JLocation -> spawnLocation
    else -> {
        errorPrint("${currentScope.scope}: В worldSpawnBlockDisplay:spawnLocation получен тип ${spawnLocation.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val customNameARG: JString = when (customName) {
                is String -> JString(customName)
is JString -> customName
                else -> {
                    errorPrint("${currentScope.scope}: В worldSpawnBlockDisplay:customName получен тип ${customName.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
val blockARG: JBlock = when (block) {
    is JBlock -> block
    else -> {
        errorPrint("${currentScope.scope}: В worldSpawnBlockDisplay:block получен тип ${block.javaClass.kotlin.simpleName}, ожидалось: JBlock")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("spawn_location"),
    "value" to spawnLocationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("custom_name"),
    "value" to customNameARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("block"),
    "value" to blockARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_spawn_block_display"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSpawnEffectCloud(location: Any, duration: Any, radius: Any, effects: Any, particle: Any, customName: Any) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldSpawnEffectCloud:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val durationARG: JNumber = when (duration) {
                is Number -> JNumber(duration)
is JNumber -> duration
                else -> {
                    errorPrint("${currentScope.scope}: В worldSpawnEffectCloud:duration получен тип ${duration.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val radiusARG: JNumber = when (radius) {
                is Number -> JNumber(radius)
is JNumber -> radius
                else -> {
                    errorPrint("${currentScope.scope}: В worldSpawnEffectCloud:radius получен тип ${radius.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
val effectsARG: JPotion = when (effects) {
    is JPotion -> effects
    else -> {
        errorPrint("${currentScope.scope}: В worldSpawnEffectCloud:effects получен тип ${effects.javaClass.kotlin.simpleName}, ожидалось: JPotion")
        throw Exception()
    }
}
val particleARG: JParticle = when (particle) {
    is JParticle -> particle
    else -> {
        errorPrint("${currentScope.scope}: В worldSpawnEffectCloud:particle получен тип ${particle.javaClass.kotlin.simpleName}, ожидалось: JParticle")
        throw Exception()
    }
}
            val customNameARG: JString = when (customName) {
                is String -> JString(customName)
is JString -> customName
                else -> {
                    errorPrint("${currentScope.scope}: В worldSpawnEffectCloud:customName получен тип ${customName.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("duration"),
    "value" to durationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("radius"),
    "value" to radiusARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("effects"),
    "value" to effectsARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("particle"),
    "value" to particleARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("custom_name"),
    "value" to customNameARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_spawn_effect_cloud"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSpawnEndCrystal(location: Any, customName: Any, showBottom: JString? = null) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldSpawnEndCrystal:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val customNameARG: JString = when (customName) {
                is String -> JString(customName)
is JString -> customName
                else -> {
                    errorPrint("${currentScope.scope}: В worldSpawnEndCrystal:customName получен тип ${customName.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("custom_name"),
    "value" to customNameARG.parse()
)))
if (showBottom != null) {
    if (showBottom.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции worldSpawnEndCrystal для аргумента show_bottom получено значение = \"${showBottom.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("show_bottom"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to showBottom.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_spawn_end_crystal"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSpawnEvokerFangs(location: Any, customName: Any) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldSpawnEvokerFangs:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val customNameARG: JString = when (customName) {
                is String -> JString(customName)
is JString -> customName
                else -> {
                    errorPrint("${currentScope.scope}: В worldSpawnEvokerFangs:customName получен тип ${customName.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("custom_name"),
    "value" to customNameARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_spawn_evoker_fangs"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSpawnExperienceOrb(location: Any, experienceAmount: Any, customName: Any) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldSpawnExperienceOrb:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val experienceAmountARG: JNumber = when (experienceAmount) {
                is Number -> JNumber(experienceAmount)
is JNumber -> experienceAmount
                else -> {
                    errorPrint("${currentScope.scope}: В worldSpawnExperienceOrb:experienceAmount получен тип ${experienceAmount.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val customNameARG: JString = when (customName) {
                is String -> JString(customName)
is JString -> customName
                else -> {
                    errorPrint("${currentScope.scope}: В worldSpawnExperienceOrb:customName получен тип ${customName.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("experience_amount"),
    "value" to experienceAmountARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("custom_name"),
    "value" to customNameARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_spawn_experience_orb"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSpawnEyeOfEnder(location: Any, destination: Any, lifespan: Any, customName: Any, endOfLifespan: JString? = null) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldSpawnEyeOfEnder:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
val destinationARG: JLocation = when (destination) {
    is JLocation -> destination
    else -> {
        errorPrint("${currentScope.scope}: В worldSpawnEyeOfEnder:destination получен тип ${destination.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val lifespanARG: JNumber = when (lifespan) {
                is Number -> JNumber(lifespan)
is JNumber -> lifespan
                else -> {
                    errorPrint("${currentScope.scope}: В worldSpawnEyeOfEnder:lifespan получен тип ${lifespan.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val customNameARG: JString = when (customName) {
                is String -> JString(customName)
is JString -> customName
                else -> {
                    errorPrint("${currentScope.scope}: В worldSpawnEyeOfEnder:customName получен тип ${customName.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("destination"),
    "value" to destinationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("lifespan"),
    "value" to lifespanARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("custom_name"),
    "value" to customNameARG.parse()
)))
if (endOfLifespan != null) {
    if (endOfLifespan.value !in setOf("DROP", "RANDOM", "SHATTER")) {
        errorPrint("${currentScope.scope}: В функции worldSpawnEyeOfEnder для аргумента end_of_lifespan получено значение = \"${endOfLifespan.value}\", ожидалось одно из: \"DROP\", \"RANDOM\", \"SHATTER\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("end_of_lifespan"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to endOfLifespan.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_spawn_eye_of_ender"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSpawnFallingBlock(block: Any, location: Any, name: Any, shouldExpire: JString? = null) {
val blockARG: JBlock = when (block) {
    is JBlock -> block
    else -> {
        errorPrint("${currentScope.scope}: В worldSpawnFallingBlock:block получен тип ${block.javaClass.kotlin.simpleName}, ожидалось: JBlock")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldSpawnFallingBlock:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val nameARG: JString = when (name) {
                is String -> JString(name)
is JString -> name
                else -> {
                    errorPrint("${currentScope.scope}: В worldSpawnFallingBlock:name получен тип ${name.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("block"),
    "value" to blockARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("name"),
    "value" to nameARG.parse()
)))
if (shouldExpire != null) {
    if (shouldExpire.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции worldSpawnFallingBlock для аргумента should_expire получено значение = \"${shouldExpire.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("should_expire"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to shouldExpire.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_spawn_falling_block"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSpawnInteractionEntity(location: Any, customName: Any, width: Any, height: Any, responsive: JString? = null) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldSpawnInteractionEntity:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val customNameARG: JString = when (customName) {
                is String -> JString(customName)
is JString -> customName
                else -> {
                    errorPrint("${currentScope.scope}: В worldSpawnInteractionEntity:customName получен тип ${customName.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val widthARG: JNumber = when (width) {
                is Number -> JNumber(width)
is JNumber -> width
                else -> {
                    errorPrint("${currentScope.scope}: В worldSpawnInteractionEntity:width получен тип ${width.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val heightARG: JNumber = when (height) {
                is Number -> JNumber(height)
is JNumber -> height
                else -> {
                    errorPrint("${currentScope.scope}: В worldSpawnInteractionEntity:height получен тип ${height.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("custom_name"),
    "value" to customNameARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("width"),
    "value" to widthARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("height"),
    "value" to heightARG.parse()
)))
if (responsive != null) {
    if (responsive.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции worldSpawnInteractionEntity для аргумента responsive получено значение = \"${responsive.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("responsive"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to responsive.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_spawn_interaction_entity"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSpawnItem(location: Any, item: Any, customName: Any, canMobPickup: JString? = null, canPlayerPickup: JString? = null, applyMotion: JString? = null) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldSpawnItem:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В worldSpawnItem:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
            val customNameARG: JString = when (customName) {
                is String -> JString(customName)
is JString -> customName
                else -> {
                    errorPrint("${currentScope.scope}: В worldSpawnItem:customName получен тип ${customName.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }



    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("custom_name"),
    "value" to customNameARG.parse()
)))
if (canMobPickup != null) {
    if (canMobPickup.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции worldSpawnItem для аргумента can_mob_pickup получено значение = \"${canMobPickup.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("can_mob_pickup"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to canMobPickup.jsonValue()
        ))
    )))
}
if (canPlayerPickup != null) {
    if (canPlayerPickup.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции worldSpawnItem для аргумента can_player_pickup получено значение = \"${canPlayerPickup.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("can_player_pickup"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to canPlayerPickup.jsonValue()
        ))
    )))
}
if (applyMotion != null) {
    if (applyMotion.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции worldSpawnItem для аргумента apply_motion получено значение = \"${applyMotion.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("apply_motion"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to applyMotion.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_spawn_item"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSpawnItemDisplay(spawnLocation: Any, customName: Any, displayedItem: Any) {
val spawnLocationARG: JLocation = when (spawnLocation) {
    is JLocation -> spawnLocation
    else -> {
        errorPrint("${currentScope.scope}: В worldSpawnItemDisplay:spawnLocation получен тип ${spawnLocation.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val customNameARG: JString = when (customName) {
                is String -> JString(customName)
is JString -> customName
                else -> {
                    errorPrint("${currentScope.scope}: В worldSpawnItemDisplay:customName получен тип ${customName.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
val displayedItemARG: JItem = when (displayedItem) {
    is JItem -> displayedItem
    else -> {
        errorPrint("${currentScope.scope}: В worldSpawnItemDisplay:displayedItem получен тип ${displayedItem.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("spawn_location"),
    "value" to spawnLocationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("custom_name"),
    "value" to customNameARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("displayed_item"),
    "value" to displayedItemARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_spawn_item_display"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSpawnLightningBolt(location: Any) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldSpawnLightningBolt:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_spawn_lightning_bolt"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSpawnMob(mob: Any, location: Any, health: Any, potionEffects: Any, customName: Any, mainHand: Any, helmet: Any, chestplate: Any, leggings: Any, boots: Any, offHand: Any, naturalEquipment: JString? = null) {
val mobARG: JItem = when (mob) {
    is JItem -> mob
    else -> {
        errorPrint("${currentScope.scope}: В worldSpawnMob:mob получен тип ${mob.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldSpawnMob:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val healthARG: JNumber = when (health) {
                is Number -> JNumber(health)
is JNumber -> health
                else -> {
                    errorPrint("${currentScope.scope}: В worldSpawnMob:health получен тип ${health.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
val potionEffectsARG: JPotion = when (potionEffects) {
    is JPotion -> potionEffects
    else -> {
        errorPrint("${currentScope.scope}: В worldSpawnMob:potionEffects получен тип ${potionEffects.javaClass.kotlin.simpleName}, ожидалось: JPotion")
        throw Exception()
    }
}
            val customNameARG: JString = when (customName) {
                is String -> JString(customName)
is JString -> customName
                else -> {
                    errorPrint("${currentScope.scope}: В worldSpawnMob:customName получен тип ${customName.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
val mainHandARG: JItem = when (mainHand) {
    is JItem -> mainHand
    else -> {
        errorPrint("${currentScope.scope}: В worldSpawnMob:mainHand получен тип ${mainHand.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
val helmetARG: JItem = when (helmet) {
    is JItem -> helmet
    else -> {
        errorPrint("${currentScope.scope}: В worldSpawnMob:helmet получен тип ${helmet.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
val chestplateARG: JItem = when (chestplate) {
    is JItem -> chestplate
    else -> {
        errorPrint("${currentScope.scope}: В worldSpawnMob:chestplate получен тип ${chestplate.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
val leggingsARG: JItem = when (leggings) {
    is JItem -> leggings
    else -> {
        errorPrint("${currentScope.scope}: В worldSpawnMob:leggings получен тип ${leggings.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
val bootsARG: JItem = when (boots) {
    is JItem -> boots
    else -> {
        errorPrint("${currentScope.scope}: В worldSpawnMob:boots получен тип ${boots.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
val offHandARG: JItem = when (offHand) {
    is JItem -> offHand
    else -> {
        errorPrint("${currentScope.scope}: В worldSpawnMob:offHand получен тип ${offHand.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("mob"),
    "value" to mobARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("health"),
    "value" to healthARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("potion_effects"),
    "value" to potionEffectsARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("custom_name"),
    "value" to customNameARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("main_hand"),
    "value" to mainHandARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("helmet"),
    "value" to helmetARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("chestplate"),
    "value" to chestplateARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("leggings"),
    "value" to leggingsARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("boots"),
    "value" to bootsARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("off_hand"),
    "value" to offHandARG.parse()
)))
if (naturalEquipment != null) {
    if (naturalEquipment.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции worldSpawnMob для аргумента natural_equipment получено значение = \"${naturalEquipment.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("natural_equipment"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to naturalEquipment.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_spawn_mob"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSpawnPrimedTnt(location: Any, tntPower: Any, fuseDuration: Any, customName: Any, block: Any) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldSpawnPrimedTnt:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val tntPowerARG: JNumber = when (tntPower) {
                is Number -> JNumber(tntPower)
is JNumber -> tntPower
                else -> {
                    errorPrint("${currentScope.scope}: В worldSpawnPrimedTnt:tntPower получен тип ${tntPower.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val fuseDurationARG: JNumber = when (fuseDuration) {
                is Number -> JNumber(fuseDuration)
is JNumber -> fuseDuration
                else -> {
                    errorPrint("${currentScope.scope}: В worldSpawnPrimedTnt:fuseDuration получен тип ${fuseDuration.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val customNameARG: JString = when (customName) {
                is String -> JString(customName)
is JString -> customName
                else -> {
                    errorPrint("${currentScope.scope}: В worldSpawnPrimedTnt:customName получен тип ${customName.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
val blockARG: JBlock = when (block) {
    is JBlock -> block
    else -> {
        errorPrint("${currentScope.scope}: В worldSpawnPrimedTnt:block получен тип ${block.javaClass.kotlin.simpleName}, ожидалось: JBlock")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("tnt_power"),
    "value" to tntPowerARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("fuse_duration"),
    "value" to fuseDurationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("custom_name"),
    "value" to customNameARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("block"),
    "value" to blockARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_spawn_primed_tnt"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSpawnShulkerBullet(location: Any, customName: Any) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldSpawnShulkerBullet:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val customNameARG: JString = when (customName) {
                is String -> JString(customName)
is JString -> customName
                else -> {
                    errorPrint("${currentScope.scope}: В worldSpawnShulkerBullet:customName получен тип ${customName.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("custom_name"),
    "value" to customNameARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_spawn_shulker_bullet"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSpawnTextDisplay(spawnLocation: Any, displayedText: Any, customName: Any, mergingMode: JString? = null) {
val spawnLocationARG: JLocation = when (spawnLocation) {
    is JLocation -> spawnLocation
    else -> {
        errorPrint("${currentScope.scope}: В worldSpawnTextDisplay:spawnLocation получен тип ${spawnLocation.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val displayedTextARG: JString = when (displayedText) {
                is String -> JString(displayedText)
is JString -> displayedText
                else -> {
                    errorPrint("${currentScope.scope}: В worldSpawnTextDisplay:displayedText получен тип ${displayedText.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val customNameARG: JString = when (customName) {
                is String -> JString(customName)
is JString -> customName
                else -> {
                    errorPrint("${currentScope.scope}: В worldSpawnTextDisplay:customName получен тип ${customName.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("spawn_location"),
    "value" to spawnLocationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("displayed_text"),
    "value" to displayedTextARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("custom_name"),
    "value" to customNameARG.parse()
)))
if (mergingMode != null) {
    if (mergingMode.value !in setOf("CONCATENATION", "SEPARATE_LINES", "SPACES")) {
        errorPrint("${currentScope.scope}: В функции worldSpawnTextDisplay для аргумента merging_mode получено значение = \"${mergingMode.value}\", ожидалось одно из: \"CONCATENATION\", \"SEPARATE_LINES\", \"SPACES\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("merging_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to mergingMode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_spawn_text_display"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSpawnVehicle(vehicle: Any, location: Any, customName: Any) {
val vehicleARG: JItem = when (vehicle) {
    is JItem -> vehicle
    else -> {
        errorPrint("${currentScope.scope}: В worldSpawnVehicle:vehicle получен тип ${vehicle.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldSpawnVehicle:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val customNameARG: JString = when (customName) {
                is String -> JString(customName)
is JString -> customName
                else -> {
                    errorPrint("${currentScope.scope}: В worldSpawnVehicle:customName получен тип ${customName.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("vehicle"),
    "value" to vehicleARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("custom_name"),
    "value" to customNameARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_spawn_vehicle"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldUncancelEvent() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_uncancel_event"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldUpdateBlock(location: Any) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldUpdateBlock:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("game_update_block"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityCollidesAtLocation(location: Any) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В entityCollidesAtLocation:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_entity_collides_at_location"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityCollidesUsingHitbox(min: Any, max: Any) {
val minARG: JLocation = when (min) {
    is JLocation -> min
    else -> {
        errorPrint("${currentScope.scope}: В entityCollidesUsingHitbox:min получен тип ${min.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
val maxARG: JLocation = when (max) {
    is JLocation -> max
    else -> {
        errorPrint("${currentScope.scope}: В entityCollidesUsingHitbox:max получен тип ${max.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("min"),
    "value" to minARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("max"),
    "value" to maxARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_entity_collides_using_hitbox"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityCollidesWithEntity(nameOrUuid: Any, checkType: JString? = null) {
            val nameOrUuidARG: JString = when (nameOrUuid) {
                is String -> JString(nameOrUuid)
is JString -> nameOrUuid
                else -> {
                    errorPrint("${currentScope.scope}: В entityCollidesWithEntity:nameOrUuid получен тип ${nameOrUuid.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("name_or_uuid"),
    "value" to nameOrUuidARG.parse()
)))
if (checkType != null) {
    if (checkType.value !in setOf("CONTAINS", "OVERLAPS")) {
        errorPrint("${currentScope.scope}: В функции entityCollidesWithEntity для аргумента check_type получено значение = \"${checkType.value}\", ожидалось одно из: \"CONTAINS\", \"OVERLAPS\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("check_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to checkType.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_entity_collides_with_entity"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityExists() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_entity_exists"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityHasCustomTag(tag: Any, tagValue: Any, compareType: JString? = null) {
            val tagARG: JString = when (tag) {
                is String -> JString(tag)
is JString -> tag
                else -> {
                    errorPrint("${currentScope.scope}: В entityHasCustomTag:tag получен тип ${tag.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val tagValueARG: JString = when (tagValue) {
                is String -> JString(tagValue)
is JString -> tagValue
                else -> {
                    errorPrint("${currentScope.scope}: В entityHasCustomTag:tagValue получен тип ${tagValue.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("tag"),
    "value" to tagARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("tag_value"),
    "value" to tagValueARG.parse()
)))
if (compareType != null) {
    if (compareType.value !in setOf("CONTAINS", "ENDS_WITH", "EQUALS", "STARTS_WITH")) {
        errorPrint("${currentScope.scope}: В функции entityHasCustomTag для аргумента compare_type получено значение = \"${compareType.value}\", ожидалось одно из: \"CONTAINS\", \"ENDS_WITH\", \"EQUALS\", \"STARTS_WITH\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("compare_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to compareType.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_entity_has_custom_tag"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityHasPotionEffect(potions: Any, checkMode: JString? = null) {
val potionsARG: JPotion = when (potions) {
    is JPotion -> potions
    else -> {
        errorPrint("${currentScope.scope}: В entityHasPotionEffect:potions получен тип ${potions.javaClass.kotlin.simpleName}, ожидалось: JPotion")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("potions"),
    "value" to potionsARG.parse()
)))
if (checkMode != null) {
    if (checkMode.value !in setOf("ALL", "ANY")) {
        errorPrint("${currentScope.scope}: В функции entityHasPotionEffect для аргумента check_mode получено значение = \"${checkMode.value}\", ожидалось одно из: \"ALL\", \"ANY\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("check_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to checkMode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_entity_has_potion_effect"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityInArea(location1: Any, location2: Any, ignoreYAxis: JString? = null, intersectType: JString? = null, checkType: JString? = null) {
val location1ARG: JLocation = when (location1) {
    is JLocation -> location1
    else -> {
        errorPrint("${currentScope.scope}: В entityInArea:location1 получен тип ${location1.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
val location2ARG: JLocation = when (location2) {
    is JLocation -> location2
    else -> {
        errorPrint("${currentScope.scope}: В entityInArea:location2 получен тип ${location2.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}



    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location_1"),
    "value" to location1ARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location_2"),
    "value" to location2ARG.parse()
)))
if (ignoreYAxis != null) {
    if (ignoreYAxis.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entityInArea для аргумента ignore_y_axis получено значение = \"${ignoreYAxis.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("ignore_y_axis"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to ignoreYAxis.jsonValue()
        ))
    )))
}
if (intersectType != null) {
    if (intersectType.value !in setOf("HITBOX", "POINT")) {
        errorPrint("${currentScope.scope}: В функции entityInArea для аргумента intersect_type получено значение = \"${intersectType.value}\", ожидалось одно из: \"HITBOX\", \"POINT\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("intersect_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to intersectType.jsonValue()
        ))
    )))
}
if (checkType != null) {
    if (checkType.value !in setOf("CONTAINS", "OVERLAPS")) {
        errorPrint("${currentScope.scope}: В функции entityInArea для аргумента check_type получено значение = \"${checkType.value}\", ожидалось одно из: \"CONTAINS\", \"OVERLAPS\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("check_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to checkType.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_entity_in_area"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityIsDisguised() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_entity_is_disguised"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityIsGrounded() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_entity_is_grounded"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityIsItem() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_entity_is_item"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityIsMob() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_entity_is_mob"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityIsNearLocation(range: Any, location: Any, ignoreYAxis: JString? = null) {
            val rangeARG: JNumber = when (range) {
                is Number -> JNumber(range)
is JNumber -> range
                else -> {
                    errorPrint("${currentScope.scope}: В entityIsNearLocation:range получен тип ${range.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В entityIsNearLocation:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("range"),
    "value" to rangeARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
if (ignoreYAxis != null) {
    if (ignoreYAxis.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entityIsNearLocation для аргумента ignore_y_axis получено значение = \"${ignoreYAxis.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("ignore_y_axis"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to ignoreYAxis.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_entity_is_near_location"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityIsProjectile() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_entity_is_projectile"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityIsRidingEntity(entityIds: Any, compareMode: JString? = null) {
            val entityIdsARG: JString = when (entityIds) {
                is String -> JString(entityIds)
is JString -> entityIds
                else -> {
                    errorPrint("${currentScope.scope}: В entityIsRidingEntity:entityIds получен тип ${entityIds.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("entity_ids"),
    "value" to entityIdsARG.parse()
)))
if (compareMode != null) {
    if (compareMode.value !in setOf("FARTHEST", "NAME_OR_UUID", "NEAREST", "TYPE")) {
        errorPrint("${currentScope.scope}: В функции entityIsRidingEntity для аргумента compare_mode получено значение = \"${compareMode.value}\", ожидалось одно из: \"FARTHEST\", \"NAME_OR_UUID\", \"NEAREST\", \"TYPE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("compare_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to compareMode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_entity_is_riding_entity"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityIsStandingOnBlock(blocks: Any, locations: Any, onlySolid: JString? = null) {
val blocksARG: JBlock = when (blocks) {
    is JBlock -> blocks
    else -> {
        errorPrint("${currentScope.scope}: В entityIsStandingOnBlock:blocks получен тип ${blocks.javaClass.kotlin.simpleName}, ожидалось: JBlock")
        throw Exception()
    }
}
val locationsARG: JLocation = when (locations) {
    is JLocation -> locations
    else -> {
        errorPrint("${currentScope.scope}: В entityIsStandingOnBlock:locations получен тип ${locations.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("blocks"),
    "value" to blocksARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("locations"),
    "value" to locationsARG.parse()
)))
if (onlySolid != null) {
    if (onlySolid.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции entityIsStandingOnBlock для аргумента only_solid получено значение = \"${onlySolid.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("only_solid"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to onlySolid.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_entity_is_standing_on_block"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityIsType(entityTypes: Any) {
val entityTypesARG: JItem = when (entityTypes) {
    is JItem -> entityTypes
    else -> {
        errorPrint("${currentScope.scope}: В entityIsType:entityTypes получен тип ${entityTypes.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("entity_types"),
    "value" to entityTypesARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_entity_is_type"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityIsVehicle() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_entity_is_vehicle"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entityNameEquals(namesOrUuids: Any) {
            val namesOrUuidsARG: JString = when (namesOrUuids) {
                is String -> JString(namesOrUuids)
is JString -> namesOrUuids
                else -> {
                    errorPrint("${currentScope.scope}: В entityNameEquals:namesOrUuids получен тип ${namesOrUuids.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("names_or_uuids"),
    "value" to namesOrUuidsARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_entity_name_equals"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun entitySpawnReasonEquals(reason: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (reason != null) {
    if (reason.value !in setOf("BEEHIVE", "BREEDING", "BUILD_IRONGOLEM", "BUILD_SNOWMAN", "BUILD_WITHER", "COMMAND", "CURED", "CUSTOM", "DEFAULT", "DISPENSE_EGG", "DROWNED", "EGG", "ENDER_PEARL", "EXPLOSION", "FROZEN", "INFECTION", "JOCKEY", "LIGHTNING", "MOUNT", "NATURAL", "NETHER_PORTAL", "OCELOT_BABY", "PATROL", "PIGLIN_ZOMBIFIED", "RAID", "REINFORCEMENTS", "SHEARED", "SHOULDER_ENTITY", "SILVERFISH_BLOCK", "SLIME_SPLIT", "SPAWNER", "SPAWNER_EGG", "TRAP", "VILLAGER_DEFENSE", "VILLAGE_INVASION")) {
        errorPrint("${currentScope.scope}: В функции entitySpawnReasonEquals для аргумента reason получено значение = \"${reason.value}\", ожидалось одно из: \"BEEHIVE\", \"BREEDING\", \"BUILD_IRONGOLEM\", \"BUILD_SNOWMAN\", \"BUILD_WITHER\", \"COMMAND\", \"CURED\", \"CUSTOM\", \"DEFAULT\", \"DISPENSE_EGG\", \"DROWNED\", \"EGG\", \"ENDER_PEARL\", \"EXPLOSION\", \"FROZEN\", \"INFECTION\", \"JOCKEY\", \"LIGHTNING\", \"MOUNT\", \"NATURAL\", \"NETHER_PORTAL\", \"OCELOT_BABY\", \"PATROL\", \"PIGLIN_ZOMBIFIED\", \"RAID\", \"REINFORCEMENTS\", \"SHEARED\", \"SHOULDER_ENTITY\", \"SILVERFISH_BLOCK\", \"SLIME_SPLIT\", \"SPAWNER\", \"SPAWNER_EGG\", \"TRAP\", \"VILLAGER_DEFENSE\", \"VILLAGE_INVASION\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("reason"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to reason.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_entity_spawn_reason_equals"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldBlockEquals(blocks: Any, location: Any) {
val blocksARG: JBlock = when (blocks) {
    is JBlock -> blocks
    else -> {
        errorPrint("${currentScope.scope}: В worldBlockEquals:blocks получен тип ${blocks.javaClass.kotlin.simpleName}, ожидалось: JBlock")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldBlockEquals:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("blocks"),
    "value" to blocksARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_game_block_equals"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldBlockPowered(locations: Any, powerMode: JString? = null) {
val locationsARG: JLocation = when (locations) {
    is JLocation -> locations
    else -> {
        errorPrint("${currentScope.scope}: В worldBlockPowered:locations получен тип ${locations.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("locations"),
    "value" to locationsARG.parse()
)))
if (powerMode != null) {
    if (powerMode.value !in setOf("DIRECT", "INDIRECT")) {
        errorPrint("${currentScope.scope}: В функции worldBlockPowered для аргумента power_mode получено значение = \"${powerMode.value}\", ожидалось одно из: \"DIRECT\", \"INDIRECT\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("power_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to powerMode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_game_block_powered"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldChunkIsLoaded(location: Any) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldChunkIsLoaded:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_game_chunk_is_loaded"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldContainerHas(items: Any, location: Any, checkMode: JString? = null, comparisonMode: JString? = null) {
val itemsARG: JItem = when (items) {
    is JItem -> items
    else -> {
        errorPrint("${currentScope.scope}: В worldContainerHas:items получен тип ${items.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldContainerHas:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}


    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("items"),
    "value" to itemsARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
if (checkMode != null) {
    if (checkMode.value !in setOf("ALL", "ANY")) {
        errorPrint("${currentScope.scope}: В функции worldContainerHas для аргумента check_mode получено значение = \"${checkMode.value}\", ожидалось одно из: \"ALL\", \"ANY\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("check_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to checkMode.jsonValue()
        ))
    )))
}
if (comparisonMode != null) {
    if (comparisonMode.value !in setOf("EXACTLY", "IGNORE_DURABILITY_AND_STACK_SIZE", "IGNORE_STACK_SIZE", "TYPE_ONLY")) {
        errorPrint("${currentScope.scope}: В функции worldContainerHas для аргумента comparison_mode получено значение = \"${comparisonMode.value}\", ожидалось одно из: \"EXACTLY\", \"IGNORE_DURABILITY_AND_STACK_SIZE\", \"IGNORE_STACK_SIZE\", \"TYPE_ONLY\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("comparison_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to comparisonMode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_game_container_has"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldContainerHasRoomForItem(items: Any, location: Any, checkMode: JString? = null) {
val itemsARG: JItem = when (items) {
    is JItem -> items
    else -> {
        errorPrint("${currentScope.scope}: В worldContainerHasRoomForItem:items получен тип ${items.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldContainerHasRoomForItem:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("items"),
    "value" to itemsARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
if (checkMode != null) {
    if (checkMode.value !in setOf("ALL", "ANY")) {
        errorPrint("${currentScope.scope}: В функции worldContainerHasRoomForItem для аргумента check_mode получено значение = \"${checkMode.value}\", ожидалось одно из: \"ALL\", \"ANY\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("check_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to checkMode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_game_container_has_room_for_item"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldDamageCauseEquals(cause: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (cause != null) {
    if (cause.value !in setOf("BLOCK_EXPLOSION", "CONTACT", "CRAMMING", "CUSTOM", "DRAGON_BREATH", "DROWNING", "DRYOUT", "ENTITY_ATTACK", "ENTITY_EXPLOSION", "ENTITY_SWEEP_ATTACK", "FALL", "FALLING_BLOCK", "FIRE", "FIRE_TICK", "FLY_INTO_WALL", "FREEZE", "HOT_FLOOR", "KILL", "LAVA", "LIGHTNING", "MAGIC", "MELTING", "POISON", "PROJECTILE", "SONIC_BOOM", "STARVATION", "SUFFOCATION", "SUICIDE", "THORNS", "VOID", "WITHER", "WORLD_BORDER")) {
        errorPrint("${currentScope.scope}: В функции worldDamageCauseEquals для аргумента cause получено значение = \"${cause.value}\", ожидалось одно из: \"BLOCK_EXPLOSION\", \"CONTACT\", \"CRAMMING\", \"CUSTOM\", \"DRAGON_BREATH\", \"DROWNING\", \"DRYOUT\", \"ENTITY_ATTACK\", \"ENTITY_EXPLOSION\", \"ENTITY_SWEEP_ATTACK\", \"FALL\", \"FALLING_BLOCK\", \"FIRE\", \"FIRE_TICK\", \"FLY_INTO_WALL\", \"FREEZE\", \"HOT_FLOOR\", \"KILL\", \"LAVA\", \"LIGHTNING\", \"MAGIC\", \"MELTING\", \"POISON\", \"PROJECTILE\", \"SONIC_BOOM\", \"STARVATION\", \"SUFFOCATION\", \"SUICIDE\", \"THORNS\", \"VOID\", \"WITHER\", \"WORLD_BORDER\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("cause"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to cause.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_game_damage_cause_equals"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldEventAttackIsCritical() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_game_event_attack_is_critical"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldEventBlockEquals(blocks: Any, locations: Any) {
val blocksARG: JBlock = when (blocks) {
    is JBlock -> blocks
    else -> {
        errorPrint("${currentScope.scope}: В worldEventBlockEquals:blocks получен тип ${blocks.javaClass.kotlin.simpleName}, ожидалось: JBlock")
        throw Exception()
    }
}
val locationsARG: JLocation = when (locations) {
    is JLocation -> locations
    else -> {
        errorPrint("${currentScope.scope}: В worldEventBlockEquals:locations получен тип ${locations.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("blocks"),
    "value" to blocksARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("locations"),
    "value" to locationsARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_game_event_block_equals"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldEventIsCanceled() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_game_event_is_canceled"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldEventItemEquals(items: Any, comparisonMode: JString? = null) {
val itemsARG: JItem = when (items) {
    is JItem -> items
    else -> {
        errorPrint("${currentScope.scope}: В worldEventItemEquals:items получен тип ${items.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("items"),
    "value" to itemsARG.parse()
)))
if (comparisonMode != null) {
    if (comparisonMode.value !in setOf("EXACTLY", "IGNORE_DURABILITY_AND_STACK_SIZE", "IGNORE_STACK_SIZE", "TYPE_ONLY")) {
        errorPrint("${currentScope.scope}: В функции worldEventItemEquals для аргумента comparison_mode получено значение = \"${comparisonMode.value}\", ожидалось одно из: \"EXACTLY\", \"IGNORE_DURABILITY_AND_STACK_SIZE\", \"IGNORE_STACK_SIZE\", \"TYPE_ONLY\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("comparison_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to comparisonMode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_game_event_item_equals"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldHasPlayer(namesOrUuids: Any) {
            val namesOrUuidsARG: JString = when (namesOrUuids) {
                is String -> JString(namesOrUuids)
is JString -> namesOrUuids
                else -> {
                    errorPrint("${currentScope.scope}: В worldHasPlayer:namesOrUuids получен тип ${namesOrUuids.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("names_or_uuids"),
    "value" to namesOrUuidsARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_game_has_player"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldHealCauseEquals(healCause: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (healCause != null) {
    if (healCause.value !in setOf("CUSTOM", "EATING", "ENDER_CRYSTAL", "MAGIC", "MAGIC_REGEN", "REGEN", "SATIATED", "WITHER", "WITHER_SPAWN")) {
        errorPrint("${currentScope.scope}: В функции worldHealCauseEquals для аргумента heal_cause получено значение = \"${healCause.value}\", ожидалось одно из: \"CUSTOM\", \"EATING\", \"ENDER_CRYSTAL\", \"MAGIC\", \"MAGIC_REGEN\", \"REGEN\", \"SATIATED\", \"WITHER\", \"WITHER_SPAWN\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("heal_cause"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to healCause.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_game_heal_cause_equals"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldIgniteCauseEquals(cause: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (cause != null) {
    if (cause.value !in setOf("ARROW", "ENDER_CRYSTAL", "EXPLOSION", "FALL", "FIREBALL", "FLINT_AND_STEEL", "LAVA", "LIGHTNING", "SPREAD", "SUFFOCATION")) {
        errorPrint("${currentScope.scope}: В функции worldIgniteCauseEquals для аргумента cause получено значение = \"${cause.value}\", ожидалось одно из: \"ARROW\", \"ENDER_CRYSTAL\", \"EXPLOSION\", \"FALL\", \"FIREBALL\", \"FLINT_AND_STEEL\", \"LAVA\", \"LIGHTNING\", \"SPREAD\", \"SUFFOCATION\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("cause"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to cause.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_game_ignite_cause_equals"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldInstrumentEquals(instrument: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (instrument != null) {
    if (instrument.value !in setOf("BANJO", "BASS_DRUM", "BASS_GUITAR", "BELL", "BIT", "CHIME", "COW_BELL", "CREEPER", "CUSTOM_HEAD", "DIDGERIDOO", "DRAGON", "FLUTE", "GUITAR", "IRON_XYLOPHONE", "PIANO", "PIGLIN", "PLING", "SKELETON", "SNARE_DRUM", "STICKS", "WITHER_SKELETON", "XYLOPHONE", "ZOMBIE")) {
        errorPrint("${currentScope.scope}: В функции worldInstrumentEquals для аргумента instrument получено значение = \"${instrument.value}\", ожидалось одно из: \"BANJO\", \"BASS_DRUM\", \"BASS_GUITAR\", \"BELL\", \"BIT\", \"CHIME\", \"COW_BELL\", \"CREEPER\", \"CUSTOM_HEAD\", \"DIDGERIDOO\", \"DRAGON\", \"FLUTE\", \"GUITAR\", \"IRON_XYLOPHONE\", \"PIANO\", \"PIGLIN\", \"PLING\", \"SKELETON\", \"SNARE_DRUM\", \"STICKS\", \"WITHER_SKELETON\", \"XYLOPHONE\", \"ZOMBIE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("instrument"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to instrument.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_game_instrument_equals"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun worldSignContains(location: Any, texts: Any, checkSide: JString? = null, checkMode: JString? = null, lines: JString? = null) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В worldSignContains:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val textsARG: JString = when (texts) {
                is String -> JString(texts)
is JString -> texts
                else -> {
                    errorPrint("${currentScope.scope}: В worldSignContains:texts получен тип ${texts.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }



    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("texts"),
    "value" to textsARG.parse()
)))
if (checkSide != null) {
    if (checkSide.value !in setOf("ANY", "BACK", "FRONT")) {
        errorPrint("${currentScope.scope}: В функции worldSignContains для аргумента check_side получено значение = \"${checkSide.value}\", ожидалось одно из: \"ANY\", \"BACK\", \"FRONT\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("check_side"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to checkSide.jsonValue()
        ))
    )))
}
if (checkMode != null) {
    if (checkMode.value !in setOf("ALL", "ANY", "CONTAINS", "EQUALS")) {
        errorPrint("${currentScope.scope}: В функции worldSignContains для аргумента check_mode получено значение = \"${checkMode.value}\", ожидалось одно из: \"ALL\", \"ANY\", \"CONTAINS\", \"EQUALS\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("check_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to checkMode.jsonValue()
        ))
    )))
}
if (lines != null) {
    if (lines.value !in setOf("ALL", "ANY", "FIRST", "FOURTH", "SECOND", "THIRD")) {
        errorPrint("${currentScope.scope}: В функции worldSignContains для аргумента lines получено значение = \"${lines.value}\", ожидалось одно из: \"ALL\", \"ANY\", \"FIRST\", \"FOURTH\", \"SECOND\", \"THIRD\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("lines"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to lines.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_game_sign_contains"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerChatColorsEnabled() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_player_chat_colors_enabled"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerChatMessageEquals(chatMessages: Any) {
            val chatMessagesARG: JString = when (chatMessages) {
                is String -> JString(chatMessages)
is JString -> chatMessages
                else -> {
                    errorPrint("${currentScope.scope}: В playerChatMessageEquals:chatMessages получен тип ${chatMessages.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("chat_messages"),
    "value" to chatMessagesARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_player_chat_message_equals"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerCollidesAtLocation(location: Any) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В playerCollidesAtLocation:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_player_collides_at_location"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerCollidesUsingHitbox(min: Any, max: Any) {
val minARG: JLocation = when (min) {
    is JLocation -> min
    else -> {
        errorPrint("${currentScope.scope}: В playerCollidesUsingHitbox:min получен тип ${min.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
val maxARG: JLocation = when (max) {
    is JLocation -> max
    else -> {
        errorPrint("${currentScope.scope}: В playerCollidesUsingHitbox:max получен тип ${max.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("min"),
    "value" to minARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("max"),
    "value" to maxARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_player_collides_using_hitbox"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerCollidesWithEntity(nameOrUuid: Any, checkType: JString? = null) {
            val nameOrUuidARG: JString = when (nameOrUuid) {
                is String -> JString(nameOrUuid)
is JString -> nameOrUuid
                else -> {
                    errorPrint("${currentScope.scope}: В playerCollidesWithEntity:nameOrUuid получен тип ${nameOrUuid.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("name_or_uuid"),
    "value" to nameOrUuidARG.parse()
)))
if (checkType != null) {
    if (checkType.value !in setOf("CONTAINS", "OVERLAPS")) {
        errorPrint("${currentScope.scope}: В функции playerCollidesWithEntity для аргумента check_type получено значение = \"${checkType.value}\", ожидалось одно из: \"CONTAINS\", \"OVERLAPS\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("check_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to checkType.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_player_collides_with_entity"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerCursorItemEquals(items: Any, comparisonMode: JString? = null) {
val itemsARG: JItem = when (items) {
    is JItem -> items
    else -> {
        errorPrint("${currentScope.scope}: В playerCursorItemEquals:items получен тип ${items.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("items"),
    "value" to itemsARG.parse()
)))
if (comparisonMode != null) {
    if (comparisonMode.value !in setOf("EXACTLY", "IGNORE_DURABILITY_AND_STACK_SIZE", "IGNORE_STACK_SIZE", "TYPE_ONLY")) {
        errorPrint("${currentScope.scope}: В функции playerCursorItemEquals для аргумента comparison_mode получено значение = \"${comparisonMode.value}\", ожидалось одно из: \"EXACTLY\", \"IGNORE_DURABILITY_AND_STACK_SIZE\", \"IGNORE_STACK_SIZE\", \"TYPE_ONLY\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("comparison_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to comparisonMode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_player_cursor_item_equals"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerGamemodeEquals(gamemode: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (gamemode != null) {
    if (gamemode.value !in setOf("ADVENTURE", "CREATIVE", "SPECTATOR", "SURVIVAL")) {
        errorPrint("${currentScope.scope}: В функции playerGamemodeEquals для аргумента gamemode получено значение = \"${gamemode.value}\", ожидалось одно из: \"ADVENTURE\", \"CREATIVE\", \"SPECTATOR\", \"SURVIVAL\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("gamemode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to gamemode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_player_gamemode_equals"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerHasItem(items: Any, checkMode: JString? = null, comparisonMode: JString? = null) {
val itemsARG: JItem = when (items) {
    is JItem -> items
    else -> {
        errorPrint("${currentScope.scope}: В playerHasItem:items получен тип ${items.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}


    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("items"),
    "value" to itemsARG.parse()
)))
if (checkMode != null) {
    if (checkMode.value !in setOf("ALL", "ANY")) {
        errorPrint("${currentScope.scope}: В функции playerHasItem для аргумента check_mode получено значение = \"${checkMode.value}\", ожидалось одно из: \"ALL\", \"ANY\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("check_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to checkMode.jsonValue()
        ))
    )))
}
if (comparisonMode != null) {
    if (comparisonMode.value !in setOf("EXACTLY", "IGNORE_DURABILITY_AND_STACK_SIZE", "IGNORE_STACK_SIZE", "TYPE_ONLY")) {
        errorPrint("${currentScope.scope}: В функции playerHasItem для аргумента comparison_mode получено значение = \"${comparisonMode.value}\", ожидалось одно из: \"EXACTLY\", \"IGNORE_DURABILITY_AND_STACK_SIZE\", \"IGNORE_STACK_SIZE\", \"TYPE_ONLY\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("comparison_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to comparisonMode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_player_has_item"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerHasItemAtLeast(item: Any, count: Any, comparisonMode: JString? = null) {
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В playerHasItemAtLeast:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
            val countARG: JNumber = when (count) {
                is Number -> JNumber(count)
is JNumber -> count
                else -> {
                    errorPrint("${currentScope.scope}: В playerHasItemAtLeast:count получен тип ${count.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("count"),
    "value" to countARG.parse()
)))
if (comparisonMode != null) {
    if (comparisonMode.value !in setOf("EXACTLY", "IGNORE_DURABILITY_AND_STACK_SIZE", "IGNORE_STACK_SIZE", "TYPE_ONLY")) {
        errorPrint("${currentScope.scope}: В функции playerHasItemAtLeast для аргумента comparison_mode получено значение = \"${comparisonMode.value}\", ожидалось одно из: \"EXACTLY\", \"IGNORE_DURABILITY_AND_STACK_SIZE\", \"IGNORE_STACK_SIZE\", \"TYPE_ONLY\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("comparison_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to comparisonMode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_player_has_item_at_least"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerHasItemInSlot(slots: Any, items: Any, comparisonMode: JString? = null) {
            val slotsARG: JNumber = when (slots) {
                is Number -> JNumber(slots)
is JNumber -> slots
                else -> {
                    errorPrint("${currentScope.scope}: В playerHasItemInSlot:slots получен тип ${slots.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
val itemsARG: JItem = when (items) {
    is JItem -> items
    else -> {
        errorPrint("${currentScope.scope}: В playerHasItemInSlot:items получен тип ${items.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("slots"),
    "value" to slotsARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("items"),
    "value" to itemsARG.parse()
)))
if (comparisonMode != null) {
    if (comparisonMode.value !in setOf("EXACTLY", "IGNORE_DURABILITY_AND_STACK_SIZE", "IGNORE_STACK_SIZE", "TYPE_ONLY")) {
        errorPrint("${currentScope.scope}: В функции playerHasItemInSlot для аргумента comparison_mode получено значение = \"${comparisonMode.value}\", ожидалось одно из: \"EXACTLY\", \"IGNORE_DURABILITY_AND_STACK_SIZE\", \"IGNORE_STACK_SIZE\", \"TYPE_ONLY\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("comparison_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to comparisonMode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_player_has_item_in_slot"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerHasPotionEffect(potions: Any, checkMode: JString? = null) {
val potionsARG: JPotion = when (potions) {
    is JPotion -> potions
    else -> {
        errorPrint("${currentScope.scope}: В playerHasPotionEffect:potions получен тип ${potions.javaClass.kotlin.simpleName}, ожидалось: JPotion")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("potions"),
    "value" to potionsARG.parse()
)))
if (checkMode != null) {
    if (checkMode.value !in setOf("ALL", "ANY")) {
        errorPrint("${currentScope.scope}: В функции playerHasPotionEffect для аргумента check_mode получено значение = \"${checkMode.value}\", ожидалось одно из: \"ALL\", \"ANY\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("check_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to checkMode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_player_has_potion_effect"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerHasPrivilege(privilege: JString? = null, exact: JString? = null) {


    val funValues = mutableListOf<JsonObject>()
if (privilege != null) {
    if (privilege.value !in setOf("BUILDER", "BUILDER_AND_DEVELOPER", "DEVELOPER", "OWNER", "WHITELISTED")) {
        errorPrint("${currentScope.scope}: В функции playerHasPrivilege для аргумента privilege получено значение = \"${privilege.value}\", ожидалось одно из: \"BUILDER\", \"BUILDER_AND_DEVELOPER\", \"DEVELOPER\", \"OWNER\", \"WHITELISTED\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("privilege"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to privilege.jsonValue()
        ))
    )))
}
if (exact != null) {
    if (exact.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции playerHasPrivilege для аргумента exact получено значение = \"${exact.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("exact"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to exact.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_player_has_privilege"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerHasRoomForItem(items: Any, checkedSlots: JString? = null, checkMode: JString? = null) {
val itemsARG: JItem = when (items) {
    is JItem -> items
    else -> {
        errorPrint("${currentScope.scope}: В playerHasRoomForItem:items получен тип ${items.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}


    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("items"),
    "value" to itemsARG.parse()
)))
if (checkedSlots != null) {
    if (checkedSlots.value !in setOf("ARMOR", "ENTIRE_INVENTORY", "HOTBAR", "MAIN_INVENTORY", "UPPER_INVENTORY")) {
        errorPrint("${currentScope.scope}: В функции playerHasRoomForItem для аргумента checked_slots получено значение = \"${checkedSlots.value}\", ожидалось одно из: \"ARMOR\", \"ENTIRE_INVENTORY\", \"HOTBAR\", \"MAIN_INVENTORY\", \"UPPER_INVENTORY\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("checked_slots"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to checkedSlots.jsonValue()
        ))
    )))
}
if (checkMode != null) {
    if (checkMode.value !in setOf("ALL", "ANY")) {
        errorPrint("${currentScope.scope}: В функции playerHasRoomForItem для аргумента check_mode получено значение = \"${checkMode.value}\", ожидалось одно из: \"ALL\", \"ANY\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("check_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to checkMode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_player_has_room_for_item"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerHotbarSlotEquals(slot: Any) {
            val slotARG: JNumber = when (slot) {
                is Number -> JNumber(slot)
is JNumber -> slot
                else -> {
                    errorPrint("${currentScope.scope}: В playerHotbarSlotEquals:slot получен тип ${slot.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("slot"),
    "value" to slotARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_player_hotbar_slot_equals"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerInArea(location1: Any, location2: Any, ignoreYAxis: JString? = null, intersectType: JString? = null, checkType: JString? = null) {
val location1ARG: JLocation = when (location1) {
    is JLocation -> location1
    else -> {
        errorPrint("${currentScope.scope}: В playerInArea:location1 получен тип ${location1.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
val location2ARG: JLocation = when (location2) {
    is JLocation -> location2
    else -> {
        errorPrint("${currentScope.scope}: В playerInArea:location2 получен тип ${location2.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}



    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location_1"),
    "value" to location1ARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location_2"),
    "value" to location2ARG.parse()
)))
if (ignoreYAxis != null) {
    if (ignoreYAxis.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции playerInArea для аргумента ignore_y_axis получено значение = \"${ignoreYAxis.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("ignore_y_axis"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to ignoreYAxis.jsonValue()
        ))
    )))
}
if (intersectType != null) {
    if (intersectType.value !in setOf("HITBOX", "POINT")) {
        errorPrint("${currentScope.scope}: В функции playerInArea для аргумента intersect_type получено значение = \"${intersectType.value}\", ожидалось одно из: \"HITBOX\", \"POINT\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("intersect_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to intersectType.jsonValue()
        ))
    )))
}
if (checkType != null) {
    if (checkType.value !in setOf("CONTAINS", "OVERLAPS")) {
        errorPrint("${currentScope.scope}: В функции playerInArea для аргумента check_type получено значение = \"${checkType.value}\", ожидалось одно из: \"CONTAINS\", \"OVERLAPS\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("check_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to checkType.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_player_in_area"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerInventoryMenuSlotEquals(slots: Any, items: Any, comparisonMode: JString? = null) {
            val slotsARG: JNumber = when (slots) {
                is Number -> JNumber(slots)
is JNumber -> slots
                else -> {
                    errorPrint("${currentScope.scope}: В playerInventoryMenuSlotEquals:slots получен тип ${slots.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
val itemsARG: JItem = when (items) {
    is JItem -> items
    else -> {
        errorPrint("${currentScope.scope}: В playerInventoryMenuSlotEquals:items получен тип ${items.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("slots"),
    "value" to slotsARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("items"),
    "value" to itemsARG.parse()
)))
if (comparisonMode != null) {
    if (comparisonMode.value !in setOf("EXACTLY", "IGNORE_DURABILITY_AND_STACK_SIZE", "IGNORE_STACK_SIZE", "TYPE_ONLY")) {
        errorPrint("${currentScope.scope}: В функции playerInventoryMenuSlotEquals для аргумента comparison_mode получено значение = \"${comparisonMode.value}\", ожидалось одно из: \"EXACTLY\", \"IGNORE_DURABILITY_AND_STACK_SIZE\", \"IGNORE_STACK_SIZE\", \"TYPE_ONLY\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("comparison_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to comparisonMode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_player_inventory_menu_slot_equals"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerInventoryTypeOpen(inventoryType: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (inventoryType != null) {
    if (inventoryType.value !in setOf("ANVIL", "BARREL", "BEACON", "BLAST_FURNACE", "BREWING", "CARTOGRAPHY", "CHEST", "CHISELED_BOOKSHELF", "COMPOSTER", "CRAFTER", "CRAFTING", "CREATIVE", "DECORATED_POT", "DISPENSER", "DROPPER", "ENCHANTING", "ENDER_CHEST", "FURNACE", "GRINDSTONE", "HOPPER", "JUKEBOX", "LECTERN", "LOOM", "MERCHANT", "PLAYER", "SHULKER_BOX", "SMITHING", "SMITHING_NEW", "SMOKER", "STONECUTTER", "WORKBENCH")) {
        errorPrint("${currentScope.scope}: В функции playerInventoryTypeOpen для аргумента inventory_type получено значение = \"${inventoryType.value}\", ожидалось одно из: \"ANVIL\", \"BARREL\", \"BEACON\", \"BLAST_FURNACE\", \"BREWING\", \"CARTOGRAPHY\", \"CHEST\", \"CHISELED_BOOKSHELF\", \"COMPOSTER\", \"CRAFTER\", \"CRAFTING\", \"CREATIVE\", \"DECORATED_POT\", \"DISPENSER\", \"DROPPER\", \"ENCHANTING\", \"ENDER_CHEST\", \"FURNACE\", \"GRINDSTONE\", \"HOPPER\", \"JUKEBOX\", \"LECTERN\", \"LOOM\", \"MERCHANT\", \"PLAYER\", \"SHULKER_BOX\", \"SMITHING\", \"SMITHING_NEW\", \"SMOKER\", \"STONECUTTER\", \"WORKBENCH\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("inventory_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to inventoryType.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_player_inventory_type_open"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerIsAllowServerListing() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_player_is_allow_server_listing"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerIsBlocking() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_player_is_blocking"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerIsDisguised() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_player_is_disguised"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerIsFlying() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_player_is_flying"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerIsGliding() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_player_is_gliding"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerHolding(items: Any, handSlot: JString? = null, comparisonMode: JString? = null) {
val itemsARG: JItem = when (items) {
    is JItem -> items
    else -> {
        errorPrint("${currentScope.scope}: В playerHolding:items получен тип ${items.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}


    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("items"),
    "value" to itemsARG.parse()
)))
if (handSlot != null) {
    if (handSlot.value !in setOf("EITHER_HAND", "MAIN_HAND", "OFF_HAND")) {
        errorPrint("${currentScope.scope}: В функции playerHolding для аргумента hand_slot получено значение = \"${handSlot.value}\", ожидалось одно из: \"EITHER_HAND\", \"MAIN_HAND\", \"OFF_HAND\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("hand_slot"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to handSlot.jsonValue()
        ))
    )))
}
if (comparisonMode != null) {
    if (comparisonMode.value !in setOf("EXACTLY", "IGNORE_DURABILITY_AND_STACK_SIZE", "IGNORE_STACK_SIZE", "TYPE_ONLY")) {
        errorPrint("${currentScope.scope}: В функции playerHolding для аргумента comparison_mode получено значение = \"${comparisonMode.value}\", ожидалось одно из: \"EXACTLY\", \"IGNORE_DURABILITY_AND_STACK_SIZE\", \"IGNORE_STACK_SIZE\", \"TYPE_ONLY\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("comparison_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to comparisonMode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_player_is_holding"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerIsLookingAtBlock(blocks: Any, locations: Any, distance: Any, fluidMode: JString? = null) {
val blocksARG: JBlock = when (blocks) {
    is JBlock -> blocks
    else -> {
        errorPrint("${currentScope.scope}: В playerIsLookingAtBlock:blocks получен тип ${blocks.javaClass.kotlin.simpleName}, ожидалось: JBlock")
        throw Exception()
    }
}
val locationsARG: JLocation = when (locations) {
    is JLocation -> locations
    else -> {
        errorPrint("${currentScope.scope}: В playerIsLookingAtBlock:locations получен тип ${locations.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val distanceARG: JNumber = when (distance) {
                is Number -> JNumber(distance)
is JNumber -> distance
                else -> {
                    errorPrint("${currentScope.scope}: В playerIsLookingAtBlock:distance получен тип ${distance.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("blocks"),
    "value" to blocksARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("locations"),
    "value" to locationsARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("distance"),
    "value" to distanceARG.parse()
)))
if (fluidMode != null) {
    if (fluidMode.value !in setOf("ALWAYS", "NEVER", "SOURCE_ONLY")) {
        errorPrint("${currentScope.scope}: В функции playerIsLookingAtBlock для аргумента fluid_mode получено значение = \"${fluidMode.value}\", ожидалось одно из: \"ALWAYS\", \"NEVER\", \"SOURCE_ONLY\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("fluid_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to fluidMode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_player_is_looking_at_block"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerIsNear(range: Any, location: Any, ignoreYAxis: JString? = null) {
            val rangeARG: JNumber = when (range) {
                is Number -> JNumber(range)
is JNumber -> range
                else -> {
                    errorPrint("${currentScope.scope}: В playerIsNear:range получен тип ${range.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В playerIsNear:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("range"),
    "value" to rangeARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
if (ignoreYAxis != null) {
    if (ignoreYAxis.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции playerIsNear для аргумента ignore_y_axis получено значение = \"${ignoreYAxis.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("ignore_y_axis"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to ignoreYAxis.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_player_is_near"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerIsOnGround() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_player_is_on_ground"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerIsOnlineMode() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_player_is_online_mode"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerIsRidingEntity(entityIds: Any, compareMode: JString? = null) {
            val entityIdsARG: JString = when (entityIds) {
                is String -> JString(entityIds)
is JString -> entityIds
                else -> {
                    errorPrint("${currentScope.scope}: В playerIsRidingEntity:entityIds получен тип ${entityIds.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("entity_ids"),
    "value" to entityIdsARG.parse()
)))
if (compareMode != null) {
    if (compareMode.value !in setOf("FARTHEST", "NAME_OR_UUID", "NEAREST", "TYPE")) {
        errorPrint("${currentScope.scope}: В функции playerIsRidingEntity для аргумента compare_mode получено значение = \"${compareMode.value}\", ожидалось одно из: \"FARTHEST\", \"NAME_OR_UUID\", \"NEAREST\", \"TYPE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("compare_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to compareMode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_player_is_riding_entity"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerIsSelfDisguised() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_player_is_self_disguised"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerIsSleeping() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_player_is_sleeping"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerIsSneaking() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_player_is_sneaking"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerIsSprinting() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_player_is_sprinting"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerIsStandingOnBlock(blocks: Any, locations: Any, onlySolid: JString? = null) {
val blocksARG: JBlock = when (blocks) {
    is JBlock -> blocks
    else -> {
        errorPrint("${currentScope.scope}: В playerIsStandingOnBlock:blocks получен тип ${blocks.javaClass.kotlin.simpleName}, ожидалось: JBlock")
        throw Exception()
    }
}
val locationsARG: JLocation = when (locations) {
    is JLocation -> locations
    else -> {
        errorPrint("${currentScope.scope}: В playerIsStandingOnBlock:locations получен тип ${locations.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("blocks"),
    "value" to blocksARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("locations"),
    "value" to locationsARG.parse()
)))
if (onlySolid != null) {
    if (onlySolid.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции playerIsStandingOnBlock для аргумента only_solid получено значение = \"${onlySolid.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("only_solid"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to onlySolid.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_player_is_standing_on_block"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerIsSwimming() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_player_is_swimming"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerIsUsingItem(items: Any, comparisonMode: JString? = null) {
val itemsARG: JItem = when (items) {
    is JItem -> items
    else -> {
        errorPrint("${currentScope.scope}: В playerIsUsingItem:items получен тип ${items.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("items"),
    "value" to itemsARG.parse()
)))
if (comparisonMode != null) {
    if (comparisonMode.value !in setOf("EXACTLY", "IGNORE_DURABILITY_AND_STACK_SIZE", "IGNORE_STACK_SIZE", "TYPE_ONLY")) {
        errorPrint("${currentScope.scope}: В функции playerIsUsingItem для аргумента comparison_mode получено значение = \"${comparisonMode.value}\", ожидалось одно из: \"EXACTLY\", \"IGNORE_DURABILITY_AND_STACK_SIZE\", \"IGNORE_STACK_SIZE\", \"TYPE_ONLY\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("comparison_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to comparisonMode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_player_is_using_item"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerIsWearingItem(items: Any, checkMode: JString? = null, comparisonMode: JString? = null) {
val itemsARG: JItem = when (items) {
    is JItem -> items
    else -> {
        errorPrint("${currentScope.scope}: В playerIsWearingItem:items получен тип ${items.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}


    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("items"),
    "value" to itemsARG.parse()
)))
if (checkMode != null) {
    if (checkMode.value !in setOf("ALL", "ANY")) {
        errorPrint("${currentScope.scope}: В функции playerIsWearingItem для аргумента check_mode получено значение = \"${checkMode.value}\", ожидалось одно из: \"ALL\", \"ANY\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("check_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to checkMode.jsonValue()
        ))
    )))
}
if (comparisonMode != null) {
    if (comparisonMode.value !in setOf("EXACTLY", "IGNORE_DURABILITY_AND_STACK_SIZE", "IGNORE_STACK_SIZE", "TYPE_ONLY")) {
        errorPrint("${currentScope.scope}: В функции playerIsWearingItem для аргумента comparison_mode получено значение = \"${comparisonMode.value}\", ожидалось одно из: \"EXACTLY\", \"IGNORE_DURABILITY_AND_STACK_SIZE\", \"IGNORE_STACK_SIZE\", \"TYPE_ONLY\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("comparison_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to comparisonMode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_player_is_wearing_item"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerItemIsNotOnCooldown(items: Any) {
val itemsARG: JItem = when (items) {
    is JItem -> items
    else -> {
        errorPrint("${currentScope.scope}: В playerItemIsNotOnCooldown:items получен тип ${items.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("items"),
    "value" to itemsARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_player_item_is_not_on_cooldown"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerNameEquals(namesOrUuids: Any) {
            val namesOrUuidsARG: JString = when (namesOrUuids) {
                is String -> JString(namesOrUuids)
is JString -> namesOrUuids
                else -> {
                    errorPrint("${currentScope.scope}: В playerNameEquals:namesOrUuids получен тип ${namesOrUuids.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("names_or_uuids"),
    "value" to namesOrUuidsARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_player_name_equals"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerTextFilteringEnabled() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_player_text_filtering_enabled"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableEquals(value: Any, compare: Any) {
val valueARG: JAny = when (value) {
    is JAny -> value
    else -> {
        errorPrint("${currentScope.scope}: В variableEquals:value получен тип ${value.javaClass.kotlin.simpleName}, ожидалось: JAny")
        throw Exception()
    }
}
val compareARG: JAny = when (compare) {
    is JAny -> compare
    else -> {
        errorPrint("${currentScope.scope}: В variableEquals:compare получен тип ${compare.javaClass.kotlin.simpleName}, ожидалось: JAny")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("value"),
    "value" to valueARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("compare"),
    "value" to compareARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_variable_equals"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableExists(variable: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableExists:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_variable_exists"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGreater(value: Any, compare: Any) {
            val valueARG: JNumber = when (value) {
                is Number -> JNumber(value)
is JNumber -> value
                else -> {
                    errorPrint("${currentScope.scope}: В variableGreater:value получен тип ${value.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val compareARG: JNumber = when (compare) {
                is Number -> JNumber(compare)
is JNumber -> compare
                else -> {
                    errorPrint("${currentScope.scope}: В variableGreater:compare получен тип ${compare.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("value"),
    "value" to valueARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("compare"),
    "value" to compareARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_variable_greater"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGreaterOrEquals(value: Any, compare: Any) {
            val valueARG: JNumber = when (value) {
                is Number -> JNumber(value)
is JNumber -> value
                else -> {
                    errorPrint("${currentScope.scope}: В variableGreaterOrEquals:value получен тип ${value.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val compareARG: JNumber = when (compare) {
                is Number -> JNumber(compare)
is JNumber -> compare
                else -> {
                    errorPrint("${currentScope.scope}: В variableGreaterOrEquals:compare получен тип ${compare.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("value"),
    "value" to valueARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("compare"),
    "value" to compareARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_variable_greater_or_equals"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableInRange(value: Any, min: Any, max: Any) {
val valueARG: JAny = when (value) {
    is JAny -> value
    else -> {
        errorPrint("${currentScope.scope}: В variableInRange:value получен тип ${value.javaClass.kotlin.simpleName}, ожидалось: JAny")
        throw Exception()
    }
}
val minARG: JAny = when (min) {
    is JAny -> min
    else -> {
        errorPrint("${currentScope.scope}: В variableInRange:min получен тип ${min.javaClass.kotlin.simpleName}, ожидалось: JAny")
        throw Exception()
    }
}
val maxARG: JAny = when (max) {
    is JAny -> max
    else -> {
        errorPrint("${currentScope.scope}: В variableInRange:max получен тип ${max.javaClass.kotlin.simpleName}, ожидалось: JAny")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("value"),
    "value" to valueARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("min"),
    "value" to minARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("max"),
    "value" to maxARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_variable_in_range"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableIsType(value: Any, variableType: JString? = null) {
val valueARG: JAny = when (value) {
    is JAny -> value
    else -> {
        errorPrint("${currentScope.scope}: В variableIsType:value получен тип ${value.javaClass.kotlin.simpleName}, ожидалось: JAny")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("value"),
    "value" to valueARG.parse()
)))
if (variableType != null) {
    if (variableType.value !in setOf("ARRAY", "ITEM", "LOCATION", "MAP", "NUMBER", "PARTICLE", "POTION", "SOUND", "TEXT", "VECTOR")) {
        errorPrint("${currentScope.scope}: В функции variableIsType для аргумента variable_type получено значение = \"${variableType.value}\", ожидалось одно из: \"ARRAY\", \"ITEM\", \"LOCATION\", \"MAP\", \"NUMBER\", \"PARTICLE\", \"POTION\", \"SOUND\", \"TEXT\", \"VECTOR\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("variable_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to variableType.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_variable_is_type"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableItemEquals(value: Any, compare: Any, comparisonMode: JString? = null) {
val valueARG: JItem = when (value) {
    is JItem -> value
    else -> {
        errorPrint("${currentScope.scope}: В variableItemEquals:value получен тип ${value.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
val compareARG: JItem = when (compare) {
    is JItem -> compare
    else -> {
        errorPrint("${currentScope.scope}: В variableItemEquals:compare получен тип ${compare.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("value"),
    "value" to valueARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("compare"),
    "value" to compareARG.parse()
)))
if (comparisonMode != null) {
    if (comparisonMode.value !in setOf("EXACTLY", "IGNORE_DURABILITY_AND_STACK_SIZE", "IGNORE_STACK_SIZE", "TYPE_ONLY")) {
        errorPrint("${currentScope.scope}: В функции variableItemEquals для аргумента comparison_mode получено значение = \"${comparisonMode.value}\", ожидалось одно из: \"EXACTLY\", \"IGNORE_DURABILITY_AND_STACK_SIZE\", \"IGNORE_STACK_SIZE\", \"TYPE_ONLY\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("comparison_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to comparisonMode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_variable_item_equals"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableItemHasEnchantment(item: Any, enchant: Any, level: Any) {
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В variableItemHasEnchantment:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
            val enchantARG: JString = when (enchant) {
                is String -> JString(enchant)
is JString -> enchant
                else -> {
                    errorPrint("${currentScope.scope}: В variableItemHasEnchantment:enchant получен тип ${enchant.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val levelARG: JNumber = when (level) {
                is Number -> JNumber(level)
is JNumber -> level
                else -> {
                    errorPrint("${currentScope.scope}: В variableItemHasEnchantment:level получен тип ${level.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("enchant"),
    "value" to enchantARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("level"),
    "value" to levelARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_variable_item_has_enchantment"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableItemHasTag(item: Any, tag: Any, value: Any, compareType: JString? = null) {
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В variableItemHasTag:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
            val tagARG: JString = when (tag) {
                is String -> JString(tag)
is JString -> tag
                else -> {
                    errorPrint("${currentScope.scope}: В variableItemHasTag:tag получен тип ${tag.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val valueARG: JString = when (value) {
                is String -> JString(value)
is JString -> value
                else -> {
                    errorPrint("${currentScope.scope}: В variableItemHasTag:value получен тип ${value.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("tag"),
    "value" to tagARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("value"),
    "value" to valueARG.parse()
)))
if (compareType != null) {
    if (compareType.value !in setOf("CONTAINS", "ENDS_WITH", "EQUALS", "STARTS_WITH")) {
        errorPrint("${currentScope.scope}: В функции variableItemHasTag для аргумента compare_type получено значение = \"${compareType.value}\", ожидалось одно из: \"CONTAINS\", \"ENDS_WITH\", \"EQUALS\", \"STARTS_WITH\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("compare_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to compareType.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_variable_item_has_tag"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableLess(value: Any, compare: Any) {
            val valueARG: JNumber = when (value) {
                is Number -> JNumber(value)
is JNumber -> value
                else -> {
                    errorPrint("${currentScope.scope}: В variableLess:value получен тип ${value.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val compareARG: JNumber = when (compare) {
                is Number -> JNumber(compare)
is JNumber -> compare
                else -> {
                    errorPrint("${currentScope.scope}: В variableLess:compare получен тип ${compare.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("value"),
    "value" to valueARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("compare"),
    "value" to compareARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_variable_less"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableLessOrEquals(value: Any, compare: Any) {
            val valueARG: JNumber = when (value) {
                is Number -> JNumber(value)
is JNumber -> value
                else -> {
                    errorPrint("${currentScope.scope}: В variableLessOrEquals:value получен тип ${value.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val compareARG: JNumber = when (compare) {
                is Number -> JNumber(compare)
is JNumber -> compare
                else -> {
                    errorPrint("${currentScope.scope}: В variableLessOrEquals:compare получен тип ${compare.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("value"),
    "value" to valueARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("compare"),
    "value" to compareARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_variable_less_or_equals"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableListContainsValue(list: Any, values: Any, checkMode: JString? = null) {
val listARG: JArray = when (list) {
    is JArray -> list
    else -> {
        errorPrint("${currentScope.scope}: В variableListContainsValue:list получен тип ${list.javaClass.kotlin.simpleName}, ожидалось: JArray")
        throw Exception()
    }
}
val valuesARG: JAny = when (values) {
    is JAny -> values
    else -> {
        errorPrint("${currentScope.scope}: В variableListContainsValue:values получен тип ${values.javaClass.kotlin.simpleName}, ожидалось: JAny")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("list"),
    "value" to listARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("values"),
    "value" to valuesARG.parse()
)))
if (checkMode != null) {
    if (checkMode.value !in setOf("ALL", "ANY")) {
        errorPrint("${currentScope.scope}: В функции variableListContainsValue для аргумента check_mode получено значение = \"${checkMode.value}\", ожидалось одно из: \"ALL\", \"ANY\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("check_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to checkMode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_variable_list_contains_value"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableListIsEmpty(list: Any) {
val listARG: JAny = when (list) {
    is JAny -> list
    else -> {
        errorPrint("${currentScope.scope}: В variableListIsEmpty:list получен тип ${list.javaClass.kotlin.simpleName}, ожидалось: JAny")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("list"),
    "value" to listARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_variable_list_is_empty"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableListValueEquals(list: Any, index: Any, values: Any) {
val listARG: JArray = when (list) {
    is JArray -> list
    else -> {
        errorPrint("${currentScope.scope}: В variableListValueEquals:list получен тип ${list.javaClass.kotlin.simpleName}, ожидалось: JArray")
        throw Exception()
    }
}
            val indexARG: JNumber = when (index) {
                is Number -> JNumber(index)
is JNumber -> index
                else -> {
                    errorPrint("${currentScope.scope}: В variableListValueEquals:index получен тип ${index.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
val valuesARG: JAny = when (values) {
    is JAny -> values
    else -> {
        errorPrint("${currentScope.scope}: В variableListValueEquals:values получен тип ${values.javaClass.kotlin.simpleName}, ожидалось: JAny")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("list"),
    "value" to listARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("index"),
    "value" to indexARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("values"),
    "value" to valuesARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_variable_list_value_equals"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableLocationInRange(value: Any, min: Any, max: Any, borderHandling: JString? = null) {
val valueARG: JLocation = when (value) {
    is JLocation -> value
    else -> {
        errorPrint("${currentScope.scope}: В variableLocationInRange:value получен тип ${value.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
val minARG: JLocation = when (min) {
    is JLocation -> min
    else -> {
        errorPrint("${currentScope.scope}: В variableLocationInRange:min получен тип ${min.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
val maxARG: JLocation = when (max) {
    is JLocation -> max
    else -> {
        errorPrint("${currentScope.scope}: В variableLocationInRange:max получен тип ${max.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("value"),
    "value" to valueARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("min"),
    "value" to minARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("max"),
    "value" to maxARG.parse()
)))
if (borderHandling != null) {
    if (borderHandling.value !in setOf("BLOCK", "EXACT", "FULL_BLOCK_RANGE")) {
        errorPrint("${currentScope.scope}: В функции variableLocationInRange для аргумента border_handling получено значение = \"${borderHandling.value}\", ожидалось одно из: \"BLOCK\", \"EXACT\", \"FULL_BLOCK_RANGE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("border_handling"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to borderHandling.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_variable_location_in_range"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableLocationIsNear(location: Any, radius: Any, check: Any, shape: JString? = null) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В variableLocationIsNear:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val radiusARG: JNumber = when (radius) {
                is Number -> JNumber(radius)
is JNumber -> radius
                else -> {
                    errorPrint("${currentScope.scope}: В variableLocationIsNear:radius получен тип ${radius.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
val checkARG: JLocation = when (check) {
    is JLocation -> check
    else -> {
        errorPrint("${currentScope.scope}: В variableLocationIsNear:check получен тип ${check.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("radius"),
    "value" to radiusARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("check"),
    "value" to checkARG.parse()
)))
if (shape != null) {
    if (shape.value !in setOf("CIRCLE", "CUBE", "SPHERE", "SQUARE")) {
        errorPrint("${currentScope.scope}: В функции variableLocationIsNear для аргумента shape получено значение = \"${shape.value}\", ожидалось одно из: \"CIRCLE\", \"CUBE\", \"SPHERE\", \"SQUARE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("shape"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to shape.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_variable_location_is_near"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableMapHasKey(map: Any, key: Any) {
val mapARG: JMap = when (map) {
    is JMap -> map
    else -> {
        errorPrint("${currentScope.scope}: В variableMapHasKey:map получен тип ${map.javaClass.kotlin.simpleName}, ожидалось: JMap")
        throw Exception()
    }
}
val keyARG: JAny = when (key) {
    is JAny -> key
    else -> {
        errorPrint("${currentScope.scope}: В variableMapHasKey:key получен тип ${key.javaClass.kotlin.simpleName}, ожидалось: JAny")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("map"),
    "value" to mapARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("key"),
    "value" to keyARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_variable_map_has_key"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableMapValueEquals(map: Any, key: Any, values: Any) {
val mapARG: JMap = when (map) {
    is JMap -> map
    else -> {
        errorPrint("${currentScope.scope}: В variableMapValueEquals:map получен тип ${map.javaClass.kotlin.simpleName}, ожидалось: JMap")
        throw Exception()
    }
}
val keyARG: JAny = when (key) {
    is JAny -> key
    else -> {
        errorPrint("${currentScope.scope}: В variableMapValueEquals:key получен тип ${key.javaClass.kotlin.simpleName}, ожидалось: JAny")
        throw Exception()
    }
}
val valuesARG: JAny = when (values) {
    is JAny -> values
    else -> {
        errorPrint("${currentScope.scope}: В variableMapValueEquals:values получен тип ${values.javaClass.kotlin.simpleName}, ожидалось: JAny")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("map"),
    "value" to mapARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("key"),
    "value" to keyARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("values"),
    "value" to valuesARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_variable_map_value_equals"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableNotEquals(value: Any, compare: Any) {
val valueARG: JAny = when (value) {
    is JAny -> value
    else -> {
        errorPrint("${currentScope.scope}: В variableNotEquals:value получен тип ${value.javaClass.kotlin.simpleName}, ожидалось: JAny")
        throw Exception()
    }
}
val compareARG: JAny = when (compare) {
    is JAny -> compare
    else -> {
        errorPrint("${currentScope.scope}: В variableNotEquals:compare получен тип ${compare.javaClass.kotlin.simpleName}, ожидалось: JAny")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("value"),
    "value" to valueARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("compare"),
    "value" to compareARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_variable_not_equals"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableRangeIntersectsRange(min1: Any, max1: Any, min2: Any, max2: Any, checkType: JString? = null) {
val min1ARG: JLocation = when (min1) {
    is JLocation -> min1
    else -> {
        errorPrint("${currentScope.scope}: В variableRangeIntersectsRange:min1 получен тип ${min1.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
val max1ARG: JLocation = when (max1) {
    is JLocation -> max1
    else -> {
        errorPrint("${currentScope.scope}: В variableRangeIntersectsRange:max1 получен тип ${max1.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
val min2ARG: JLocation = when (min2) {
    is JLocation -> min2
    else -> {
        errorPrint("${currentScope.scope}: В variableRangeIntersectsRange:min2 получен тип ${min2.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
val max2ARG: JLocation = when (max2) {
    is JLocation -> max2
    else -> {
        errorPrint("${currentScope.scope}: В variableRangeIntersectsRange:max2 получен тип ${max2.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("min1"),
    "value" to min1ARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("max1"),
    "value" to max1ARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("min2"),
    "value" to min2ARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("max2"),
    "value" to max2ARG.parse()
)))
if (checkType != null) {
    if (checkType.value !in setOf("CONTAINS", "OVERLAPS")) {
        errorPrint("${currentScope.scope}: В функции variableRangeIntersectsRange для аргумента check_type получено значение = \"${checkType.value}\", ожидалось одно из: \"CONTAINS\", \"OVERLAPS\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("check_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to checkType.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_variable_range_intersects_range"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableTextContains(value: Any, compare: Any, ignoreCase: JString? = null) {
            val valueARG: JString = when (value) {
                is String -> JString(value)
is JString -> value
                else -> {
                    errorPrint("${currentScope.scope}: В variableTextContains:value получен тип ${value.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val compareARG: JString = when (compare) {
                is String -> JString(compare)
is JString -> compare
                else -> {
                    errorPrint("${currentScope.scope}: В variableTextContains:compare получен тип ${compare.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("value"),
    "value" to valueARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("compare"),
    "value" to compareARG.parse()
)))
if (ignoreCase != null) {
    if (ignoreCase.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции variableTextContains для аргумента ignore_case получено значение = \"${ignoreCase.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("ignore_case"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to ignoreCase.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_variable_text_contains"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableTextEndsWith(value: Any, compare: Any, ignoreCase: JString? = null) {
            val valueARG: JString = when (value) {
                is String -> JString(value)
is JString -> value
                else -> {
                    errorPrint("${currentScope.scope}: В variableTextEndsWith:value получен тип ${value.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val compareARG: JString = when (compare) {
                is String -> JString(compare)
is JString -> compare
                else -> {
                    errorPrint("${currentScope.scope}: В variableTextEndsWith:compare получен тип ${compare.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("value"),
    "value" to valueARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("compare"),
    "value" to compareARG.parse()
)))
if (ignoreCase != null) {
    if (ignoreCase.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции variableTextEndsWith для аргумента ignore_case получено значение = \"${ignoreCase.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("ignore_case"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to ignoreCase.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_variable_text_ends_with"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableTextMatches(match: Any, values: Any, regularExpressions: JString? = null, ignoreCase: JString? = null) {
            val matchARG: JString = when (match) {
                is String -> JString(match)
is JString -> match
                else -> {
                    errorPrint("${currentScope.scope}: В variableTextMatches:match получен тип ${match.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val valuesARG: JString = when (values) {
                is String -> JString(values)
is JString -> values
                else -> {
                    errorPrint("${currentScope.scope}: В variableTextMatches:values получен тип ${values.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }


    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("match"),
    "value" to matchARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("values"),
    "value" to valuesARG.parse()
)))
if (regularExpressions != null) {
    if (regularExpressions.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции variableTextMatches для аргумента regular_expressions получено значение = \"${regularExpressions.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("regular_expressions"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to regularExpressions.jsonValue()
        ))
    )))
}
if (ignoreCase != null) {
    if (ignoreCase.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции variableTextMatches для аргумента ignore_case получено значение = \"${ignoreCase.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("ignore_case"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to ignoreCase.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_variable_text_matches"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableTextStartsWith(value: Any, compare: Any, ignoreCase: JString? = null) {
            val valueARG: JString = when (value) {
                is String -> JString(value)
is JString -> value
                else -> {
                    errorPrint("${currentScope.scope}: В variableTextStartsWith:value получен тип ${value.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val compareARG: JString = when (compare) {
                is String -> JString(compare)
is JString -> compare
                else -> {
                    errorPrint("${currentScope.scope}: В variableTextStartsWith:compare получен тип ${compare.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("value"),
    "value" to valueARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("compare"),
    "value" to compareARG.parse()
)))
if (ignoreCase != null) {
    if (ignoreCase.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции variableTextStartsWith для аргумента ignore_case получено значение = \"${ignoreCase.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("ignore_case"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to ignoreCase.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("if_variable_text_starts_with"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerAddInventoryMenuRow(items: Any, position: JString? = null) {
val itemsARG: JItem = when (items) {
    is JItem -> items
    else -> {
        errorPrint("${currentScope.scope}: В playerAddInventoryMenuRow:items получен тип ${items.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("items"),
    "value" to itemsARG.parse()
)))
if (position != null) {
    if (position.value !in setOf("BUTTON", "TOP")) {
        errorPrint("${currentScope.scope}: В функции playerAddInventoryMenuRow для аргумента position получено значение = \"${position.value}\", ожидалось одно из: \"BUTTON\", \"TOP\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("position"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to position.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_add_inventory_menu_row"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerAllowPlacingBreakingBlocks(blocks: Any, allow: JString? = null) {
val blocksARG: JBlock = when (blocks) {
    is JBlock -> blocks
    else -> {
        errorPrint("${currentScope.scope}: В playerAllowPlacingBreakingBlocks:blocks получен тип ${blocks.javaClass.kotlin.simpleName}, ожидалось: JBlock")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("blocks"),
    "value" to blocksARG.parse()
)))
if (allow != null) {
    if (allow.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции playerAllowPlacingBreakingBlocks для аргумента allow получено значение = \"${allow.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("allow"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to allow.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_allow_placing_breaking_blocks"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerBoostElytra(firework: Any) {
val fireworkARG: JItem = when (firework) {
    is JItem -> firework
    else -> {
        errorPrint("${currentScope.scope}: В playerBoostElytra:firework получен тип ${firework.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("firework"),
    "value" to fireworkARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_boost_elytra"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerClearChat() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_clear_chat"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerClearDebugMarkers() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_clear_debug_markers"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerClearEnderChestContents() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_clear_ender_chest_contents"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerClearInventory(clearMode: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (clearMode != null) {
    if (clearMode.value !in setOf("ARMOR", "ENTIRE", "HOTBAR", "MAIN", "UPPER")) {
        errorPrint("${currentScope.scope}: В функции playerClearInventory для аргумента clear_mode получено значение = \"${clearMode.value}\", ожидалось одно из: \"ARMOR\", \"ENTIRE\", \"HOTBAR\", \"MAIN\", \"UPPER\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("clear_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to clearMode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_clear_inventory"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerClearItems(items: Any) {
val itemsARG: JItem = when (items) {
    is JItem -> items
    else -> {
        errorPrint("${currentScope.scope}: В playerClearItems:items получен тип ${items.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("items"),
    "value" to itemsARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_clear_items"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerClearPotionEffects() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_clear_potion_effects"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerCloseInventory() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_close_inventory"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerDamage(damage: Any, source: Any) {
            val damageARG: JNumber = when (damage) {
                is Number -> JNumber(damage)
is JNumber -> damage
                else -> {
                    errorPrint("${currentScope.scope}: В playerDamage:damage получен тип ${damage.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val sourceARG: JString = when (source) {
                is String -> JString(source)
is JString -> source
                else -> {
                    errorPrint("${currentScope.scope}: В playerDamage:source получен тип ${source.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("damage"),
    "value" to damageARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("source"),
    "value" to sourceARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_damage"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerDisguiseAsBlock(block: Any, visibleToSelf: JString? = null) {
val blockARG: JBlock = when (block) {
    is JBlock -> block
    else -> {
        errorPrint("${currentScope.scope}: В playerDisguiseAsBlock:block получен тип ${block.javaClass.kotlin.simpleName}, ожидалось: JBlock")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("block"),
    "value" to blockARG.parse()
)))
if (visibleToSelf != null) {
    if (visibleToSelf.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции playerDisguiseAsBlock для аргумента visible_to_self получено значение = \"${visibleToSelf.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("visible_to_self"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to visibleToSelf.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_disguise_as_block"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerDisguiseAsEntity(entityType: Any, visibleToSelf: JString? = null) {
val entityTypeARG: JItem = when (entityType) {
    is JItem -> entityType
    else -> {
        errorPrint("${currentScope.scope}: В playerDisguiseAsEntity:entityType получен тип ${entityType.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("entity_type"),
    "value" to entityTypeARG.parse()
)))
if (visibleToSelf != null) {
    if (visibleToSelf.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции playerDisguiseAsEntity для аргумента visible_to_self получено значение = \"${visibleToSelf.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("visible_to_self"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to visibleToSelf.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_disguise_as_entity"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerDisguiseAsItem(item: Any, visibleToSelf: JString? = null) {
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В playerDisguiseAsItem:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
if (visibleToSelf != null) {
    if (visibleToSelf.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции playerDisguiseAsItem для аргумента visible_to_self получено значение = \"${visibleToSelf.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("visible_to_self"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to visibleToSelf.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_disguise_as_item"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerDisplayBellRing(location: Any, direction: JString? = null) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В playerDisplayBellRing:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
if (direction != null) {
    if (direction.value !in setOf("DOWN", "EAST", "NORTH", "SOUTH", "WEST")) {
        errorPrint("${currentScope.scope}: В функции playerDisplayBellRing для аргумента direction получено значение = \"${direction.value}\", ожидалось одно из: \"DOWN\", \"EAST\", \"NORTH\", \"SOUTH\", \"WEST\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("direction"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to direction.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_display_bell_ring"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerDisplayBlock(location: Any, block: Any) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В playerDisplayBlock:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
val blockARG: JBlock = when (block) {
    is JBlock -> block
    else -> {
        errorPrint("${currentScope.scope}: В playerDisplayBlock:block получен тип ${block.javaClass.kotlin.simpleName}, ожидалось: JBlock")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("block"),
    "value" to blockARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_display_block"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerDisplayEndGatewayBeam(location: Any, color: JString? = null) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В playerDisplayEndGatewayBeam:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
if (color != null) {
    if (color.value !in setOf("DARK_PURPLE", "LIGHT_PURPLE")) {
        errorPrint("${currentScope.scope}: В функции playerDisplayEndGatewayBeam для аргумента color получено значение = \"${color.value}\", ожидалось одно из: \"DARK_PURPLE\", \"LIGHT_PURPLE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("color"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to color.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_display_end_gateway_beam"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerDisplayHologram(location: Any, text: Any) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В playerDisplayHologram:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val textARG: JString = when (text) {
                is String -> JString(text)
is JString -> text
                else -> {
                    errorPrint("${currentScope.scope}: В playerDisplayHologram:text получен тип ${text.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("text"),
    "value" to textARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_display_hologram"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerDisplayLightning(location: Any) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В playerDisplayLightning:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_display_lightning"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerDisplayParticle(particle: Any, location: Any) {
val particleARG: JParticle = when (particle) {
    is JParticle -> particle
    else -> {
        errorPrint("${currentScope.scope}: В playerDisplayParticle:particle получен тип ${particle.javaClass.kotlin.simpleName}, ожидалось: JParticle")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В playerDisplayParticle:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("particle"),
    "value" to particleARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_display_particle"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerDisplayParticleCircle(particle: Any, center: Any, radius: Any, points: Any, startAngle: Any, perpendicular: Any, angleUnit: JString? = null) {
val particleARG: JParticle = when (particle) {
    is JParticle -> particle
    else -> {
        errorPrint("${currentScope.scope}: В playerDisplayParticleCircle:particle получен тип ${particle.javaClass.kotlin.simpleName}, ожидалось: JParticle")
        throw Exception()
    }
}
val centerARG: JLocation = when (center) {
    is JLocation -> center
    else -> {
        errorPrint("${currentScope.scope}: В playerDisplayParticleCircle:center получен тип ${center.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val radiusARG: JNumber = when (radius) {
                is Number -> JNumber(radius)
is JNumber -> radius
                else -> {
                    errorPrint("${currentScope.scope}: В playerDisplayParticleCircle:radius получен тип ${radius.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val pointsARG: JNumber = when (points) {
                is Number -> JNumber(points)
is JNumber -> points
                else -> {
                    errorPrint("${currentScope.scope}: В playerDisplayParticleCircle:points получен тип ${points.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val startAngleARG: JNumber = when (startAngle) {
                is Number -> JNumber(startAngle)
is JNumber -> startAngle
                else -> {
                    errorPrint("${currentScope.scope}: В playerDisplayParticleCircle:startAngle получен тип ${startAngle.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
val perpendicularARG: JVector = when (perpendicular) {
    is JVector -> perpendicular
    else -> {
        errorPrint("${currentScope.scope}: В playerDisplayParticleCircle:perpendicular получен тип ${perpendicular.javaClass.kotlin.simpleName}, ожидалось: JVector")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("particle"),
    "value" to particleARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("center"),
    "value" to centerARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("radius"),
    "value" to radiusARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("points"),
    "value" to pointsARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("start_angle"),
    "value" to startAngleARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("perpendicular"),
    "value" to perpendicularARG.parse()
)))
if (angleUnit != null) {
    if (angleUnit.value !in setOf("DEGREES", "RADIANS")) {
        errorPrint("${currentScope.scope}: В функции playerDisplayParticleCircle для аргумента angle_unit получено значение = \"${angleUnit.value}\", ожидалось одно из: \"DEGREES\", \"RADIANS\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("angle_unit"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to angleUnit.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_display_particle_circle"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerDisplayParticleCube(particle: Any, firstCorner: Any, secondCorner: Any, spacing: Any, type: JString? = null) {
val particleARG: JParticle = when (particle) {
    is JParticle -> particle
    else -> {
        errorPrint("${currentScope.scope}: В playerDisplayParticleCube:particle получен тип ${particle.javaClass.kotlin.simpleName}, ожидалось: JParticle")
        throw Exception()
    }
}
val firstCornerARG: JLocation = when (firstCorner) {
    is JLocation -> firstCorner
    else -> {
        errorPrint("${currentScope.scope}: В playerDisplayParticleCube:firstCorner получен тип ${firstCorner.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
val secondCornerARG: JLocation = when (secondCorner) {
    is JLocation -> secondCorner
    else -> {
        errorPrint("${currentScope.scope}: В playerDisplayParticleCube:secondCorner получен тип ${secondCorner.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val spacingARG: JNumber = when (spacing) {
                is Number -> JNumber(spacing)
is JNumber -> spacing
                else -> {
                    errorPrint("${currentScope.scope}: В playerDisplayParticleCube:spacing получен тип ${spacing.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("particle"),
    "value" to particleARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("first_corner"),
    "value" to firstCornerARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("second_corner"),
    "value" to secondCornerARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("spacing"),
    "value" to spacingARG.parse()
)))
if (type != null) {
    if (type.value !in setOf("HOLLOW", "SOLID", "WIREFRAME")) {
        errorPrint("${currentScope.scope}: В функции playerDisplayParticleCube для аргумента type получено значение = \"${type.value}\", ожидалось одно из: \"HOLLOW\", \"SOLID\", \"WIREFRAME\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to type.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_display_particle_cube"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerDisplayParticleLine(particle: Any, start: Any, end: Any, divider: Any, unitOfMeasurement: JString? = null) {
val particleARG: JParticle = when (particle) {
    is JParticle -> particle
    else -> {
        errorPrint("${currentScope.scope}: В playerDisplayParticleLine:particle получен тип ${particle.javaClass.kotlin.simpleName}, ожидалось: JParticle")
        throw Exception()
    }
}
val startARG: JLocation = when (start) {
    is JLocation -> start
    else -> {
        errorPrint("${currentScope.scope}: В playerDisplayParticleLine:start получен тип ${start.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
val endARG: JLocation = when (end) {
    is JLocation -> end
    else -> {
        errorPrint("${currentScope.scope}: В playerDisplayParticleLine:end получен тип ${end.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val dividerARG: JNumber = when (divider) {
                is Number -> JNumber(divider)
is JNumber -> divider
                else -> {
                    errorPrint("${currentScope.scope}: В playerDisplayParticleLine:divider получен тип ${divider.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("particle"),
    "value" to particleARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("start"),
    "value" to startARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("end"),
    "value" to endARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("divider"),
    "value" to dividerARG.parse()
)))
if (unitOfMeasurement != null) {
    if (unitOfMeasurement.value !in setOf("DISTANCE", "POINTS")) {
        errorPrint("${currentScope.scope}: В функции playerDisplayParticleLine для аргумента unit_of_measurement получено значение = \"${unitOfMeasurement.value}\", ожидалось одно из: \"DISTANCE\", \"POINTS\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("unit_of_measurement"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to unitOfMeasurement.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_display_particle_line"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerDisplayParticleRay(particle: Any, start: Any, ray: Any, divider: Any, unitOfMeasurement: JString? = null) {
val particleARG: JParticle = when (particle) {
    is JParticle -> particle
    else -> {
        errorPrint("${currentScope.scope}: В playerDisplayParticleRay:particle получен тип ${particle.javaClass.kotlin.simpleName}, ожидалось: JParticle")
        throw Exception()
    }
}
val startARG: JLocation = when (start) {
    is JLocation -> start
    else -> {
        errorPrint("${currentScope.scope}: В playerDisplayParticleRay:start получен тип ${start.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
val rayARG: JVector = when (ray) {
    is JVector -> ray
    else -> {
        errorPrint("${currentScope.scope}: В playerDisplayParticleRay:ray получен тип ${ray.javaClass.kotlin.simpleName}, ожидалось: JVector")
        throw Exception()
    }
}
            val dividerARG: JNumber = when (divider) {
                is Number -> JNumber(divider)
is JNumber -> divider
                else -> {
                    errorPrint("${currentScope.scope}: В playerDisplayParticleRay:divider получен тип ${divider.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("particle"),
    "value" to particleARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("start"),
    "value" to startARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("ray"),
    "value" to rayARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("divider"),
    "value" to dividerARG.parse()
)))
if (unitOfMeasurement != null) {
    if (unitOfMeasurement.value !in setOf("DISTANCE", "POINTS")) {
        errorPrint("${currentScope.scope}: В функции playerDisplayParticleRay для аргумента unit_of_measurement получено значение = \"${unitOfMeasurement.value}\", ожидалось одно из: \"DISTANCE\", \"POINTS\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("unit_of_measurement"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to unitOfMeasurement.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_display_particle_ray"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerDisplayParticleSphere(particle: Any, center: Any, radius: Any, points: Any) {
val particleARG: JParticle = when (particle) {
    is JParticle -> particle
    else -> {
        errorPrint("${currentScope.scope}: В playerDisplayParticleSphere:particle получен тип ${particle.javaClass.kotlin.simpleName}, ожидалось: JParticle")
        throw Exception()
    }
}
val centerARG: JLocation = when (center) {
    is JLocation -> center
    else -> {
        errorPrint("${currentScope.scope}: В playerDisplayParticleSphere:center получен тип ${center.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val radiusARG: JNumber = when (radius) {
                is Number -> JNumber(radius)
is JNumber -> radius
                else -> {
                    errorPrint("${currentScope.scope}: В playerDisplayParticleSphere:radius получен тип ${radius.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val pointsARG: JNumber = when (points) {
                is Number -> JNumber(points)
is JNumber -> points
                else -> {
                    errorPrint("${currentScope.scope}: В playerDisplayParticleSphere:points получен тип ${points.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("particle"),
    "value" to particleARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("center"),
    "value" to centerARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("radius"),
    "value" to radiusARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("points"),
    "value" to pointsARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_display_particle_sphere"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerDisplayParticleSpiral(particle: Any, center: Any, distance: Any, radius: Any, points: Any, rotations: Any, startAngle: Any, angleUnit: JString? = null) {
val particleARG: JParticle = when (particle) {
    is JParticle -> particle
    else -> {
        errorPrint("${currentScope.scope}: В playerDisplayParticleSpiral:particle получен тип ${particle.javaClass.kotlin.simpleName}, ожидалось: JParticle")
        throw Exception()
    }
}
val centerARG: JLocation = when (center) {
    is JLocation -> center
    else -> {
        errorPrint("${currentScope.scope}: В playerDisplayParticleSpiral:center получен тип ${center.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val distanceARG: JNumber = when (distance) {
                is Number -> JNumber(distance)
is JNumber -> distance
                else -> {
                    errorPrint("${currentScope.scope}: В playerDisplayParticleSpiral:distance получен тип ${distance.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val radiusARG: JNumber = when (radius) {
                is Number -> JNumber(radius)
is JNumber -> radius
                else -> {
                    errorPrint("${currentScope.scope}: В playerDisplayParticleSpiral:radius получен тип ${radius.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val pointsARG: JNumber = when (points) {
                is Number -> JNumber(points)
is JNumber -> points
                else -> {
                    errorPrint("${currentScope.scope}: В playerDisplayParticleSpiral:points получен тип ${points.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val rotationsARG: JNumber = when (rotations) {
                is Number -> JNumber(rotations)
is JNumber -> rotations
                else -> {
                    errorPrint("${currentScope.scope}: В playerDisplayParticleSpiral:rotations получен тип ${rotations.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val startAngleARG: JNumber = when (startAngle) {
                is Number -> JNumber(startAngle)
is JNumber -> startAngle
                else -> {
                    errorPrint("${currentScope.scope}: В playerDisplayParticleSpiral:startAngle получен тип ${startAngle.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("particle"),
    "value" to particleARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("center"),
    "value" to centerARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("distance"),
    "value" to distanceARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("radius"),
    "value" to radiusARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("points"),
    "value" to pointsARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("rotations"),
    "value" to rotationsARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("start_angle"),
    "value" to startAngleARG.parse()
)))
if (angleUnit != null) {
    if (angleUnit.value !in setOf("DEGREES", "RADIANS")) {
        errorPrint("${currentScope.scope}: В функции playerDisplayParticleSpiral для аргумента angle_unit получено значение = \"${angleUnit.value}\", ожидалось одно из: \"DEGREES\", \"RADIANS\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("angle_unit"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to angleUnit.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_display_particle_spiral"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerDisplayPickUpAnimation(collectedNameOrUuid: Any, collectorNameOrUuid: Any, amount: Any) {
            val collectedNameOrUuidARG: JString = when (collectedNameOrUuid) {
                is String -> JString(collectedNameOrUuid)
is JString -> collectedNameOrUuid
                else -> {
                    errorPrint("${currentScope.scope}: В playerDisplayPickUpAnimation:collectedNameOrUuid получен тип ${collectedNameOrUuid.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val collectorNameOrUuidARG: JString = when (collectorNameOrUuid) {
                is String -> JString(collectorNameOrUuid)
is JString -> collectorNameOrUuid
                else -> {
                    errorPrint("${currentScope.scope}: В playerDisplayPickUpAnimation:collectorNameOrUuid получен тип ${collectorNameOrUuid.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val amountARG: JNumber = when (amount) {
                is Number -> JNumber(amount)
is JNumber -> amount
                else -> {
                    errorPrint("${currentScope.scope}: В playerDisplayPickUpAnimation:amount получен тип ${amount.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("collected_name_or_uuid"),
    "value" to collectedNameOrUuidARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("collector_name_or_uuid"),
    "value" to collectorNameOrUuidARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("amount"),
    "value" to amountARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_display_pick_up_animation"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerDisplaySignText(location: Any, line1: Any, line2: Any, line3: Any, line4: Any) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В playerDisplaySignText:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val line1ARG: JString = when (line1) {
                is String -> JString(line1)
is JString -> line1
                else -> {
                    errorPrint("${currentScope.scope}: В playerDisplaySignText:line1 получен тип ${line1.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val line2ARG: JString = when (line2) {
                is String -> JString(line2)
is JString -> line2
                else -> {
                    errorPrint("${currentScope.scope}: В playerDisplaySignText:line2 получен тип ${line2.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val line3ARG: JString = when (line3) {
                is String -> JString(line3)
is JString -> line3
                else -> {
                    errorPrint("${currentScope.scope}: В playerDisplaySignText:line3 получен тип ${line3.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val line4ARG: JString = when (line4) {
                is String -> JString(line4)
is JString -> line4
                else -> {
                    errorPrint("${currentScope.scope}: В playerDisplaySignText:line4 получен тип ${line4.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("line_1"),
    "value" to line1ARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("line_2"),
    "value" to line2ARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("line_3"),
    "value" to line3ARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("line_4"),
    "value" to line4ARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_display_sign_text"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerDisplayVibration(from: Any, to: Any, destinationTime: Any) {
val fromARG: JLocation = when (from) {
    is JLocation -> from
    else -> {
        errorPrint("${currentScope.scope}: В playerDisplayVibration:from получен тип ${from.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
val toARG: JLocation = when (to) {
    is JLocation -> to
    else -> {
        errorPrint("${currentScope.scope}: В playerDisplayVibration:to получен тип ${to.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val destinationTimeARG: JNumber = when (destinationTime) {
                is Number -> JNumber(destinationTime)
is JNumber -> destinationTime
                else -> {
                    errorPrint("${currentScope.scope}: В playerDisplayVibration:destinationTime получен тип ${destinationTime.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("from"),
    "value" to fromARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("to"),
    "value" to toARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("destination_time"),
    "value" to destinationTimeARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_display_vibration"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerExpandInventoryMenu(items: Any, size: Any) {
val itemsARG: JItem = when (items) {
    is JItem -> items
    else -> {
        errorPrint("${currentScope.scope}: В playerExpandInventoryMenu:items получен тип ${items.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
            val sizeARG: JNumber = when (size) {
                is Number -> JNumber(size)
is JNumber -> size
                else -> {
                    errorPrint("${currentScope.scope}: В playerExpandInventoryMenu:size получен тип ${size.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("items"),
    "value" to itemsARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("size"),
    "value" to sizeARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_expand_inventory_menu"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerFaceLocation(location: Any) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В playerFaceLocation:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_face_location"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerForceFlightMode(isFlying: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (isFlying != null) {
    if (isFlying.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции playerForceFlightMode для аргумента is_flying получено значение = \"${isFlying.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("is_flying"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to isFlying.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_force_flight_mode"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerGiveExperience(experience: Any, mode: JString? = null) {
            val experienceARG: JNumber = when (experience) {
                is Number -> JNumber(experience)
is JNumber -> experience
                else -> {
                    errorPrint("${currentScope.scope}: В playerGiveExperience:experience получен тип ${experience.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("experience"),
    "value" to experienceARG.parse()
)))
if (mode != null) {
    if (mode.value !in setOf("LEVEL", "LEVEL_PERCENTAGE", "POINTS")) {
        errorPrint("${currentScope.scope}: В функции playerGiveExperience для аргумента mode получено значение = \"${mode.value}\", ожидалось одно из: \"LEVEL\", \"LEVEL_PERCENTAGE\", \"POINTS\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to mode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_give_experience"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerGiveItems(items: Any, amount: Any) {
val itemsARG: JItem = when (items) {
    is JItem -> items
    else -> {
        errorPrint("${currentScope.scope}: В playerGiveItems:items получен тип ${items.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
            val amountARG: JNumber = when (amount) {
                is Number -> JNumber(amount)
is JNumber -> amount
                else -> {
                    errorPrint("${currentScope.scope}: В playerGiveItems:amount получен тип ${amount.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("items"),
    "value" to itemsARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("amount"),
    "value" to amountARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_give_items"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerGivePotionEffect(potions: Any, showIcon: JString? = null, overwrite: JString? = null, particleMode: JString? = null) {
val potionsARG: JPotion = when (potions) {
    is JPotion -> potions
    else -> {
        errorPrint("${currentScope.scope}: В playerGivePotionEffect:potions получен тип ${potions.javaClass.kotlin.simpleName}, ожидалось: JPotion")
        throw Exception()
    }
}



    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("potions"),
    "value" to potionsARG.parse()
)))
if (showIcon != null) {
    if (showIcon.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции playerGivePotionEffect для аргумента show_icon получено значение = \"${showIcon.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("show_icon"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to showIcon.jsonValue()
        ))
    )))
}
if (overwrite != null) {
    if (overwrite.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции playerGivePotionEffect для аргумента overwrite получено значение = \"${overwrite.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("overwrite"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to overwrite.jsonValue()
        ))
    )))
}
if (particleMode != null) {
    if (particleMode.value !in setOf("AMBIENT", "NONE", "REGULAR")) {
        errorPrint("${currentScope.scope}: В функции playerGivePotionEffect для аргумента particle_mode получено значение = \"${particleMode.value}\", ожидалось одно из: \"AMBIENT\", \"NONE\", \"REGULAR\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("particle_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to particleMode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_give_potion_effect"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerGiveRandomItem(items: Any) {
val itemsARG: JItem = when (items) {
    is JItem -> items
    else -> {
        errorPrint("${currentScope.scope}: В playerGiveRandomItem:items получен тип ${items.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("items"),
    "value" to itemsARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_give_random_item"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerHeal(heal: Any) {
            val healARG: JNumber = when (heal) {
                is Number -> JNumber(heal)
is JNumber -> heal
                else -> {
                    errorPrint("${currentScope.scope}: В playerHeal:heal получен тип ${heal.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("heal"),
    "value" to healARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_heal"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerHideEntity(nameOrUuid: Any, hide: JString? = null) {
            val nameOrUuidARG: JString = when (nameOrUuid) {
                is String -> JString(nameOrUuid)
is JString -> nameOrUuid
                else -> {
                    errorPrint("${currentScope.scope}: В playerHideEntity:nameOrUuid получен тип ${nameOrUuid.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("name_or_uuid"),
    "value" to nameOrUuidARG.parse()
)))
if (hide != null) {
    if (hide.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции playerHideEntity для аргумента hide получено значение = \"${hide.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("hide"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to hide.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_hide_entity"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerHideScoreboard() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_hide_scoreboard"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerKick() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_kick"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerLaunchForward(power: Any, increment: JString? = null, launchAxis: JString? = null) {
            val powerARG: JNumber = when (power) {
                is Number -> JNumber(power)
is JNumber -> power
                else -> {
                    errorPrint("${currentScope.scope}: В playerLaunchForward:power получен тип ${power.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }


    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("power"),
    "value" to powerARG.parse()
)))
if (increment != null) {
    if (increment.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции playerLaunchForward для аргумента increment получено значение = \"${increment.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("increment"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to increment.jsonValue()
        ))
    )))
}
if (launchAxis != null) {
    if (launchAxis.value !in setOf("YAW", "YAW_AND_PITCH")) {
        errorPrint("${currentScope.scope}: В функции playerLaunchForward для аргумента launch_axis получено значение = \"${launchAxis.value}\", ожидалось одно из: \"YAW\", \"YAW_AND_PITCH\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("launch_axis"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to launchAxis.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_launch_forward"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerLaunchProjectile(projectile: Any, location: Any, name: Any, speed: Any, inaccuracy: Any, trail: Any) {
val projectileARG: JItem = when (projectile) {
    is JItem -> projectile
    else -> {
        errorPrint("${currentScope.scope}: В playerLaunchProjectile:projectile получен тип ${projectile.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В playerLaunchProjectile:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val nameARG: JString = when (name) {
                is String -> JString(name)
is JString -> name
                else -> {
                    errorPrint("${currentScope.scope}: В playerLaunchProjectile:name получен тип ${name.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val speedARG: JNumber = when (speed) {
                is Number -> JNumber(speed)
is JNumber -> speed
                else -> {
                    errorPrint("${currentScope.scope}: В playerLaunchProjectile:speed получен тип ${speed.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val inaccuracyARG: JNumber = when (inaccuracy) {
                is Number -> JNumber(inaccuracy)
is JNumber -> inaccuracy
                else -> {
                    errorPrint("${currentScope.scope}: В playerLaunchProjectile:inaccuracy получен тип ${inaccuracy.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
val trailARG: JParticle = when (trail) {
    is JParticle -> trail
    else -> {
        errorPrint("${currentScope.scope}: В playerLaunchProjectile:trail получен тип ${trail.javaClass.kotlin.simpleName}, ожидалось: JParticle")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("projectile"),
    "value" to projectileARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("name"),
    "value" to nameARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("speed"),
    "value" to speedARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("inaccuracy"),
    "value" to inaccuracyARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("trail"),
    "value" to trailARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_launch_projectile"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerLaunchToLocation(location: Any, power: Any, increment: JString? = null) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В playerLaunchToLocation:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val powerARG: JNumber = when (power) {
                is Number -> JNumber(power)
is JNumber -> power
                else -> {
                    errorPrint("${currentScope.scope}: В playerLaunchToLocation:power получен тип ${power.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("power"),
    "value" to powerARG.parse()
)))
if (increment != null) {
    if (increment.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции playerLaunchToLocation для аргумента increment получено значение = \"${increment.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("increment"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to increment.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_launch_to_location"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerLaunchUp(power: Any, increment: JString? = null) {
            val powerARG: JNumber = when (power) {
                is Number -> JNumber(power)
is JNumber -> power
                else -> {
                    errorPrint("${currentScope.scope}: В playerLaunchUp:power получен тип ${power.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("power"),
    "value" to powerARG.parse()
)))
if (increment != null) {
    if (increment.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции playerLaunchUp для аргумента increment получено значение = \"${increment.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("increment"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to increment.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_launch_up"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerLeaveVehicle() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_leave_vehicle"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerLoadInventory() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_load_inventory"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerOpenBook(book: Any) {
val bookARG: JItem = when (book) {
    is JItem -> book
    else -> {
        errorPrint("${currentScope.scope}: В playerOpenBook:book получен тип ${book.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("book"),
    "value" to bookARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_open_book"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerOpenContainerInventory(location: Any) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В playerOpenContainerInventory:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_open_container_inventory"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerPlayAnimationAction(animation: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (animation != null) {
    if (animation.value !in setOf("DAMAGE", "JUMPSCARE", "TOTEM", "WAKE_UP")) {
        errorPrint("${currentScope.scope}: В функции playerPlayAnimationAction для аргумента animation получено значение = \"${animation.value}\", ожидалось одно из: \"DAMAGE\", \"JUMPSCARE\", \"TOTEM\", \"WAKE_UP\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("animation"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to animation.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_play_animation_action"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerPlayHurtAnimation(yaw: Any) {
            val yawARG: JNumber = when (yaw) {
                is Number -> JNumber(yaw)
is JNumber -> yaw
                else -> {
                    errorPrint("${currentScope.scope}: В playerPlayHurtAnimation:yaw получен тип ${yaw.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("yaw"),
    "value" to yawARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_play_hurt_animation"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerPlaySound(sound: Any, location: Any) {
val soundARG: JSound = when (sound) {
    is JSound -> sound
    else -> {
        errorPrint("${currentScope.scope}: В playerPlaySound:sound получен тип ${sound.javaClass.kotlin.simpleName}, ожидалось: JSound")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В playerPlaySound:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("sound"),
    "value" to soundARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_play_sound"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerPlaySoundFromEntity(nameOrUuid: Any, sounds: Any) {
            val nameOrUuidARG: JString = when (nameOrUuid) {
                is String -> JString(nameOrUuid)
is JString -> nameOrUuid
                else -> {
                    errorPrint("${currentScope.scope}: В playerPlaySoundFromEntity:nameOrUuid получен тип ${nameOrUuid.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
val soundsARG: JSound = when (sounds) {
    is JSound -> sounds
    else -> {
        errorPrint("${currentScope.scope}: В playerPlaySoundFromEntity:sounds получен тип ${sounds.javaClass.kotlin.simpleName}, ожидалось: JSound")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("name_or_uuid"),
    "value" to nameOrUuidARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("sounds"),
    "value" to soundsARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_play_sound_from_entity"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerPlaySoundSequence(sounds: Any, location: Any, delay: Any) {
val soundsARG: JSound = when (sounds) {
    is JSound -> sounds
    else -> {
        errorPrint("${currentScope.scope}: В playerPlaySoundSequence:sounds получен тип ${sounds.javaClass.kotlin.simpleName}, ожидалось: JSound")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В playerPlaySoundSequence:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val delayARG: JNumber = when (delay) {
                is Number -> JNumber(delay)
is JNumber -> delay
                else -> {
                    errorPrint("${currentScope.scope}: В playerPlaySoundSequence:delay получен тип ${delay.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("sounds"),
    "value" to soundsARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("delay"),
    "value" to delayARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_play_sound_sequence"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerRandomizedTeleport(locations: Any, keepRotation: JString? = null, keepVelocity: JString? = null, dismount: JString? = null) {
val locationsARG: JLocation = when (locations) {
    is JLocation -> locations
    else -> {
        errorPrint("${currentScope.scope}: В playerRandomizedTeleport:locations получен тип ${locations.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}



    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("locations"),
    "value" to locationsARG.parse()
)))
if (keepRotation != null) {
    if (keepRotation.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции playerRandomizedTeleport для аргумента keep_rotation получено значение = \"${keepRotation.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("keep_rotation"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to keepRotation.jsonValue()
        ))
    )))
}
if (keepVelocity != null) {
    if (keepVelocity.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции playerRandomizedTeleport для аргумента keep_velocity получено значение = \"${keepVelocity.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("keep_velocity"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to keepVelocity.jsonValue()
        ))
    )))
}
if (dismount != null) {
    if (dismount.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции playerRandomizedTeleport для аргумента dismount получено значение = \"${dismount.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("dismount"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to dismount.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_randomized_teleport"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerRedirectWorld(worldId: Any) {
            val worldIdARG: JString = when (worldId) {
                is String -> JString(worldId)
is JString -> worldId
                else -> {
                    errorPrint("${currentScope.scope}: В playerRedirectWorld:worldId получен тип ${worldId.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("world_id"),
    "value" to worldIdARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_redirect_world"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerRemoveBossBar(id: Any) {
            val idARG: JString = when (id) {
                is String -> JString(id)
is JString -> id
                else -> {
                    errorPrint("${currentScope.scope}: В playerRemoveBossBar:id получен тип ${id.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("id"),
    "value" to idARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_remove_boss_bar"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerRemoveDisguise() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_remove_disguise"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerRemoveDisplayBlocks(pos1: Any, pos2: Any) {
val pos1ARG: JLocation = when (pos1) {
    is JLocation -> pos1
    else -> {
        errorPrint("${currentScope.scope}: В playerRemoveDisplayBlocks:pos1 получен тип ${pos1.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
val pos2ARG: JLocation = when (pos2) {
    is JLocation -> pos2
    else -> {
        errorPrint("${currentScope.scope}: В playerRemoveDisplayBlocks:pos2 получен тип ${pos2.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("pos_1"),
    "value" to pos1ARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("pos_2"),
    "value" to pos2ARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_remove_display_blocks"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerRemoveInventoryMenuRow(size: Any, position: JString? = null) {
            val sizeARG: JNumber = when (size) {
                is Number -> JNumber(size)
is JNumber -> size
                else -> {
                    errorPrint("${currentScope.scope}: В playerRemoveInventoryMenuRow:size получен тип ${size.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("size"),
    "value" to sizeARG.parse()
)))
if (position != null) {
    if (position.value !in setOf("BUTTON", "TOP")) {
        errorPrint("${currentScope.scope}: В функции playerRemoveInventoryMenuRow для аргумента position получено значение = \"${position.value}\", ожидалось одно из: \"BUTTON\", \"TOP\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("position"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to position.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_remove_inventory_menu_row"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerRemoveItems(items: Any) {
val itemsARG: JItem = when (items) {
    is JItem -> items
    else -> {
        errorPrint("${currentScope.scope}: В playerRemoveItems:items получен тип ${items.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("items"),
    "value" to itemsARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_remove_items"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerRemovePose() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_remove_pose"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerRemovePotionEffect(potions: Any) {
val potionsARG: JPotion = when (potions) {
    is JPotion -> potions
    else -> {
        errorPrint("${currentScope.scope}: В playerRemovePotionEffect:potions получен тип ${potions.javaClass.kotlin.simpleName}, ожидалось: JPotion")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("potions"),
    "value" to potionsARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_remove_potion_effect"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerRemoveSelfDisguise() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_remove_self_disguise"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerRemoveSkin() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_remove_skin"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerRemoveWorldBorder() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_remove_world_border"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerReplaceItems(items: Any, replace: Any, count: Any) {
val itemsARG: JItem = when (items) {
    is JItem -> items
    else -> {
        errorPrint("${currentScope.scope}: В playerReplaceItems:items получен тип ${items.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
val replaceARG: JItem = when (replace) {
    is JItem -> replace
    else -> {
        errorPrint("${currentScope.scope}: В playerReplaceItems:replace получен тип ${replace.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
            val countARG: JNumber = when (count) {
                is Number -> JNumber(count)
is JNumber -> count
                else -> {
                    errorPrint("${currentScope.scope}: В playerReplaceItems:count получен тип ${count.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("items"),
    "value" to itemsARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("replace"),
    "value" to replaceARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("count"),
    "value" to countARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_replace_items"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerResetWeather() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_reset_weather"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerRideEntity(nameOrUuid: Any) {
            val nameOrUuidARG: JString = when (nameOrUuid) {
                is String -> JString(nameOrUuid)
is JString -> nameOrUuid
                else -> {
                    errorPrint("${currentScope.scope}: В playerRideEntity:nameOrUuid получен тип ${nameOrUuid.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("name_or_uuid"),
    "value" to nameOrUuidARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_ride_entity"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSaveInventory() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_save_inventory"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSelfDisguiseAsBlock(block: Any) {
val blockARG: JBlock = when (block) {
    is JBlock -> block
    else -> {
        errorPrint("${currentScope.scope}: В playerSelfDisguiseAsBlock:block получен тип ${block.javaClass.kotlin.simpleName}, ожидалось: JBlock")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("block"),
    "value" to blockARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_self_disguise_as_block"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSelfDisguiseAsEntity(entityType: Any) {
val entityTypeARG: JItem = when (entityType) {
    is JItem -> entityType
    else -> {
        errorPrint("${currentScope.scope}: В playerSelfDisguiseAsEntity:entityType получен тип ${entityType.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("entity_type"),
    "value" to entityTypeARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_self_disguise_as_entity"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSelfDisguiseAsItem(item: Any) {
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В playerSelfDisguiseAsItem:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_self_disguise_as_item"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSendActionBar(messages: Any, merging: JString? = null) {
            val messagesARG: JString = when (messages) {
                is String -> JString(messages)
is JString -> messages
                else -> {
                    errorPrint("${currentScope.scope}: В playerSendActionBar:messages получен тип ${messages.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("messages"),
    "value" to messagesARG.parse()
)))
if (merging != null) {
    if (merging.value !in setOf("CONCATENATION", "SPACES")) {
        errorPrint("${currentScope.scope}: В функции playerSendActionBar для аргумента merging получено значение = \"${merging.value}\", ожидалось одно из: \"CONCATENATION\", \"SPACES\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("merging"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to merging.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_send_action_bar"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSendAdvancement(icon: Any, name: Any, frame: JString? = null) {
val iconARG: JItem = when (icon) {
    is JItem -> icon
    else -> {
        errorPrint("${currentScope.scope}: В playerSendAdvancement:icon получен тип ${icon.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
            val nameARG: JString = when (name) {
                is String -> JString(name)
is JString -> name
                else -> {
                    errorPrint("${currentScope.scope}: В playerSendAdvancement:name получен тип ${name.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("icon"),
    "value" to iconARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("name"),
    "value" to nameARG.parse()
)))
if (frame != null) {
    if (frame.value !in setOf("CHALLENGE", "GOAL", "TASK")) {
        errorPrint("${currentScope.scope}: В функции playerSendAdvancement для аргумента frame получено значение = \"${frame.value}\", ожидалось одно из: \"CHALLENGE\", \"GOAL\", \"TASK\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("frame"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to frame.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_send_advancement"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSendBreakAnimation(locations: Any, stage: Any) {
val locationsARG: JLocation = when (locations) {
    is JLocation -> locations
    else -> {
        errorPrint("${currentScope.scope}: В playerSendBreakAnimation:locations получен тип ${locations.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val stageARG: JNumber = when (stage) {
                is Number -> JNumber(stage)
is JNumber -> stage
                else -> {
                    errorPrint("${currentScope.scope}: В playerSendBreakAnimation:stage получен тип ${stage.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("locations"),
    "value" to locationsARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("stage"),
    "value" to stageARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_send_break_animation"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSendDialogue(messages: Any, delay: Any) {
            val messagesARG: JString = when (messages) {
                is String -> JString(messages)
is JString -> messages
                else -> {
                    errorPrint("${currentScope.scope}: В playerSendDialogue:messages получен тип ${messages.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val delayARG: JNumber = when (delay) {
                is Number -> JNumber(delay)
is JNumber -> delay
                else -> {
                    errorPrint("${currentScope.scope}: В playerSendDialogue:delay получен тип ${delay.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("messages"),
    "value" to messagesARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("delay"),
    "value" to delayARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_send_dialogue"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSendHover(message: Any, hover: Any) {
            val messageARG: JString = when (message) {
                is String -> JString(message)
is JString -> message
                else -> {
                    errorPrint("${currentScope.scope}: В playerSendHover:message получен тип ${message.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val hoverARG: JString = when (hover) {
                is String -> JString(hover)
is JString -> hover
                else -> {
                    errorPrint("${currentScope.scope}: В playerSendHover:hover получен тип ${hover.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("message"),
    "value" to messageARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("hover"),
    "value" to hoverARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_send_hover"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerMessage(messages: Any, merging: JString? = null) {
            val messagesARG: JString = when (messages) {
                is String -> JString(messages)
is JString -> messages
                else -> {
                    errorPrint("${currentScope.scope}: В playerMessage:messages получен тип ${messages.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("messages"),
    "value" to messagesARG.parse()
)))
if (merging != null) {
    if (merging.value !in setOf("CONCATENATION", "SEPARATE_LINES", "SPACES")) {
        errorPrint("${currentScope.scope}: В функции playerMessage для аргумента merging получено значение = \"${merging.value}\", ожидалось одно из: \"CONCATENATION\", \"SEPARATE_LINES\", \"SPACES\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("merging"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to merging.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_send_message"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSendMinimessage(minimessage: Any) {
            val minimessageARG: JString = when (minimessage) {
                is String -> JString(minimessage)
is JString -> minimessage
                else -> {
                    errorPrint("${currentScope.scope}: В playerSendMinimessage:minimessage получен тип ${minimessage.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("minimessage"),
    "value" to minimessageARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_send_minimessage"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSendTitle(title: Any, subtitle: Any, fadeIn: Any, stay: Any, fadeOut: Any) {
            val titleARG: JString = when (title) {
                is String -> JString(title)
is JString -> title
                else -> {
                    errorPrint("${currentScope.scope}: В playerSendTitle:title получен тип ${title.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val subtitleARG: JString = when (subtitle) {
                is String -> JString(subtitle)
is JString -> subtitle
                else -> {
                    errorPrint("${currentScope.scope}: В playerSendTitle:subtitle получен тип ${subtitle.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val fadeInARG: JNumber = when (fadeIn) {
                is Number -> JNumber(fadeIn)
is JNumber -> fadeIn
                else -> {
                    errorPrint("${currentScope.scope}: В playerSendTitle:fadeIn получен тип ${fadeIn.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val stayARG: JNumber = when (stay) {
                is Number -> JNumber(stay)
is JNumber -> stay
                else -> {
                    errorPrint("${currentScope.scope}: В playerSendTitle:stay получен тип ${stay.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val fadeOutARG: JNumber = when (fadeOut) {
                is Number -> JNumber(fadeOut)
is JNumber -> fadeOut
                else -> {
                    errorPrint("${currentScope.scope}: В playerSendTitle:fadeOut получен тип ${fadeOut.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("title"),
    "value" to titleARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("subtitle"),
    "value" to subtitleARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("fade_in"),
    "value" to fadeInARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("stay"),
    "value" to stayARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("fade_out"),
    "value" to fadeOutARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_send_title"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetAbsorptionHealth(health: Any) {
            val healthARG: JNumber = when (health) {
                is Number -> JNumber(health)
is JNumber -> health
                else -> {
                    errorPrint("${currentScope.scope}: В playerSetAbsorptionHealth:health получен тип ${health.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("health"),
    "value" to healthARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_absorption_health"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetAirTicks(ticks: Any) {
            val ticksARG: JNumber = when (ticks) {
                is Number -> JNumber(ticks)
is JNumber -> ticks
                else -> {
                    errorPrint("${currentScope.scope}: В playerSetAirTicks:ticks получен тип ${ticks.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("ticks"),
    "value" to ticksARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_air_ticks"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetAllowFlying(allowFlying: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (allowFlying != null) {
    if (allowFlying.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции playerSetAllowFlying для аргумента allow_flying получено значение = \"${allowFlying.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("allow_flying"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to allowFlying.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_allow_flying"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetArmor(helmet: Any, chestplate: Any, leggings: Any, boots: Any) {
val helmetARG: JItem = when (helmet) {
    is JItem -> helmet
    else -> {
        errorPrint("${currentScope.scope}: В playerSetArmor:helmet получен тип ${helmet.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
val chestplateARG: JItem = when (chestplate) {
    is JItem -> chestplate
    else -> {
        errorPrint("${currentScope.scope}: В playerSetArmor:chestplate получен тип ${chestplate.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
val leggingsARG: JItem = when (leggings) {
    is JItem -> leggings
    else -> {
        errorPrint("${currentScope.scope}: В playerSetArmor:leggings получен тип ${leggings.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
val bootsARG: JItem = when (boots) {
    is JItem -> boots
    else -> {
        errorPrint("${currentScope.scope}: В playerSetArmor:boots получен тип ${boots.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("helmet"),
    "value" to helmetARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("chestplate"),
    "value" to chestplateARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("leggings"),
    "value" to leggingsARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("boots"),
    "value" to bootsARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_armor"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetArrowsInBody(amount: Any) {
            val amountARG: JNumber = when (amount) {
                is Number -> JNumber(amount)
is JNumber -> amount
                else -> {
                    errorPrint("${currentScope.scope}: В playerSetArrowsInBody:amount получен тип ${amount.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("amount"),
    "value" to amountARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_arrows_in_body"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetAttackSpeed(speed: Any) {
            val speedARG: JNumber = when (speed) {
                is Number -> JNumber(speed)
is JNumber -> speed
                else -> {
                    errorPrint("${currentScope.scope}: В playerSetAttackSpeed:speed получен тип ${speed.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("speed"),
    "value" to speedARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_attack_speed"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetAttribute(value: Any, attributeType: JString? = null) {
            val valueARG: JNumber = when (value) {
                is Number -> JNumber(value)
is JNumber -> value
                else -> {
                    errorPrint("${currentScope.scope}: В playerSetAttribute:value получен тип ${value.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("value"),
    "value" to valueARG.parse()
)))
if (attributeType != null) {
    if (attributeType.value !in setOf("GENERIC_ARMOR", "GENERIC_ARMOR_TOUGHNESS", "GENERIC_ATTACK_DAMAGE", "GENERIC_ATTACK_KNOCKBACK", "GENERIC_ATTACK_SPEED", "GENERIC_BURNING_TIME", "GENERIC_EXPLOSION_KNOCKBACK_RESISTANCE", "GENERIC_FALL_DAMAGE_MULTIPLIER", "GENERIC_FLYING_SPEED", "GENERIC_FOLLOW_RANGE", "GENERIC_GRAVITY", "GENERIC_JUMP_STRENGTH", "GENERIC_KNOCKBACK_RESISTANCE", "GENERIC_LUCK", "GENERIC_MAX_ABSORPTION", "GENERIC_MAX_HEALTH", "GENERIC_MOVEMENT_EFFICIENCY", "GENERIC_MOVEMENT_SPEED", "GENERIC_OXYGEN_BONUS", "GENERIC_SAFE_FALL_DISTANCE", "GENERIC_SCALE", "GENERIC_STEP_HEIGHT", "GENERIC_WATER_MOVEMENT_EFFICIENCY", "PLAYER_BLOCK_BREAK_SPEED", "PLAYER_BLOCK_INTERACTION_RANGE", "PLAYER_ENTITY_INTERACTION_RANGE", "PLAYER_MINING_EFFICIENCY", "PLAYER_SNEAKING_SPEED", "PLAYER_SUBMERGED_MINING_SPEED", "PLAYER_SWEEPING_DAMAGE_RATIO", "ZOMBIE_SPAWN_REINFORCEMENTS")) {
        errorPrint("${currentScope.scope}: В функции playerSetAttribute для аргумента attribute_type получено значение = \"${attributeType.value}\", ожидалось одно из: \"GENERIC_ARMOR\", \"GENERIC_ARMOR_TOUGHNESS\", \"GENERIC_ATTACK_DAMAGE\", \"GENERIC_ATTACK_KNOCKBACK\", \"GENERIC_ATTACK_SPEED\", \"GENERIC_BURNING_TIME\", \"GENERIC_EXPLOSION_KNOCKBACK_RESISTANCE\", \"GENERIC_FALL_DAMAGE_MULTIPLIER\", \"GENERIC_FLYING_SPEED\", \"GENERIC_FOLLOW_RANGE\", \"GENERIC_GRAVITY\", \"GENERIC_JUMP_STRENGTH\", \"GENERIC_KNOCKBACK_RESISTANCE\", \"GENERIC_LUCK\", \"GENERIC_MAX_ABSORPTION\", \"GENERIC_MAX_HEALTH\", \"GENERIC_MOVEMENT_EFFICIENCY\", \"GENERIC_MOVEMENT_SPEED\", \"GENERIC_OXYGEN_BONUS\", \"GENERIC_SAFE_FALL_DISTANCE\", \"GENERIC_SCALE\", \"GENERIC_STEP_HEIGHT\", \"GENERIC_WATER_MOVEMENT_EFFICIENCY\", \"PLAYER_BLOCK_BREAK_SPEED\", \"PLAYER_BLOCK_INTERACTION_RANGE\", \"PLAYER_ENTITY_INTERACTION_RANGE\", \"PLAYER_MINING_EFFICIENCY\", \"PLAYER_SNEAKING_SPEED\", \"PLAYER_SUBMERGED_MINING_SPEED\", \"PLAYER_SWEEPING_DAMAGE_RATIO\", \"ZOMBIE_SPAWN_REINFORCEMENTS\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("attribute_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to attributeType.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_attribute"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetBeeStingersInBody(amount: Any) {
            val amountARG: JNumber = when (amount) {
                is Number -> JNumber(amount)
is JNumber -> amount
                else -> {
                    errorPrint("${currentScope.scope}: В playerSetBeeStingersInBody:amount получен тип ${amount.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("amount"),
    "value" to amountARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_bee_stingers_in_body"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetBlockOpenedState(location: Any, isOpened: JString? = null) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В playerSetBlockOpenedState:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
if (isOpened != null) {
    if (isOpened.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции playerSetBlockOpenedState для аргумента is_opened получено значение = \"${isOpened.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("is_opened"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to isOpened.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_block_opened_state"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetBossBar(id: Any, title: Any, progress: Any, skyEffect: JString? = null, style: JString? = null, color: JString? = null) {
            val idARG: JString = when (id) {
                is String -> JString(id)
is JString -> id
                else -> {
                    errorPrint("${currentScope.scope}: В playerSetBossBar:id получен тип ${id.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val titleARG: JString = when (title) {
                is String -> JString(title)
is JString -> title
                else -> {
                    errorPrint("${currentScope.scope}: В playerSetBossBar:title получен тип ${title.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val progressARG: JNumber = when (progress) {
                is Number -> JNumber(progress)
is JNumber -> progress
                else -> {
                    errorPrint("${currentScope.scope}: В playerSetBossBar:progress получен тип ${progress.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }



    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("id"),
    "value" to idARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("title"),
    "value" to titleARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("progress"),
    "value" to progressARG.parse()
)))
if (skyEffect != null) {
    if (skyEffect.value !in setOf("DARK_SKY", "FOG", "FOG_AND_DARK_SKY", "NONE")) {
        errorPrint("${currentScope.scope}: В функции playerSetBossBar для аргумента sky_effect получено значение = \"${skyEffect.value}\", ожидалось одно из: \"DARK_SKY\", \"FOG\", \"FOG_AND_DARK_SKY\", \"NONE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("sky_effect"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to skyEffect.jsonValue()
        ))
    )))
}
if (style != null) {
    if (style.value !in setOf("NOTCHED_10", "NOTCHED_12", "NOTCHED_20", "NOTCHED_6", "PROGRESS")) {
        errorPrint("${currentScope.scope}: В функции playerSetBossBar для аргумента style получено значение = \"${style.value}\", ожидалось одно из: \"NOTCHED_10\", \"NOTCHED_12\", \"NOTCHED_20\", \"NOTCHED_6\", \"PROGRESS\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("style"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to style.jsonValue()
        ))
    )))
}
if (color != null) {
    if (color.value !in setOf("BLUE", "GREEN", "PINK", "PURPLE", "RED", "WHITE", "YELLOW")) {
        errorPrint("${currentScope.scope}: В функции playerSetBossBar для аргумента color получено значение = \"${color.value}\", ожидалось одно из: \"BLUE\", \"GREEN\", \"PINK\", \"PURPLE\", \"RED\", \"WHITE\", \"YELLOW\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("color"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to color.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_boss_bar"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetChatCompletions(completions: Any, settingMode: JString? = null) {
            val completionsARG: JString = when (completions) {
                is String -> JString(completions)
is JString -> completions
                else -> {
                    errorPrint("${currentScope.scope}: В playerSetChatCompletions:completions получен тип ${completions.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("completions"),
    "value" to completionsARG.parse()
)))
if (settingMode != null) {
    if (settingMode.value !in setOf("ADD", "REMOVE", "SET")) {
        errorPrint("${currentScope.scope}: В функции playerSetChatCompletions для аргумента setting_mode получено значение = \"${settingMode.value}\", ожидалось одно из: \"ADD\", \"REMOVE\", \"SET\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("setting_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to settingMode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_chat_completions"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetCollidable(collidable: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (collidable != null) {
    if (collidable.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции playerSetCollidable для аргумента collidable получено значение = \"${collidable.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("collidable"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to collidable.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_collidable"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetCompassTarget(location: Any) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В playerSetCompassTarget:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_compass_target"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetCursorItem(item: Any) {
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В playerSetCursorItem:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_cursor_item"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetDeathDrops(deathDrops: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (deathDrops != null) {
    if (deathDrops.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции playerSetDeathDrops для аргумента death_drops получено значение = \"${deathDrops.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("death_drops"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to deathDrops.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_death_drops"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetDefaultVisible(defaultVisible: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (defaultVisible != null) {
    if (defaultVisible.value !in setOf("TRUE", "FALSE")) {
        errorPrint("${currentScope.scope}: В функции playerSetDefaultVisible для аргумента default_visible получено значение = \"${defaultVisible.value}\", ожидалось одно из: \"TRUE\", \"FALSE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("default_visible"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to defaultVisible.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_default_visible"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetEnderChestContents(items: Any) {
val itemsARG: JItem = when (items) {
    is JItem -> items
    else -> {
        errorPrint("${currentScope.scope}: В playerSetEnderChestContents:items получен тип ${items.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("items"),
    "value" to itemsARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_ender_chest_contents"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetEntityGlowing(nameOrUuid: Any, color: JString? = null, glow: JString? = null) {
            val nameOrUuidARG: JString = when (nameOrUuid) {
                is String -> JString(nameOrUuid)
is JString -> nameOrUuid
                else -> {
                    errorPrint("${currentScope.scope}: В playerSetEntityGlowing:nameOrUuid получен тип ${nameOrUuid.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }


    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("name_or_uuid"),
    "value" to nameOrUuidARG.parse()
)))
if (color != null) {
    if (color.value !in setOf("AQUA", "BLACK", "BLUE", "DARK_AQUA", "DARK_BLUE", "DARK_GRAY", "DARK_GREEN", "DARK_PURPLE", "DARK_RED", "GOLD", "GRAY", "GREEN", "PURPLE", "RED", "WHITE", "YELLOW")) {
        errorPrint("${currentScope.scope}: В функции playerSetEntityGlowing для аргумента color получено значение = \"${color.value}\", ожидалось одно из: \"AQUA\", \"BLACK\", \"BLUE\", \"DARK_AQUA\", \"DARK_BLUE\", \"DARK_GRAY\", \"DARK_GREEN\", \"DARK_PURPLE\", \"DARK_RED\", \"GOLD\", \"GRAY\", \"GREEN\", \"PURPLE\", \"RED\", \"WHITE\", \"YELLOW\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("color"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to color.jsonValue()
        ))
    )))
}
if (glow != null) {
    if (glow.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции playerSetEntityGlowing для аргумента glow получено значение = \"${glow.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("glow"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to glow.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_entity_glowing"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetEquipment(item: Any, slot: JString? = null) {
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В playerSetEquipment:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
if (slot != null) {
    if (slot.value !in setOf("CHEST", "FEET", "HAND", "HEAD", "LEGS", "OFF_HAND")) {
        errorPrint("${currentScope.scope}: В функции playerSetEquipment для аргумента slot получено значение = \"${slot.value}\", ожидалось одно из: \"CHEST\", \"FEET\", \"HAND\", \"HEAD\", \"LEGS\", \"OFF_HAND\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("slot"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to slot.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_equipment"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetExhaustion(exhaustion: Any, mode: JString? = null) {
            val exhaustionARG: JNumber = when (exhaustion) {
                is Number -> JNumber(exhaustion)
is JNumber -> exhaustion
                else -> {
                    errorPrint("${currentScope.scope}: В playerSetExhaustion:exhaustion получен тип ${exhaustion.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("exhaustion"),
    "value" to exhaustionARG.parse()
)))
if (mode != null) {
    if (mode.value !in setOf("ADD", "SET")) {
        errorPrint("${currentScope.scope}: В функции playerSetExhaustion для аргумента mode получено значение = \"${mode.value}\", ожидалось одно из: \"ADD\", \"SET\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to mode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_exhaustion"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetExperience(experience: Any, mode: JString? = null) {
            val experienceARG: JNumber = when (experience) {
                is Number -> JNumber(experience)
is JNumber -> experience
                else -> {
                    errorPrint("${currentScope.scope}: В playerSetExperience:experience получен тип ${experience.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("experience"),
    "value" to experienceARG.parse()
)))
if (mode != null) {
    if (mode.value !in setOf("LEVEL", "LEVEL_PERCENTAGE", "POINTS")) {
        errorPrint("${currentScope.scope}: В функции playerSetExperience для аргумента mode получено значение = \"${mode.value}\", ожидалось одно из: \"LEVEL\", \"LEVEL_PERCENTAGE\", \"POINTS\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to mode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_experience"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetFallDistance(distance: Any) {
            val distanceARG: JNumber = when (distance) {
                is Number -> JNumber(distance)
is JNumber -> distance
                else -> {
                    errorPrint("${currentScope.scope}: В playerSetFallDistance:distance получен тип ${distance.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("distance"),
    "value" to distanceARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_fall_distance"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetFireTicks(ticks: Any) {
            val ticksARG: JNumber = when (ticks) {
                is Number -> JNumber(ticks)
is JNumber -> ticks
                else -> {
                    errorPrint("${currentScope.scope}: В playerSetFireTicks:ticks получен тип ${ticks.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("ticks"),
    "value" to ticksARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_fire_ticks"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetFlying(isFlying: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (isFlying != null) {
    if (isFlying.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции playerSetFlying для аргумента is_flying получено значение = \"${isFlying.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("is_flying"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to isFlying.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_flying"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetFogDistance(distance: Any) {
            val distanceARG: JNumber = when (distance) {
                is Number -> JNumber(distance)
is JNumber -> distance
                else -> {
                    errorPrint("${currentScope.scope}: В playerSetFogDistance:distance получен тип ${distance.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("distance"),
    "value" to distanceARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_fog_distance"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetFood(food: Any, mode: JString? = null) {
            val foodARG: JNumber = when (food) {
                is Number -> JNumber(food)
is JNumber -> food
                else -> {
                    errorPrint("${currentScope.scope}: В playerSetFood:food получен тип ${food.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("food"),
    "value" to foodARG.parse()
)))
if (mode != null) {
    if (mode.value !in setOf("ADD", "SET")) {
        errorPrint("${currentScope.scope}: В функции playerSetFood для аргумента mode получено значение = \"${mode.value}\", ожидалось одно из: \"ADD\", \"SET\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to mode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_food"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetFreezeTicks(ticks: Any, tickingLocked: JString? = null) {
            val ticksARG: JNumber = when (ticks) {
                is Number -> JNumber(ticks)
is JNumber -> ticks
                else -> {
                    errorPrint("${currentScope.scope}: В playerSetFreezeTicks:ticks получен тип ${ticks.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("ticks"),
    "value" to ticksARG.parse()
)))
if (tickingLocked != null) {
    if (tickingLocked.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции playerSetFreezeTicks для аргумента ticking_locked получено значение = \"${tickingLocked.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("ticking_locked"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to tickingLocked.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_freeze_ticks"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetGamemode(gamemode: JString? = null, flightMode: JString? = null) {


    val funValues = mutableListOf<JsonObject>()
if (gamemode != null) {
    if (gamemode.value !in setOf("ADVENTURE", "CREATIVE", "SPECTATOR", "SURVIVAL")) {
        errorPrint("${currentScope.scope}: В функции playerSetGamemode для аргумента gamemode получено значение = \"${gamemode.value}\", ожидалось одно из: \"ADVENTURE\", \"CREATIVE\", \"SPECTATOR\", \"SURVIVAL\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("gamemode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to gamemode.jsonValue()
        ))
    )))
}
if (flightMode != null) {
    if (flightMode.value !in setOf("KEEP_ORIGINAL", "RESPECT_GAMEMODE")) {
        errorPrint("${currentScope.scope}: В функции playerSetGamemode для аргумента flight_mode получено значение = \"${flightMode.value}\", ожидалось одно из: \"KEEP_ORIGINAL\", \"RESPECT_GAMEMODE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("flight_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to flightMode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_gamemode"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetGliding(isGliding: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (isGliding != null) {
    if (isGliding.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции playerSetGliding для аргумента is_gliding получено значение = \"${isGliding.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("is_gliding"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to isGliding.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_gliding"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetHealth(health: Any) {
            val healthARG: JNumber = when (health) {
                is Number -> JNumber(health)
is JNumber -> health
                else -> {
                    errorPrint("${currentScope.scope}: В playerSetHealth:health получен тип ${health.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("health"),
    "value" to healthARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_health"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetHotbarSlot(slot: Any) {
            val slotARG: JNumber = when (slot) {
                is Number -> JNumber(slot)
is JNumber -> slot
                else -> {
                    errorPrint("${currentScope.scope}: В playerSetHotbarSlot:slot получен тип ${slot.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("slot"),
    "value" to slotARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_hotbar_slot"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetInstantRespawn(instantRespawn: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (instantRespawn != null) {
    if (instantRespawn.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции playerSetInstantRespawn для аргумента instant_respawn получено значение = \"${instantRespawn.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("instant_respawn"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to instantRespawn.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_instant_respawn"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetInventoryKept(kept: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (kept != null) {
    if (kept.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции playerSetInventoryKept для аргумента kept получено значение = \"${kept.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("kept"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to kept.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_inventory_kept"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetInventoryMenuItem(item: Any, slot: Any) {
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В playerSetInventoryMenuItem:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
            val slotARG: JNumber = when (slot) {
                is Number -> JNumber(slot)
is JNumber -> slot
                else -> {
                    errorPrint("${currentScope.scope}: В playerSetInventoryMenuItem:slot получен тип ${slot.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("slot"),
    "value" to slotARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_inventory_menu_item"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetInventoryMenuName(text: Any) {
            val textARG: JString = when (text) {
                is String -> JString(text)
is JString -> text
                else -> {
                    errorPrint("${currentScope.scope}: В playerSetInventoryMenuName:text получен тип ${text.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("text"),
    "value" to textARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_inventory_menu_name"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetInvulnerabilityTicks(ticks: Any) {
            val ticksARG: JNumber = when (ticks) {
                is Number -> JNumber(ticks)
is JNumber -> ticks
                else -> {
                    errorPrint("${currentScope.scope}: В playerSetInvulnerabilityTicks:ticks получен тип ${ticks.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("ticks"),
    "value" to ticksARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_invulnerability_ticks"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetItemCooldown(cooldown: Any, item: Any, sound: Any) {
            val cooldownARG: JNumber = when (cooldown) {
                is Number -> JNumber(cooldown)
is JNumber -> cooldown
                else -> {
                    errorPrint("${currentScope.scope}: В playerSetItemCooldown:cooldown получен тип ${cooldown.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В playerSetItemCooldown:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
val soundARG: JSound = when (sound) {
    is JSound -> sound
    else -> {
        errorPrint("${currentScope.scope}: В playerSetItemCooldown:sound получен тип ${sound.javaClass.kotlin.simpleName}, ожидалось: JSound")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("cooldown"),
    "value" to cooldownARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("sound"),
    "value" to soundARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_item_cooldown"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetItems(items: Any) {
val itemsARG: JItem = when (items) {
    is JItem -> items
    else -> {
        errorPrint("${currentScope.scope}: В playerSetItems:items получен тип ${items.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("items"),
    "value" to itemsARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_items"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetMaxHealth(health: Any, heal: JString? = null) {
            val healthARG: JNumber = when (health) {
                is Number -> JNumber(health)
is JNumber -> health
                else -> {
                    errorPrint("${currentScope.scope}: В playerSetMaxHealth:health получен тип ${health.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("health"),
    "value" to healthARG.parse()
)))
if (heal != null) {
    if (heal.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции playerSetMaxHealth для аргумента heal получено значение = \"${heal.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("heal"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to heal.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_max_health"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetMovementSpeed(distance: Any, movementType: JString? = null) {
            val distanceARG: JNumber = when (distance) {
                is Number -> JNumber(distance)
is JNumber -> distance
                else -> {
                    errorPrint("${currentScope.scope}: В playerSetMovementSpeed:distance получен тип ${distance.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("distance"),
    "value" to distanceARG.parse()
)))
if (movementType != null) {
    if (movementType.value !in setOf("FLY", "WALK")) {
        errorPrint("${currentScope.scope}: В функции playerSetMovementSpeed для аргумента movement_type получено значение = \"${movementType.value}\", ожидалось одно из: \"FLY\", \"WALK\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("movement_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to movementType.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_movement_speed"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetNametagVisible(visible: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (visible != null) {
    if (visible.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции playerSetNametagVisible для аргумента visible получено значение = \"${visible.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("visible"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to visible.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_nametag_visible"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetPlayerListInfo(text: Any, merging: JString? = null, position: JString? = null) {
            val textARG: JString = when (text) {
                is String -> JString(text)
is JString -> text
                else -> {
                    errorPrint("${currentScope.scope}: В playerSetPlayerListInfo:text получен тип ${text.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }


    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("text"),
    "value" to textARG.parse()
)))
if (merging != null) {
    if (merging.value !in setOf("CONCATENATION", "SEPARATE_LINES", "SPACES")) {
        errorPrint("${currentScope.scope}: В функции playerSetPlayerListInfo для аргумента merging получено значение = \"${merging.value}\", ожидалось одно из: \"CONCATENATION\", \"SEPARATE_LINES\", \"SPACES\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("merging"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to merging.jsonValue()
        ))
    )))
}
if (position != null) {
    if (position.value !in setOf("FOOTER", "HEADER")) {
        errorPrint("${currentScope.scope}: В функции playerSetPlayerListInfo для аргумента position получено значение = \"${position.value}\", ожидалось одно из: \"FOOTER\", \"HEADER\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("position"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to position.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_player_list_info"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetPose(pose: JString? = null, locked: JString? = null) {


    val funValues = mutableListOf<JsonObject>()
if (pose != null) {
    if (pose.value !in setOf("CROAKING", "CROUCHING", "DIGGING", "DYING", "EMERGING", "FALL_FLYING", "LONG_JUMPING", "ROARING", "SITTING", "SLEEPING", "SNEAKING", "SNIFFING", "SPIN_ATTACK", "STANDING", "SWIMMING", "USING_TONGUE")) {
        errorPrint("${currentScope.scope}: В функции playerSetPose для аргумента pose получено значение = \"${pose.value}\", ожидалось одно из: \"CROAKING\", \"CROUCHING\", \"DIGGING\", \"DYING\", \"EMERGING\", \"FALL_FLYING\", \"LONG_JUMPING\", \"ROARING\", \"SITTING\", \"SLEEPING\", \"SNEAKING\", \"SNIFFING\", \"SPIN_ATTACK\", \"STANDING\", \"SWIMMING\", \"USING_TONGUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("pose"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to pose.jsonValue()
        ))
    )))
}
if (locked != null) {
    if (locked.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции playerSetPose для аргумента locked получено значение = \"${locked.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("locked"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to locked.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_pose"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetPvp(pvp: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (pvp != null) {
    if (pvp.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции playerSetPvp для аргумента pvp получено значение = \"${pvp.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("pvp"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to pvp.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_pvp"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetRainLevel(rainLevel: Any) {
            val rainLevelARG: JNumber = when (rainLevel) {
                is Number -> JNumber(rainLevel)
is JNumber -> rainLevel
                else -> {
                    errorPrint("${currentScope.scope}: В playerSetRainLevel:rainLevel получен тип ${rainLevel.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("rain_level"),
    "value" to rainLevelARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_rain_level"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetRotation(yaw: Any, pitch: Any) {
            val yawARG: JNumber = when (yaw) {
                is Number -> JNumber(yaw)
is JNumber -> yaw
                else -> {
                    errorPrint("${currentScope.scope}: В playerSetRotation:yaw получен тип ${yaw.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val pitchARG: JNumber = when (pitch) {
                is Number -> JNumber(pitch)
is JNumber -> pitch
                else -> {
                    errorPrint("${currentScope.scope}: В playerSetRotation:pitch получен тип ${pitch.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("yaw"),
    "value" to yawARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("pitch"),
    "value" to pitchARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_rotation"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetRotationByVector(vector: Any) {
val vectorARG: JVector = when (vector) {
    is JVector -> vector
    else -> {
        errorPrint("${currentScope.scope}: В playerSetRotationByVector:vector получен тип ${vector.javaClass.kotlin.simpleName}, ожидалось: JVector")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("vector"),
    "value" to vectorARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_rotation_by_vector"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetSaturation(saturation: Any, mode: JString? = null) {
            val saturationARG: JNumber = when (saturation) {
                is Number -> JNumber(saturation)
is JNumber -> saturation
                else -> {
                    errorPrint("${currentScope.scope}: В playerSetSaturation:saturation получен тип ${saturation.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("saturation"),
    "value" to saturationARG.parse()
)))
if (mode != null) {
    if (mode.value !in setOf("ADD", "SET")) {
        errorPrint("${currentScope.scope}: В функции playerSetSaturation для аргумента mode получено значение = \"${mode.value}\", ожидалось одно из: \"ADD\", \"SET\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to mode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_saturation"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetSimulationDistance(distance: Any) {
            val distanceARG: JNumber = when (distance) {
                is Number -> JNumber(distance)
is JNumber -> distance
                else -> {
                    errorPrint("${currentScope.scope}: В playerSetSimulationDistance:distance получен тип ${distance.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("distance"),
    "value" to distanceARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_simulation_distance"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetSkin(nameOrUuid: Any, serverType: JString? = null) {
            val nameOrUuidARG: JString = when (nameOrUuid) {
                is String -> JString(nameOrUuid)
is JString -> nameOrUuid
                else -> {
                    errorPrint("${currentScope.scope}: В playerSetSkin:nameOrUuid получен тип ${nameOrUuid.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("name_or_uuid"),
    "value" to nameOrUuidARG.parse()
)))
if (serverType != null) {
    if (serverType.value !in setOf("MOJANG", "SERVER")) {
        errorPrint("${currentScope.scope}: В функции playerSetSkin для аргумента server_type получено значение = \"${serverType.value}\", ожидалось одно из: \"MOJANG\", \"SERVER\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("server_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to serverType.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_skin"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetSlotItem(item: Any, slot: Any) {
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В playerSetSlotItem:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
            val slotARG: JNumber = when (slot) {
                is Number -> JNumber(slot)
is JNumber -> slot
                else -> {
                    errorPrint("${currentScope.scope}: В playerSetSlotItem:slot получен тип ${slot.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("slot"),
    "value" to slotARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_slot_item"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetSpawnPoint(spawnPoint: Any) {
val spawnPointARG: JLocation = when (spawnPoint) {
    is JLocation -> spawnPoint
    else -> {
        errorPrint("${currentScope.scope}: В playerSetSpawnPoint:spawnPoint получен тип ${spawnPoint.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("spawn_point"),
    "value" to spawnPointARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_spawn_point"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetThunderLevel(thunderLevel: Any) {
            val thunderLevelARG: JNumber = when (thunderLevel) {
                is Number -> JNumber(thunderLevel)
is JNumber -> thunderLevel
                else -> {
                    errorPrint("${currentScope.scope}: В playerSetThunderLevel:thunderLevel получен тип ${thunderLevel.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("thunder_level"),
    "value" to thunderLevelARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_thunder_level"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetTickRate(tickRate: Any) {
            val tickRateARG: JNumber = when (tickRate) {
                is Number -> JNumber(tickRate)
is JNumber -> tickRate
                else -> {
                    errorPrint("${currentScope.scope}: В playerSetTickRate:tickRate получен тип ${tickRate.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("tick_rate"),
    "value" to tickRateARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_tick_rate"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetTime(time: Any) {
            val timeARG: JNumber = when (time) {
                is Number -> JNumber(time)
is JNumber -> time
                else -> {
                    errorPrint("${currentScope.scope}: В playerSetTime:time получен тип ${time.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("time"),
    "value" to timeARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_time"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetVelocity(velocity: Any, increment: JString? = null) {
val velocityARG: JVector = when (velocity) {
    is JVector -> velocity
    else -> {
        errorPrint("${currentScope.scope}: В playerSetVelocity:velocity получен тип ${velocity.javaClass.kotlin.simpleName}, ожидалось: JVector")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("velocity"),
    "value" to velocityARG.parse()
)))
if (increment != null) {
    if (increment.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции playerSetVelocity для аргумента increment получено значение = \"${increment.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("increment"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to increment.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_velocity"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetVisualFire(visualFire: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (visualFire != null) {
    if (visualFire.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции playerSetVisualFire для аргумента visual_fire получено значение = \"${visualFire.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("visual_fire"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to visualFire.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_visual_fire"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetWeather(weatherType: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (weatherType != null) {
    if (weatherType.value !in setOf("CLEAR", "DOWNFALL")) {
        errorPrint("${currentScope.scope}: В функции playerSetWeather для аргумента weather_type получено значение = \"${weatherType.value}\", ожидалось одно из: \"CLEAR\", \"DOWNFALL\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("weather_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to weatherType.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_weather"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSetWorldBorder(center: Any, size: Any, warning: Any) {
val centerARG: JLocation = when (center) {
    is JLocation -> center
    else -> {
        errorPrint("${currentScope.scope}: В playerSetWorldBorder:center получен тип ${center.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val sizeARG: JNumber = when (size) {
                is Number -> JNumber(size)
is JNumber -> size
                else -> {
                    errorPrint("${currentScope.scope}: В playerSetWorldBorder:size получен тип ${size.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val warningARG: JNumber = when (warning) {
                is Number -> JNumber(warning)
is JNumber -> warning
                else -> {
                    errorPrint("${currentScope.scope}: В playerSetWorldBorder:warning получен тип ${warning.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("center"),
    "value" to centerARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("size"),
    "value" to sizeARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("warning"),
    "value" to warningARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_set_world_border"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerShiftWorldBorder(oldSize: Any, size: Any, time: Any) {
            val oldSizeARG: JNumber = when (oldSize) {
                is Number -> JNumber(oldSize)
is JNumber -> oldSize
                else -> {
                    errorPrint("${currentScope.scope}: В playerShiftWorldBorder:oldSize получен тип ${oldSize.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val sizeARG: JNumber = when (size) {
                is Number -> JNumber(size)
is JNumber -> size
                else -> {
                    errorPrint("${currentScope.scope}: В playerShiftWorldBorder:size получен тип ${size.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val timeARG: JNumber = when (time) {
                is Number -> JNumber(time)
is JNumber -> time
                else -> {
                    errorPrint("${currentScope.scope}: В playerShiftWorldBorder:time получен тип ${time.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("old_size"),
    "value" to oldSizeARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("size"),
    "value" to sizeARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("time"),
    "value" to timeARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_shift_world_border"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerShowDebugMarker(location: Any, name: Any, duration: Any, red: Any, green: Any, blue: Any, alpha: Any) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В playerShowDebugMarker:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val nameARG: JString = when (name) {
                is String -> JString(name)
is JString -> name
                else -> {
                    errorPrint("${currentScope.scope}: В playerShowDebugMarker:name получен тип ${name.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val durationARG: JNumber = when (duration) {
                is Number -> JNumber(duration)
is JNumber -> duration
                else -> {
                    errorPrint("${currentScope.scope}: В playerShowDebugMarker:duration получен тип ${duration.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val redARG: JNumber = when (red) {
                is Number -> JNumber(red)
is JNumber -> red
                else -> {
                    errorPrint("${currentScope.scope}: В playerShowDebugMarker:red получен тип ${red.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val greenARG: JNumber = when (green) {
                is Number -> JNumber(green)
is JNumber -> green
                else -> {
                    errorPrint("${currentScope.scope}: В playerShowDebugMarker:green получен тип ${green.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val blueARG: JNumber = when (blue) {
                is Number -> JNumber(blue)
is JNumber -> blue
                else -> {
                    errorPrint("${currentScope.scope}: В playerShowDebugMarker:blue получен тип ${blue.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val alphaARG: JNumber = when (alpha) {
                is Number -> JNumber(alpha)
is JNumber -> alpha
                else -> {
                    errorPrint("${currentScope.scope}: В playerShowDebugMarker:alpha получен тип ${alpha.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("name"),
    "value" to nameARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("duration"),
    "value" to durationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("red"),
    "value" to redARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("green"),
    "value" to greenARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("blue"),
    "value" to blueARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("alpha"),
    "value" to alphaARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_show_debug_marker"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerShowDemoScreen() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_show_demo_screen"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerShowInventoryMenu(items: Any, name: Any, inventoryType: JString? = null) {
val itemsARG: JItem = when (items) {
    is JItem -> items
    else -> {
        errorPrint("${currentScope.scope}: В playerShowInventoryMenu:items получен тип ${items.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
            val nameARG: JString = when (name) {
                is String -> JString(name)
is JString -> name
                else -> {
                    errorPrint("${currentScope.scope}: В playerShowInventoryMenu:name получен тип ${name.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("items"),
    "value" to itemsARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("name"),
    "value" to nameARG.parse()
)))
if (inventoryType != null) {
    if (inventoryType.value !in setOf("ANVIL", "BARREL", "BEACON", "BLAST_FURNACE", "BREWING", "CARTOGRAPHY", "CHEST", "COMPOSTER", "CRAFTING", "CREATIVE", "DISPENSER", "DROPPER", "ENCHANTING", "ENDER_CHEST", "FURNACE", "GRINDSTONE", "HOPPER", "LECTERN", "LOOM", "MERCHANT", "PLAYER", "SHULKER_BOX", "SMITHING", "SMOKER", "STONECUTTER", "WORKBENCH")) {
        errorPrint("${currentScope.scope}: В функции playerShowInventoryMenu для аргумента inventory_type получено значение = \"${inventoryType.value}\", ожидалось одно из: \"ANVIL\", \"BARREL\", \"BEACON\", \"BLAST_FURNACE\", \"BREWING\", \"CARTOGRAPHY\", \"CHEST\", \"COMPOSTER\", \"CRAFTING\", \"CREATIVE\", \"DISPENSER\", \"DROPPER\", \"ENCHANTING\", \"ENDER_CHEST\", \"FURNACE\", \"GRINDSTONE\", \"HOPPER\", \"LECTERN\", \"LOOM\", \"MERCHANT\", \"PLAYER\", \"SHULKER_BOX\", \"SMITHING\", \"SMOKER\", \"STONECUTTER\", \"WORKBENCH\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("inventory_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to inventoryType.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_show_inventory_menu"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerShowScoreboard(id: Any) {
            val idARG: JString = when (id) {
                is String -> JString(id)
is JString -> id
                else -> {
                    errorPrint("${currentScope.scope}: В playerShowScoreboard:id получен тип ${id.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("id"),
    "value" to idARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_show_scoreboard"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerShowWinScreen() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_show_win_screen"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSpectateTarget(nameOrUuid: Any) {
            val nameOrUuidARG: JString = when (nameOrUuid) {
                is String -> JString(nameOrUuid)
is JString -> nameOrUuid
                else -> {
                    errorPrint("${currentScope.scope}: В playerSpectateTarget:nameOrUuid получен тип ${nameOrUuid.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("name_or_uuid"),
    "value" to nameOrUuidARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_spectate_target"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerStopSound(sounds: Any) {
val soundsARG: JSound = when (sounds) {
    is JSound -> sounds
    else -> {
        errorPrint("${currentScope.scope}: В playerStopSound:sounds получен тип ${sounds.javaClass.kotlin.simpleName}, ожидалось: JSound")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("sounds"),
    "value" to soundsARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_stop_sound"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerStopSoundsBySource(source: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (source != null) {
    if (source.value !in setOf("AMBIENT", "BLOCK", "HOSTILE", "MASTER", "MUSIC", "NEUTRAL", "PLAYER", "RECORD", "VOICE", "WEATHER")) {
        errorPrint("${currentScope.scope}: В функции playerStopSoundsBySource для аргумента source получено значение = \"${source.value}\", ожидалось одно из: \"AMBIENT\", \"BLOCK\", \"HOSTILE\", \"MASTER\", \"MUSIC\", \"NEUTRAL\", \"PLAYER\", \"RECORD\", \"VOICE\", \"WEATHER\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("source"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to source.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_stop_sounds_by_source"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerSwingHand(handType: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (handType != null) {
    if (handType.value !in setOf("MAIN", "OFF")) {
        errorPrint("${currentScope.scope}: В функции playerSwingHand для аргумента hand_type получено значение = \"${handType.value}\", ожидалось одно из: \"MAIN\", \"OFF\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("hand_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to handType.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_swing_hand"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerTeleport(location: Any, keepRotation: JString? = null, keepVelocity: JString? = null, dismount: JString? = null) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В playerTeleport:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}



    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
if (keepRotation != null) {
    if (keepRotation.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции playerTeleport для аргумента keep_rotation получено значение = \"${keepRotation.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("keep_rotation"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to keepRotation.jsonValue()
        ))
    )))
}
if (keepVelocity != null) {
    if (keepVelocity.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции playerTeleport для аргумента keep_velocity получено значение = \"${keepVelocity.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("keep_velocity"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to keepVelocity.jsonValue()
        ))
    )))
}
if (dismount != null) {
    if (dismount.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции playerTeleport для аргумента dismount получено значение = \"${dismount.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("dismount"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to dismount.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_teleport"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun playerTeleportSequence(locations: Any, delay: Any) {
val locationsARG: JLocation = when (locations) {
    is JLocation -> locations
    else -> {
        errorPrint("${currentScope.scope}: В playerTeleportSequence:locations получен тип ${locations.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val delayARG: JNumber = when (delay) {
                is Number -> JNumber(delay)
is JNumber -> delay
                else -> {
                    errorPrint("${currentScope.scope}: В playerTeleportSequence:delay получен тип ${delay.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("locations"),
    "value" to locationsARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("delay"),
    "value" to delayARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("player_teleport_sequence"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun repeatAdjacently(variable: Any, origin: Any, changeRotation: JString? = null, includeSelf: JString? = null, pattern: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В repeatAdjacently:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val originARG: JLocation = when (origin) {
    is JLocation -> origin
    else -> {
        errorPrint("${currentScope.scope}: В repeatAdjacently:origin получен тип ${origin.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}



    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("origin"),
    "value" to originARG.parse()
)))
if (changeRotation != null) {
    if (changeRotation.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции repeatAdjacently для аргумента change_rotation получено значение = \"${changeRotation.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("change_rotation"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to changeRotation.jsonValue()
        ))
    )))
}
if (includeSelf != null) {
    if (includeSelf.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции repeatAdjacently для аргумента include_self получено значение = \"${includeSelf.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("include_self"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to includeSelf.jsonValue()
        ))
    )))
}
if (pattern != null) {
    if (pattern.value !in setOf("ADJACENT", "CARDINAL", "CUBE", "SQUARE")) {
        errorPrint("${currentScope.scope}: В функции repeatAdjacently для аргумента pattern получено значение = \"${pattern.value}\", ожидалось одно из: \"ADJACENT\", \"CARDINAL\", \"CUBE\", \"SQUARE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("pattern"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to pattern.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("repeat_adjacently"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun repeatForEachInList(indexVariable: Any, valueVariable: Any, list: Any) {
val indexVariableARG: Var = when (indexVariable) {
    is Var -> indexVariable
    else -> {
        errorPrint("${currentScope.scope}: В repeatForEachInList:indexVariable получен тип ${indexVariable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val valueVariableARG: Var = when (valueVariable) {
    is Var -> valueVariable
    else -> {
        errorPrint("${currentScope.scope}: В repeatForEachInList:valueVariable получен тип ${valueVariable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val listARG: JArray = when (list) {
    is JArray -> list
    else -> {
        errorPrint("${currentScope.scope}: В repeatForEachInList:list получен тип ${list.javaClass.kotlin.simpleName}, ожидалось: JArray")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("index_variable"),
    "value" to indexVariableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("value_variable"),
    "value" to valueVariableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("list"),
    "value" to listARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("repeat_for_each_in_list"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun repeatForEachMapEntry(keyVariable: Any, valueVariable: Any, map: Any) {
val keyVariableARG: Var = when (keyVariable) {
    is Var -> keyVariable
    else -> {
        errorPrint("${currentScope.scope}: В repeatForEachMapEntry:keyVariable получен тип ${keyVariable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val valueVariableARG: Var = when (valueVariable) {
    is Var -> valueVariable
    else -> {
        errorPrint("${currentScope.scope}: В repeatForEachMapEntry:valueVariable получен тип ${valueVariable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val mapARG: JMap = when (map) {
    is JMap -> map
    else -> {
        errorPrint("${currentScope.scope}: В repeatForEachMapEntry:map получен тип ${map.javaClass.kotlin.simpleName}, ожидалось: JMap")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("key_variable"),
    "value" to keyVariableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("value_variable"),
    "value" to valueVariableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("map"),
    "value" to mapARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("repeat_for_each_map_entry"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun repeatForever() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("repeat_forever"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun repeatMultiTimes(variable: Any, amount: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В repeatMultiTimes:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val amountARG: JNumber = when (amount) {
                is Number -> JNumber(amount)
is JNumber -> amount
                else -> {
                    errorPrint("${currentScope.scope}: В repeatMultiTimes:amount получен тип ${amount.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("amount"),
    "value" to amountARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("repeat_multi_times"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun repeatOnCircle(variable: Any, center: Any, radius: Any, circlePoints: Any, perpendicularToPlane: Any, startAngle: Any, angleUnit: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В repeatOnCircle:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val centerARG: JLocation = when (center) {
    is JLocation -> center
    else -> {
        errorPrint("${currentScope.scope}: В repeatOnCircle:center получен тип ${center.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val radiusARG: JNumber = when (radius) {
                is Number -> JNumber(radius)
is JNumber -> radius
                else -> {
                    errorPrint("${currentScope.scope}: В repeatOnCircle:radius получен тип ${radius.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val circlePointsARG: JNumber = when (circlePoints) {
                is Number -> JNumber(circlePoints)
is JNumber -> circlePoints
                else -> {
                    errorPrint("${currentScope.scope}: В repeatOnCircle:circlePoints получен тип ${circlePoints.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
val perpendicularToPlaneARG: JVector = when (perpendicularToPlane) {
    is JVector -> perpendicularToPlane
    else -> {
        errorPrint("${currentScope.scope}: В repeatOnCircle:perpendicularToPlane получен тип ${perpendicularToPlane.javaClass.kotlin.simpleName}, ожидалось: JVector")
        throw Exception()
    }
}
            val startAngleARG: JNumber = when (startAngle) {
                is Number -> JNumber(startAngle)
is JNumber -> startAngle
                else -> {
                    errorPrint("${currentScope.scope}: В repeatOnCircle:startAngle получен тип ${startAngle.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("center"),
    "value" to centerARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("radius"),
    "value" to radiusARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("circle_points"),
    "value" to circlePointsARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("perpendicular_to_plane"),
    "value" to perpendicularToPlaneARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("start_angle"),
    "value" to startAngleARG.parse()
)))
if (angleUnit != null) {
    if (angleUnit.value !in setOf("DEGREES", "RADIANS")) {
        errorPrint("${currentScope.scope}: В функции repeatOnCircle для аргумента angle_unit получено значение = \"${angleUnit.value}\", ожидалось одно из: \"DEGREES\", \"RADIANS\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("angle_unit"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to angleUnit.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("repeat_on_circle"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun repeatOnGrid(variable: Any, start: Any, end: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В repeatOnGrid:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val startARG: JLocation = when (start) {
    is JLocation -> start
    else -> {
        errorPrint("${currentScope.scope}: В repeatOnGrid:start получен тип ${start.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
val endARG: JLocation = when (end) {
    is JLocation -> end
    else -> {
        errorPrint("${currentScope.scope}: В repeatOnGrid:end получен тип ${end.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("start"),
    "value" to startARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("end"),
    "value" to endARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("repeat_on_grid"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun repeatOnPath(variable: Any, step: Any, locations: Any, rotation: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В repeatOnPath:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val stepARG: JNumber = when (step) {
                is Number -> JNumber(step)
is JNumber -> step
                else -> {
                    errorPrint("${currentScope.scope}: В repeatOnPath:step получен тип ${step.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
val locationsARG: JLocation = when (locations) {
    is JLocation -> locations
    else -> {
        errorPrint("${currentScope.scope}: В repeatOnPath:locations получен тип ${locations.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("step"),
    "value" to stepARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("locations"),
    "value" to locationsARG.parse()
)))
if (rotation != null) {
    if (rotation.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции repeatOnPath для аргумента rotation получено значение = \"${rotation.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("rotation"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to rotation.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("repeat_on_path"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun repeatOnRange(variable: Any, start: Any, end: Any, interval: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В repeatOnRange:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val startARG: JNumber = when (start) {
                is Number -> JNumber(start)
is JNumber -> start
                else -> {
                    errorPrint("${currentScope.scope}: В repeatOnRange:start получен тип ${start.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val endARG: JNumber = when (end) {
                is Number -> JNumber(end)
is JNumber -> end
                else -> {
                    errorPrint("${currentScope.scope}: В repeatOnRange:end получен тип ${end.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val intervalARG: JNumber = when (interval) {
                is Number -> JNumber(interval)
is JNumber -> interval
                else -> {
                    errorPrint("${currentScope.scope}: В repeatOnRange:interval получен тип ${interval.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("start"),
    "value" to startARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("end"),
    "value" to endARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("interval"),
    "value" to intervalARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("repeat_on_range"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun repeatOnSphere(variable: Any, center: Any, radius: Any, points: Any, rotateLocation: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В repeatOnSphere:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val centerARG: JLocation = when (center) {
    is JLocation -> center
    else -> {
        errorPrint("${currentScope.scope}: В repeatOnSphere:center получен тип ${center.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val radiusARG: JNumber = when (radius) {
                is Number -> JNumber(radius)
is JNumber -> radius
                else -> {
                    errorPrint("${currentScope.scope}: В repeatOnSphere:radius получен тип ${radius.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val pointsARG: JNumber = when (points) {
                is Number -> JNumber(points)
is JNumber -> points
                else -> {
                    errorPrint("${currentScope.scope}: В repeatOnSphere:points получен тип ${points.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("center"),
    "value" to centerARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("radius"),
    "value" to radiusARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("points"),
    "value" to pointsARG.parse()
)))
if (rotateLocation != null) {
    if (rotateLocation.value !in setOf("INWARDS", "NO_CHANGES", "OUTWARDS")) {
        errorPrint("${currentScope.scope}: В функции repeatOnSphere для аргумента rotate_location получено значение = \"${rotateLocation.value}\", ожидалось одно из: \"INWARDS\", \"NO_CHANGES\", \"OUTWARDS\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("rotate_location"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to rotateLocation.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("repeat_on_sphere"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun repeatWhile() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("repeat_while"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun selectAddAllEntities() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("select_add_all_entities"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun selectAddAllMobs() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("select_add_all_mobs"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun selectAddAllPlayers() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("select_add_all_players"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun selectAddEntityByConditional() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("select_add_entity_by_conditional"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun selectAddEntityByName(nameOrUuid: Any) {
            val nameOrUuidARG: JString = when (nameOrUuid) {
                is String -> JString(nameOrUuid)
is JString -> nameOrUuid
                else -> {
                    errorPrint("${currentScope.scope}: В selectAddEntityByName:nameOrUuid получен тип ${nameOrUuid.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("name_or_uuid"),
    "value" to nameOrUuidARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("select_add_entity_by_name"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun selectAddEventTarget(selectionType: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (selectionType != null) {
    if (selectionType.value !in setOf("DAMAGER", "DEFAULT", "KILLER", "PROJECTILE", "SHOOTER", "VICTIM")) {
        errorPrint("${currentScope.scope}: В функции selectAddEventTarget для аргумента selection_type получено значение = \"${selectionType.value}\", ожидалось одно из: \"DAMAGER\", \"DEFAULT\", \"KILLER\", \"PROJECTILE\", \"SHOOTER\", \"VICTIM\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("selection_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to selectionType.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("select_add_event_target"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun selectAddLastEntity() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("select_add_last_entity"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun selectAddLastMob() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("select_add_last_mob"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun selectAddMobByName(nameOrUuid: Any) {
            val nameOrUuidARG: JString = when (nameOrUuid) {
                is String -> JString(nameOrUuid)
is JString -> nameOrUuid
                else -> {
                    errorPrint("${currentScope.scope}: В selectAddMobByName:nameOrUuid получен тип ${nameOrUuid.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("name_or_uuid"),
    "value" to nameOrUuidARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("select_add_mob_by_name"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun selectAddPlayerByConditional() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("select_add_player_by_conditional"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun selectAddPlayerByName(nameOrUuid: Any) {
            val nameOrUuidARG: JString = when (nameOrUuid) {
                is String -> JString(nameOrUuid)
is JString -> nameOrUuid
                else -> {
                    errorPrint("${currentScope.scope}: В selectAddPlayerByName:nameOrUuid получен тип ${nameOrUuid.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("name_or_uuid"),
    "value" to nameOrUuidARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("select_add_player_by_name"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun selectAddRandomEntity() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("select_add_random_entity"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun selectAddRandomMob() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("select_add_random_mob"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun selectAddRandomPlayer() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("select_add_random_player"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun selectAllEntities() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("select_all_entities"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun selectAllMobs() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("select_all_mobs"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun selectAllPlayers() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("select_all_players"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun selectEntityByConditional() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("select_entity_by_conditional"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun selectEntityByName(nameOrUuid: Any) {
            val nameOrUuidARG: JString = when (nameOrUuid) {
                is String -> JString(nameOrUuid)
is JString -> nameOrUuid
                else -> {
                    errorPrint("${currentScope.scope}: В selectEntityByName:nameOrUuid получен тип ${nameOrUuid.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("name_or_uuid"),
    "value" to nameOrUuidARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("select_entity_by_name"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun selectEventTarget(selectionType: JString? = null) {

    val funValues = mutableListOf<JsonObject>()
if (selectionType != null) {
    if (selectionType.value !in setOf("DAMAGER", "DEFAULT", "KILLER", "PROJECTILE", "SHOOTER", "VICTIM")) {
        errorPrint("${currentScope.scope}: В функции selectEventTarget для аргумента selection_type получено значение = \"${selectionType.value}\", ожидалось одно из: \"DAMAGER\", \"DEFAULT\", \"KILLER\", \"PROJECTILE\", \"SHOOTER\", \"VICTIM\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("selection_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to selectionType.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("select_event_target"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun selectFilterByConditional() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("select_filter_by_conditional"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun selectFilterByDistance(location: Any, selectionSize: Any, ignoreYAxis: JString? = null, compareMode: JString? = null) {
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В selectFilterByDistance:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val selectionSizeARG: JNumber = when (selectionSize) {
                is Number -> JNumber(selectionSize)
is JNumber -> selectionSize
                else -> {
                    errorPrint("${currentScope.scope}: В selectFilterByDistance:selectionSize получен тип ${selectionSize.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }


    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("selection_size"),
    "value" to selectionSizeARG.parse()
)))
if (ignoreYAxis != null) {
    if (ignoreYAxis.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции selectFilterByDistance для аргумента ignore_y_axis получено значение = \"${ignoreYAxis.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("ignore_y_axis"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to ignoreYAxis.jsonValue()
        ))
    )))
}
if (compareMode != null) {
    if (compareMode.value !in setOf("FARTHEST", "NEAREST")) {
        errorPrint("${currentScope.scope}: В функции selectFilterByDistance для аргумента compare_mode получено значение = \"${compareMode.value}\", ожидалось одно из: \"FARTHEST\", \"NEAREST\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("compare_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to compareMode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("select_filter_by_distance"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun selectFilterByRaycast(variable: Any, origin: Any, maxDistance: Any, raySize: Any, selectionSize: Any, considerBlocks: JString? = null, ignorePassableBlocks: JString? = null, fluidCollisionMode: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В selectFilterByRaycast:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val originARG: JLocation = when (origin) {
    is JLocation -> origin
    else -> {
        errorPrint("${currentScope.scope}: В selectFilterByRaycast:origin получен тип ${origin.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val maxDistanceARG: JNumber = when (maxDistance) {
                is Number -> JNumber(maxDistance)
is JNumber -> maxDistance
                else -> {
                    errorPrint("${currentScope.scope}: В selectFilterByRaycast:maxDistance получен тип ${maxDistance.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val raySizeARG: JNumber = when (raySize) {
                is Number -> JNumber(raySize)
is JNumber -> raySize
                else -> {
                    errorPrint("${currentScope.scope}: В selectFilterByRaycast:raySize получен тип ${raySize.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val selectionSizeARG: JNumber = when (selectionSize) {
                is Number -> JNumber(selectionSize)
is JNumber -> selectionSize
                else -> {
                    errorPrint("${currentScope.scope}: В selectFilterByRaycast:selectionSize получен тип ${selectionSize.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }



    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("origin"),
    "value" to originARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("max_distance"),
    "value" to maxDistanceARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("ray_size"),
    "value" to raySizeARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("selection_size"),
    "value" to selectionSizeARG.parse()
)))
if (considerBlocks != null) {
    if (considerBlocks.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции selectFilterByRaycast для аргумента consider_blocks получено значение = \"${considerBlocks.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("consider_blocks"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to considerBlocks.jsonValue()
        ))
    )))
}
if (ignorePassableBlocks != null) {
    if (ignorePassableBlocks.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции selectFilterByRaycast для аргумента ignore_passable_blocks получено значение = \"${ignorePassableBlocks.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("ignore_passable_blocks"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to ignorePassableBlocks.jsonValue()
        ))
    )))
}
if (fluidCollisionMode != null) {
    if (fluidCollisionMode.value !in setOf("ALWAYS", "NEVER", "SOURCE_ONLY")) {
        errorPrint("${currentScope.scope}: В функции selectFilterByRaycast для аргумента fluid_collision_mode получено значение = \"${fluidCollisionMode.value}\", ожидалось одно из: \"ALWAYS\", \"NEVER\", \"SOURCE_ONLY\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("fluid_collision_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to fluidCollisionMode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("select_filter_by_raycast"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun selectFilterRandomly(size: Any) {
            val sizeARG: JNumber = when (size) {
                is Number -> JNumber(size)
is JNumber -> size
                else -> {
                    errorPrint("${currentScope.scope}: В selectFilterRandomly:size получен тип ${size.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("size"),
    "value" to sizeARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("select_filter_randomly"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun selectInvert() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("select_invert"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun selectLastEntity() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("select_last_entity"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun selectLastMob() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("select_last_mob"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun selectMobByName(nameOrUuid: Any) {
            val nameOrUuidARG: JString = when (nameOrUuid) {
                is String -> JString(nameOrUuid)
is JString -> nameOrUuid
                else -> {
                    errorPrint("${currentScope.scope}: В selectMobByName:nameOrUuid получен тип ${nameOrUuid.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("name_or_uuid"),
    "value" to nameOrUuidARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("select_mob_by_name"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun selectPlayerByConditional() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("select_player_by_conditional"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun selectPlayerByName(nameOrUuid: Any) {
            val nameOrUuidARG: JString = when (nameOrUuid) {
                is String -> JString(nameOrUuid)
is JString -> nameOrUuid
                else -> {
                    errorPrint("${currentScope.scope}: В selectPlayerByName:nameOrUuid получен тип ${nameOrUuid.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("name_or_uuid"),
    "value" to nameOrUuidARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("select_player_by_name"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun selectRandomEntity() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("select_random_entity"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun selectRandomMob() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("select_random_mob"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun selectRandomPlayer() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("select_random_player"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun selectReset() {

    val funValues = mutableListOf<JsonObject>()

    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("select_reset"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableAbsolute(variable: Any, number: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableAbsolute:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val numberARG: JNumber = when (number) {
                is Number -> JNumber(number)
is JNumber -> number
                else -> {
                    errorPrint("${currentScope.scope}: В variableAbsolute:number получен тип ${number.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("number"),
    "value" to numberARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_absolute"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableAdd(variable: Any, value: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableAdd:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val valueARG: JNumber = when (value) {
                is Number -> JNumber(value)
is JNumber -> value
                else -> {
                    errorPrint("${currentScope.scope}: В variableAdd:value получен тип ${value.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("value"),
    "value" to valueARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_add"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableAddItemEnchantment(variable: Any, item: Any, enchantment: Any, level: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableAddItemEnchantment:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В variableAddItemEnchantment:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
            val enchantmentARG: JString = when (enchantment) {
                is String -> JString(enchantment)
is JString -> enchantment
                else -> {
                    errorPrint("${currentScope.scope}: В variableAddItemEnchantment:enchantment получен тип ${enchantment.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val levelARG: JNumber = when (level) {
                is Number -> JNumber(level)
is JNumber -> level
                else -> {
                    errorPrint("${currentScope.scope}: В variableAddItemEnchantment:level получен тип ${level.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("enchantment"),
    "value" to enchantmentARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("level"),
    "value" to levelARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_add_item_enchantment"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableAddItemPotionEffects(variable: Any, potions: Any, item: Any, overwrite: JString? = null, showIcon: JString? = null, particleMode: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableAddItemPotionEffects:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val potionsARG: JPotion = when (potions) {
    is JPotion -> potions
    else -> {
        errorPrint("${currentScope.scope}: В variableAddItemPotionEffects:potions получен тип ${potions.javaClass.kotlin.simpleName}, ожидалось: JPotion")
        throw Exception()
    }
}
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В variableAddItemPotionEffects:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}



    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("potions"),
    "value" to potionsARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
if (overwrite != null) {
    if (overwrite.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции variableAddItemPotionEffects для аргумента overwrite получено значение = \"${overwrite.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("overwrite"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to overwrite.jsonValue()
        ))
    )))
}
if (showIcon != null) {
    if (showIcon.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции variableAddItemPotionEffects для аргумента show_icon получено значение = \"${showIcon.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("show_icon"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to showIcon.jsonValue()
        ))
    )))
}
if (particleMode != null) {
    if (particleMode.value !in setOf("AMBIENT", "NONE", "REGULAR")) {
        errorPrint("${currentScope.scope}: В функции variableAddItemPotionEffects для аргумента particle_mode получено значение = \"${particleMode.value}\", ожидалось одно из: \"AMBIENT\", \"NONE\", \"REGULAR\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("particle_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to particleMode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_add_item_potion_effects"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableAddVectors(variable: Any, vectors: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableAddVectors:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val vectorsARG: JVector = when (vectors) {
    is JVector -> vectors
    else -> {
        errorPrint("${currentScope.scope}: В variableAddVectors:vectors получен тип ${vectors.javaClass.kotlin.simpleName}, ожидалось: JVector")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("vectors"),
    "value" to vectorsARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_add_vectors"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableAlignLocation(variable: Any, location: Any, rotationMode: JString? = null, coordinatesMode: JString? = null, alignMode: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableAlignLocation:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В variableAlignLocation:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}



    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
if (rotationMode != null) {
    if (rotationMode.value !in setOf("KEEP", "REMOVE")) {
        errorPrint("${currentScope.scope}: В функции variableAlignLocation для аргумента rotation_mode получено значение = \"${rotationMode.value}\", ожидалось одно из: \"KEEP\", \"REMOVE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("rotation_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to rotationMode.jsonValue()
        ))
    )))
}
if (coordinatesMode != null) {
    if (coordinatesMode.value !in setOf("ALL", "X_Z", "Y")) {
        errorPrint("${currentScope.scope}: В функции variableAlignLocation для аргумента coordinates_mode получено значение = \"${coordinatesMode.value}\", ожидалось одно из: \"ALL\", \"X_Z\", \"Y\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("coordinates_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to coordinatesMode.jsonValue()
        ))
    )))
}
if (alignMode != null) {
    if (alignMode.value !in setOf("BLOCK_CENTER", "CORNER")) {
        errorPrint("${currentScope.scope}: В функции variableAlignLocation для аргумента align_mode получено значение = \"${alignMode.value}\", ожидалось одно из: \"BLOCK_CENTER\", \"CORNER\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("align_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to alignMode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_align_location"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableAlignToAxisVector(variable: Any, vector: Any, normalize: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableAlignToAxisVector:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val vectorARG: JVector = when (vector) {
    is JVector -> vector
    else -> {
        errorPrint("${currentScope.scope}: В variableAlignToAxisVector:vector получен тип ${vector.javaClass.kotlin.simpleName}, ожидалось: JVector")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("vector"),
    "value" to vectorARG.parse()
)))
if (normalize != null) {
    if (normalize.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции variableAlignToAxisVector для аргумента normalize получено значение = \"${normalize.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("normalize"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to normalize.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_align_to_axis_vector"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableAppendComponent(variable: Any, components: Any, merging: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableAppendComponent:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val componentsARG: JString = when (components) {
                is String -> JString(components)
is JString -> components
                else -> {
                    errorPrint("${currentScope.scope}: В variableAppendComponent:components получен тип ${components.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("components"),
    "value" to componentsARG.parse()
)))
if (merging != null) {
    if (merging.value !in setOf("CONCATENATION", "SEPARATE_LINES", "SPACES")) {
        errorPrint("${currentScope.scope}: В функции variableAppendComponent для аргумента merging получено значение = \"${merging.value}\", ожидалось одно из: \"CONCATENATION\", \"SEPARATE_LINES\", \"SPACES\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("merging"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to merging.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_append_component"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableAppendList(variable: Any, list1: Any, list2: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableAppendList:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val list1ARG: JArray = when (list1) {
    is JArray -> list1
    else -> {
        errorPrint("${currentScope.scope}: В variableAppendList:list1 получен тип ${list1.javaClass.kotlin.simpleName}, ожидалось: JArray")
        throw Exception()
    }
}
val list2ARG: JArray = when (list2) {
    is JArray -> list2
    else -> {
        errorPrint("${currentScope.scope}: В variableAppendList:list2 получен тип ${list2.javaClass.kotlin.simpleName}, ожидалось: JArray")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("list_1"),
    "value" to list1ARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("list_2"),
    "value" to list2ARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_append_list"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableAppendMap(variable: Any, map: Any, otherMap: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableAppendMap:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val mapARG: JMap = when (map) {
    is JMap -> map
    else -> {
        errorPrint("${currentScope.scope}: В variableAppendMap:map получен тип ${map.javaClass.kotlin.simpleName}, ожидалось: JMap")
        throw Exception()
    }
}
val otherMapARG: JMap = when (otherMap) {
    is JMap -> otherMap
    else -> {
        errorPrint("${currentScope.scope}: В variableAppendMap:otherMap получен тип ${otherMap.javaClass.kotlin.simpleName}, ожидалось: JMap")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("map"),
    "value" to mapARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("other_map"),
    "value" to otherMapARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_append_map"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableAppendValue(variable: Any, values: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableAppendValue:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val valuesARG: JAny = when (values) {
    is JAny -> values
    else -> {
        errorPrint("${currentScope.scope}: В variableAppendValue:values получен тип ${values.javaClass.kotlin.simpleName}, ожидалось: JAny")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("values"),
    "value" to valuesARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_append_value"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableAverage(variable: Any, value: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableAverage:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val valueARG: JNumber = when (value) {
                is Number -> JNumber(value)
is JNumber -> value
                else -> {
                    errorPrint("${currentScope.scope}: В variableAverage:value получен тип ${value.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("value"),
    "value" to valueARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_average"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableBitwiseOperation(variable: Any, operand1: Any, operand2: Any, operator: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableBitwiseOperation:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val operand1ARG: JNumber = when (operand1) {
                is Number -> JNumber(operand1)
is JNumber -> operand1
                else -> {
                    errorPrint("${currentScope.scope}: В variableBitwiseOperation:operand1 получен тип ${operand1.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val operand2ARG: JNumber = when (operand2) {
                is Number -> JNumber(operand2)
is JNumber -> operand2
                else -> {
                    errorPrint("${currentScope.scope}: В variableBitwiseOperation:operand2 получен тип ${operand2.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("operand1"),
    "value" to operand1ARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("operand2"),
    "value" to operand2ARG.parse()
)))
if (operator != null) {
    if (operator.value !in setOf("AND", "LEFT_SHIFT", "NOT", "OR", "RIGHT_SHIFT", "UNSIGNED_RIGHT_SHIFT", "XOR")) {
        errorPrint("${currentScope.scope}: В функции variableBitwiseOperation для аргумента operator получено значение = \"${operator.value}\", ожидалось одно из: \"AND\", \"LEFT_SHIFT\", \"NOT\", \"OR\", \"RIGHT_SHIFT\", \"UNSIGNED_RIGHT_SHIFT\", \"XOR\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("operator"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to operator.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_bitwise_operation"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableCenterLocation(variable: Any, locations: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableCenterLocation:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val locationsARG: JLocation = when (locations) {
    is JLocation -> locations
    else -> {
        errorPrint("${currentScope.scope}: В variableCenterLocation:locations получен тип ${locations.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("locations"),
    "value" to locationsARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_center_location"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableChangeComponentParsing(variable: Any, component: Any, parsing: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableChangeComponentParsing:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val componentARG: JString = when (component) {
                is String -> JString(component)
is JString -> component
                else -> {
                    errorPrint("${currentScope.scope}: В variableChangeComponentParsing:component получен тип ${component.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("component"),
    "value" to componentARG.parse()
)))
if (parsing != null) {
    if (parsing.value !in setOf("JSON", "LEGACY", "MINIMESSAGE", "PLAIN")) {
        errorPrint("${currentScope.scope}: В функции variableChangeComponentParsing для аргумента parsing получено значение = \"${parsing.value}\", ожидалось одно из: \"JSON\", \"LEGACY\", \"MINIMESSAGE\", \"PLAIN\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("parsing"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to parsing.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_change_component_parsing"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableCharToNumber(variable: Any, char: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableCharToNumber:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val charARG: JString = when (char) {
                is String -> JString(char)
is JString -> char
                else -> {
                    errorPrint("${currentScope.scope}: В variableCharToNumber:char получен тип ${char.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("char"),
    "value" to charARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_char_to_number"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableClamp(variable: Any, number: Any, min: Any, max: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableClamp:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val numberARG: JNumber = when (number) {
                is Number -> JNumber(number)
is JNumber -> number
                else -> {
                    errorPrint("${currentScope.scope}: В variableClamp:number получен тип ${number.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val minARG: JNumber = when (min) {
                is Number -> JNumber(min)
is JNumber -> min
                else -> {
                    errorPrint("${currentScope.scope}: В variableClamp:min получен тип ${min.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val maxARG: JNumber = when (max) {
                is Number -> JNumber(max)
is JNumber -> max
                else -> {
                    errorPrint("${currentScope.scope}: В variableClamp:max получен тип ${max.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("number"),
    "value" to numberARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("min"),
    "value" to minARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("max"),
    "value" to maxARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_clamp"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableClearColorCodes(variable: Any, text: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableClearColorCodes:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val textARG: JString = when (text) {
                is String -> JString(text)
is JString -> text
                else -> {
                    errorPrint("${currentScope.scope}: В variableClearColorCodes:text получен тип ${text.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("text"),
    "value" to textARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_clear_color_codes"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableClearMap(map: Any) {
val mapARG: Var = when (map) {
    is Var -> map
    else -> {
        errorPrint("${currentScope.scope}: В variableClearMap:map получен тип ${map.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("map"),
    "value" to mapARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_clear_map"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableCompactComponent(variable: Any, component: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableCompactComponent:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val componentARG: JString = when (component) {
                is String -> JString(component)
is JString -> component
                else -> {
                    errorPrint("${currentScope.scope}: В variableCompactComponent:component получен тип ${component.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("component"),
    "value" to componentARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_compact_component"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableComponentOfChildren(variable: Any, components: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableComponentOfChildren:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val componentsARG: JString = when (components) {
                is String -> JString(components)
is JString -> components
                else -> {
                    errorPrint("${currentScope.scope}: В variableComponentOfChildren:components получен тип ${components.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("components"),
    "value" to componentsARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_component_of_children"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableConvertNumberToText(variable: Any, number: Any, radix: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableConvertNumberToText:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val numberARG: JNumber = when (number) {
                is Number -> JNumber(number)
is JNumber -> number
                else -> {
                    errorPrint("${currentScope.scope}: В variableConvertNumberToText:number получен тип ${number.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val radixARG: JNumber = when (radix) {
                is Number -> JNumber(radix)
is JNumber -> radix
                else -> {
                    errorPrint("${currentScope.scope}: В variableConvertNumberToText:radix получен тип ${radix.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("number"),
    "value" to numberARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("radix"),
    "value" to radixARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_convert_number_to_text"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableConvertTextToNumber(variable: Any, text: Any, radix: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableConvertTextToNumber:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val textARG: JString = when (text) {
                is String -> JString(text)
is JString -> text
                else -> {
                    errorPrint("${currentScope.scope}: В variableConvertTextToNumber:text получен тип ${text.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val radixARG: JNumber = when (radix) {
                is Number -> JNumber(radix)
is JNumber -> radix
                else -> {
                    errorPrint("${currentScope.scope}: В variableConvertTextToNumber:radix получен тип ${radix.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("text"),
    "value" to textARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("radix"),
    "value" to radixARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_convert_text_to_number"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableCosine(variable: Any, number: Any, variant: JString? = null, input: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableCosine:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val numberARG: JNumber = when (number) {
                is Number -> JNumber(number)
is JNumber -> number
                else -> {
                    errorPrint("${currentScope.scope}: В variableCosine:number получен тип ${number.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }


    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("number"),
    "value" to numberARG.parse()
)))
if (variant != null) {
    if (variant.value !in setOf("ARCCOSINE", "COSINE", "HYPERBOLIC_COSINE")) {
        errorPrint("${currentScope.scope}: В функции variableCosine для аргумента variant получено значение = \"${variant.value}\", ожидалось одно из: \"ARCCOSINE\", \"COSINE\", \"HYPERBOLIC_COSINE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("variant"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to variant.jsonValue()
        ))
    )))
}
if (input != null) {
    if (input.value !in setOf("DEGREES", "RADIANS")) {
        errorPrint("${currentScope.scope}: В функции variableCosine для аргумента input получено значение = \"${input.value}\", ожидалось одно из: \"DEGREES\", \"RADIANS\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("input"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to input.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_cosine"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableCotangent(variable: Any, number: Any, variant: JString? = null, input: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableCotangent:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val numberARG: JNumber = when (number) {
                is Number -> JNumber(number)
is JNumber -> number
                else -> {
                    errorPrint("${currentScope.scope}: В variableCotangent:number получен тип ${number.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }


    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("number"),
    "value" to numberARG.parse()
)))
if (variant != null) {
    if (variant.value !in setOf("ARCCOTANGENT", "COTANGENT", "HYPERBOLIC_COTANGENT")) {
        errorPrint("${currentScope.scope}: В функции variableCotangent для аргумента variant получено значение = \"${variant.value}\", ожидалось одно из: \"ARCCOTANGENT\", \"COTANGENT\", \"HYPERBOLIC_COTANGENT\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("variant"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to variant.jsonValue()
        ))
    )))
}
if (input != null) {
    if (input.value !in setOf("DEGREES", "RADIANS")) {
        errorPrint("${currentScope.scope}: В функции variableCotangent для аргумента input получено значение = \"${input.value}\", ожидалось одно из: \"DEGREES\", \"RADIANS\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("input"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to input.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_cotangent"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableCreateKeybindComponent(variable: Any, key: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableCreateKeybindComponent:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val keyARG: JString = when (key) {
                is String -> JString(key)
is JString -> key
                else -> {
                    errorPrint("${currentScope.scope}: В variableCreateKeybindComponent:key получен тип ${key.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("key"),
    "value" to keyARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_create_keybind_component"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableCreateList(variable: Any, values: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableCreateList:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val valuesARG: JAny = when (values) {
    is JAny -> values
    else -> {
        errorPrint("${currentScope.scope}: В variableCreateList:values получен тип ${values.javaClass.kotlin.simpleName}, ожидалось: JAny")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("values"),
    "value" to valuesARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_create_list"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableCreateMap(variable: Any, keys: Any, values: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableCreateMap:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val keysARG: JArray = when (keys) {
    is JArray -> keys
    else -> {
        errorPrint("${currentScope.scope}: В variableCreateMap:keys получен тип ${keys.javaClass.kotlin.simpleName}, ожидалось: JArray")
        throw Exception()
    }
}
val valuesARG: JArray = when (values) {
    is JArray -> values
    else -> {
        errorPrint("${currentScope.scope}: В variableCreateMap:values получен тип ${values.javaClass.kotlin.simpleName}, ожидалось: JArray")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("keys"),
    "value" to keysARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("values"),
    "value" to valuesARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_create_map"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableCreateMapFromValues(variable: Any, keys: Any, values: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableCreateMapFromValues:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val keysARG: JAny = when (keys) {
    is JAny -> keys
    else -> {
        errorPrint("${currentScope.scope}: В variableCreateMapFromValues:keys получен тип ${keys.javaClass.kotlin.simpleName}, ожидалось: JAny")
        throw Exception()
    }
}
val valuesARG: JAny = when (values) {
    is JAny -> values
    else -> {
        errorPrint("${currentScope.scope}: В variableCreateMapFromValues:values получен тип ${values.javaClass.kotlin.simpleName}, ожидалось: JAny")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("keys"),
    "value" to keysARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("values"),
    "value" to valuesARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_create_map_from_values"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableCreateTranslatableComponent(variable: Any, key: Any, args: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableCreateTranslatableComponent:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val keyARG: JString = when (key) {
                is String -> JString(key)
is JString -> key
                else -> {
                    errorPrint("${currentScope.scope}: В variableCreateTranslatableComponent:key получен тип ${key.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val argsARG: JString = when (args) {
                is String -> JString(args)
is JString -> args
                else -> {
                    errorPrint("${currentScope.scope}: В variableCreateTranslatableComponent:args получен тип ${args.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("key"),
    "value" to keyARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("args"),
    "value" to argsARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_create_translatable_component"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableDecrement(variable: Any, number: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableDecrement:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val numberARG: JNumber = when (number) {
                is Number -> JNumber(number)
is JNumber -> number
                else -> {
                    errorPrint("${currentScope.scope}: В variableDecrement:number получен тип ${number.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("number"),
    "value" to numberARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_decrement"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableDivide(variable: Any, value: Any, divisionMode: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableDivide:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val valueARG: JNumber = when (value) {
                is Number -> JNumber(value)
is JNumber -> value
                else -> {
                    errorPrint("${currentScope.scope}: В variableDivide:value получен тип ${value.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("value"),
    "value" to valueARG.parse()
)))
if (divisionMode != null) {
    if (divisionMode.value !in setOf("CEIL", "DEFAULT", "FLOOR", "ROUND_TO_INT")) {
        errorPrint("${currentScope.scope}: В функции variableDivide для аргумента division_mode получено значение = \"${divisionMode.value}\", ожидалось одно из: \"CEIL\", \"DEFAULT\", \"FLOOR\", \"ROUND_TO_INT\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("division_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to divisionMode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_divide"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableDivideVector(variable: Any, vector: Any, divider: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableDivideVector:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val vectorARG: JVector = when (vector) {
    is JVector -> vector
    else -> {
        errorPrint("${currentScope.scope}: В variableDivideVector:vector получен тип ${vector.javaClass.kotlin.simpleName}, ожидалось: JVector")
        throw Exception()
    }
}
val dividerARG: JVector = when (divider) {
    is JVector -> divider
    else -> {
        errorPrint("${currentScope.scope}: В variableDivideVector:divider получен тип ${divider.javaClass.kotlin.simpleName}, ожидалось: JVector")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("vector"),
    "value" to vectorARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("divider"),
    "value" to dividerARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_divide_vector"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableFaceLocation(variable: Any, location: Any, target: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableFaceLocation:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В variableFaceLocation:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
val targetARG: JLocation = when (target) {
    is JLocation -> target
    else -> {
        errorPrint("${currentScope.scope}: В variableFaceLocation:target получен тип ${target.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("target"),
    "value" to targetARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_face_location"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableFlattenList(variable: Any, list: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableFlattenList:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val listARG: JArray = when (list) {
    is JArray -> list
    else -> {
        errorPrint("${currentScope.scope}: В variableFlattenList:list получен тип ${list.javaClass.kotlin.simpleName}, ожидалось: JArray")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("list"),
    "value" to listARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_flatten_list"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableFormatTimestamp(variable: Any, time: Any, pattern: Any, zoneId: Any, locale: Any, format: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableFormatTimestamp:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val timeARG: JNumber = when (time) {
                is Number -> JNumber(time)
is JNumber -> time
                else -> {
                    errorPrint("${currentScope.scope}: В variableFormatTimestamp:time получен тип ${time.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val patternARG: JString = when (pattern) {
                is String -> JString(pattern)
is JString -> pattern
                else -> {
                    errorPrint("${currentScope.scope}: В variableFormatTimestamp:pattern получен тип ${pattern.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val zoneIdARG: JString = when (zoneId) {
                is String -> JString(zoneId)
is JString -> zoneId
                else -> {
                    errorPrint("${currentScope.scope}: В variableFormatTimestamp:zoneId получен тип ${zoneId.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val localeARG: JString = when (locale) {
                is String -> JString(locale)
is JString -> locale
                else -> {
                    errorPrint("${currentScope.scope}: В variableFormatTimestamp:locale получен тип ${locale.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("time"),
    "value" to timeARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("pattern"),
    "value" to patternARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("zone_id"),
    "value" to zoneIdARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("locale"),
    "value" to localeARG.parse()
)))
if (format != null) {
    if (format.value !in setOf("CUSTOM", "DD_MM_YYYY", "DD_MM_YYYY_HH_MM_S", "EEEE", "EEE_D_MMMM", "EEE_MMMM_D", "HH_MM_SS", "H_H_M_M_S_S", "H_MM_A", "S_S", "YYYY_MM_DD", "YYYY_MM_DD_HH_MM_S")) {
        errorPrint("${currentScope.scope}: В функции variableFormatTimestamp для аргумента format получено значение = \"${format.value}\", ожидалось одно из: \"CUSTOM\", \"DD_MM_YYYY\", \"DD_MM_YYYY_HH_MM_S\", \"EEEE\", \"EEE_D_MMMM\", \"EEE_MMMM_D\", \"HH_MM_SS\", \"H_H_M_M_S_S\", \"H_MM_A\", \"S_S\", \"YYYY_MM_DD\", \"YYYY_MM_DD_HH_MM_S\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("format"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to format.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_format_timestamp"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGaussianDistribution(variable: Any, deviant: Any, mean: Any, distribution: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGaussianDistribution:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val deviantARG: JNumber = when (deviant) {
                is Number -> JNumber(deviant)
is JNumber -> deviant
                else -> {
                    errorPrint("${currentScope.scope}: В variableGaussianDistribution:deviant получен тип ${deviant.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val meanARG: JNumber = when (mean) {
                is Number -> JNumber(mean)
is JNumber -> mean
                else -> {
                    errorPrint("${currentScope.scope}: В variableGaussianDistribution:mean получен тип ${mean.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("deviant"),
    "value" to deviantARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("mean"),
    "value" to meanARG.parse()
)))
if (distribution != null) {
    if (distribution.value !in setOf("FOLDER_NORMAL", "NORMAL")) {
        errorPrint("${currentScope.scope}: В функции variableGaussianDistribution для аргумента distribution получено значение = \"${distribution.value}\", ожидалось одно из: \"FOLDER_NORMAL\", \"NORMAL\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("distribution"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to distribution.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_gaussian_distribution"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetAllBlockData(variable: Any, location: Any, hideUnspecified: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetAllBlockData:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В variableGetAllBlockData:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
if (hideUnspecified != null) {
    if (hideUnspecified.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции variableGetAllBlockData для аргумента hide_unspecified получено значение = \"${hideUnspecified.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("hide_unspecified"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to hideUnspecified.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_all_block_data"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetAllCoordinates(x: Any, y: Any, z: Any, yaw: Any, pitch: Any, location: Any) {
val xARG: Var = when (x) {
    is Var -> x
    else -> {
        errorPrint("${currentScope.scope}: В variableGetAllCoordinates:x получен тип ${x.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val yARG: Var = when (y) {
    is Var -> y
    else -> {
        errorPrint("${currentScope.scope}: В variableGetAllCoordinates:y получен тип ${y.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val zARG: Var = when (z) {
    is Var -> z
    else -> {
        errorPrint("${currentScope.scope}: В variableGetAllCoordinates:z получен тип ${z.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val yawARG: Var = when (yaw) {
    is Var -> yaw
    else -> {
        errorPrint("${currentScope.scope}: В variableGetAllCoordinates:yaw получен тип ${yaw.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val pitchARG: Var = when (pitch) {
    is Var -> pitch
    else -> {
        errorPrint("${currentScope.scope}: В variableGetAllCoordinates:pitch получен тип ${pitch.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В variableGetAllCoordinates:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("x"),
    "value" to xARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("y"),
    "value" to yARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("z"),
    "value" to zARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("yaw"),
    "value" to yawARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("pitch"),
    "value" to pitchARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_all_coordinates"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetAngleBetweenVectors(variable: Any, vector1: Any, vector2: Any, angleUnits: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetAngleBetweenVectors:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val vector1ARG: JVector = when (vector1) {
    is JVector -> vector1
    else -> {
        errorPrint("${currentScope.scope}: В variableGetAngleBetweenVectors:vector1 получен тип ${vector1.javaClass.kotlin.simpleName}, ожидалось: JVector")
        throw Exception()
    }
}
val vector2ARG: JVector = when (vector2) {
    is JVector -> vector2
    else -> {
        errorPrint("${currentScope.scope}: В variableGetAngleBetweenVectors:vector2 получен тип ${vector2.javaClass.kotlin.simpleName}, ожидалось: JVector")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("vector_1"),
    "value" to vector1ARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("vector_2"),
    "value" to vector2ARG.parse()
)))
if (angleUnits != null) {
    if (angleUnits.value !in setOf("DEGREES", "RADIANS")) {
        errorPrint("${currentScope.scope}: В функции variableGetAngleBetweenVectors для аргумента angle_units получено значение = \"${angleUnits.value}\", ожидалось одно из: \"DEGREES\", \"RADIANS\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("angle_units"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to angleUnits.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_angle_between_vectors"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetBlockCustomTag(variable: Any, location: Any, tagName: Any, tagValue: Any, defaultValue: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetBlockCustomTag:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В variableGetBlockCustomTag:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val tagNameARG: JString = when (tagName) {
                is String -> JString(tagName)
is JString -> tagName
                else -> {
                    errorPrint("${currentScope.scope}: В variableGetBlockCustomTag:tagName получен тип ${tagName.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val tagValueARG: JString = when (tagValue) {
                is String -> JString(tagValue)
is JString -> tagValue
                else -> {
                    errorPrint("${currentScope.scope}: В variableGetBlockCustomTag:tagValue получен тип ${tagValue.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
val defaultValueARG: JAny = when (defaultValue) {
    is JAny -> defaultValue
    else -> {
        errorPrint("${currentScope.scope}: В variableGetBlockCustomTag:defaultValue получен тип ${defaultValue.javaClass.kotlin.simpleName}, ожидалось: JAny")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("tag_name"),
    "value" to tagNameARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("tag_value"),
    "value" to tagValueARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("default_value"),
    "value" to defaultValueARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_block_custom_tag"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetBlockData(variable: Any, location: Any, tagName: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetBlockData:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В variableGetBlockData:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val tagNameARG: JString = when (tagName) {
                is String -> JString(tagName)
is JString -> tagName
                else -> {
                    errorPrint("${currentScope.scope}: В variableGetBlockData:tagName получен тип ${tagName.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("tag_name"),
    "value" to tagNameARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_block_data"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetBlockGrowth(variable: Any, location: Any, growthUnit: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetBlockGrowth:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В variableGetBlockGrowth:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
if (growthUnit != null) {
    if (growthUnit.value !in setOf("GROWTH_PERCENTAGE", "GROWTH_STAGE")) {
        errorPrint("${currentScope.scope}: В функции variableGetBlockGrowth для аргумента growth_unit получено значение = \"${growthUnit.value}\", ожидалось одно из: \"GROWTH_PERCENTAGE\", \"GROWTH_STAGE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("growth_unit"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to growthUnit.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_block_growth"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetBlockMaterial(variable: Any, location: Any, valueType: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetBlockMaterial:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В variableGetBlockMaterial:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
if (valueType != null) {
    if (valueType.value !in setOf("ID", "ID_WITH_DATA", "ITEM", "NAME")) {
        errorPrint("${currentScope.scope}: В функции variableGetBlockMaterial для аргумента value_type получено значение = \"${valueType.value}\", ожидалось одно из: \"ID\", \"ID_WITH_DATA\", \"ITEM\", \"NAME\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("value_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to valueType.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_block_material"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetBlockMaterialProperty(variable: Any, block: Any, property: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetBlockMaterialProperty:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val blockARG: JBlock = when (block) {
    is JBlock -> block
    else -> {
        errorPrint("${currentScope.scope}: В variableGetBlockMaterialProperty:block получен тип ${block.javaClass.kotlin.simpleName}, ожидалось: JBlock")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("block"),
    "value" to blockARG.parse()
)))
if (property != null) {
    if (property.value !in setOf("BLAST_RESISTANCE", "HARDNESS", "SLIPPERINESS")) {
        errorPrint("${currentScope.scope}: В функции variableGetBlockMaterialProperty для аргумента property получено значение = \"${property.value}\", ожидалось одно из: \"BLAST_RESISTANCE\", \"HARDNESS\", \"SLIPPERINESS\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("property"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to property.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_block_material_property"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetBlockPower(variable: Any, location: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetBlockPower:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В variableGetBlockPower:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_block_power"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetBookText(variable: Any, book: Any, page: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetBookText:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val bookARG: JItem = when (book) {
    is JItem -> book
    else -> {
        errorPrint("${currentScope.scope}: В variableGetBookText:book получен тип ${book.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
            val pageARG: JNumber = when (page) {
                is Number -> JNumber(page)
is JNumber -> page
                else -> {
                    errorPrint("${currentScope.scope}: В variableGetBookText:page получен тип ${page.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("book"),
    "value" to bookARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("page"),
    "value" to pageARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_book_text"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetBrushableBlockItem(variable: Any, location: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetBrushableBlockItem:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В variableGetBrushableBlockItem:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_brushable_block_item"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetBundleItems(variable: Any, bundle: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetBundleItems:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val bundleARG: JItem = when (bundle) {
    is JItem -> bundle
    else -> {
        errorPrint("${currentScope.scope}: В variableGetBundleItems:bundle получен тип ${bundle.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("bundle"),
    "value" to bundleARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_bundle_items"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetCharAt(variable: Any, text: Any, index: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetCharAt:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val textARG: JString = when (text) {
                is String -> JString(text)
is JString -> text
                else -> {
                    errorPrint("${currentScope.scope}: В variableGetCharAt:text получен тип ${text.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val indexARG: JNumber = when (index) {
                is Number -> JNumber(index)
is JNumber -> index
                else -> {
                    errorPrint("${currentScope.scope}: В variableGetCharAt:index получен тип ${index.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("text"),
    "value" to textARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("index"),
    "value" to indexARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_char_at"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetColorChannels(variable: Any, color: Any, colorChannels: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetColorChannels:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val colorARG: JString = when (color) {
                is String -> JString(color)
is JString -> color
                else -> {
                    errorPrint("${currentScope.scope}: В variableGetColorChannels:color получен тип ${color.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("color"),
    "value" to colorARG.parse()
)))
if (colorChannels != null) {
    if (colorChannels.value !in setOf("HSB", "HSL", "RGB")) {
        errorPrint("${currentScope.scope}: В функции variableGetColorChannels для аргумента color_channels получено значение = \"${colorChannels.value}\", ожидалось одно из: \"HSB\", \"HSL\", \"RGB\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("color_channels"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to colorChannels.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_color_channels"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetCompassLodestone(variable: Any, item: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetCompassLodestone:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В variableGetCompassLodestone:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_compass_lodestone"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetComponentChildren(variable: Any, component: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetComponentChildren:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val componentARG: JString = when (component) {
                is String -> JString(component)
is JString -> component
                else -> {
                    errorPrint("${currentScope.scope}: В variableGetComponentChildren:component получен тип ${component.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("component"),
    "value" to componentARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_component_children"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetComponentDecorations(variable: Any, component: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetComponentDecorations:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val componentARG: JString = when (component) {
                is String -> JString(component)
is JString -> component
                else -> {
                    errorPrint("${currentScope.scope}: В variableGetComponentDecorations:component получен тип ${component.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("component"),
    "value" to componentARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_component_decorations"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetComponentHexColor(variable: Any, component: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetComponentHexColor:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val componentARG: JString = when (component) {
                is String -> JString(component)
is JString -> component
                else -> {
                    errorPrint("${currentScope.scope}: В variableGetComponentHexColor:component получен тип ${component.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("component"),
    "value" to componentARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_component_hex_color"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetComponentParsing(variable: Any, component: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetComponentParsing:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val componentARG: JString = when (component) {
                is String -> JString(component)
is JString -> component
                else -> {
                    errorPrint("${currentScope.scope}: В variableGetComponentParsing:component получен тип ${component.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("component"),
    "value" to componentARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_component_parsing"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetContainerContents(variable: Any, location: Any, ignoreEmptySlots: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetContainerContents:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В variableGetContainerContents:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
if (ignoreEmptySlots != null) {
    if (ignoreEmptySlots.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции variableGetContainerContents для аргумента ignore_empty_slots получено значение = \"${ignoreEmptySlots.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("ignore_empty_slots"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to ignoreEmptySlots.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_container_contents"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetContainerLock(variable: Any, location: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetContainerLock:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В variableGetContainerLock:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_container_lock"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetContainerName(variable: Any, location: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetContainerName:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В variableGetContainerName:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_container_name"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetCoordinate(variable: Any, location: Any, type: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetCoordinate:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В variableGetCoordinate:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
if (type != null) {
    if (type.value !in setOf("PITCH", "X", "Y", "YAW", "Z")) {
        errorPrint("${currentScope.scope}: В функции variableGetCoordinate для аргумента type получено значение = \"${type.value}\", ожидалось одно из: \"PITCH\", \"X\", \"Y\", \"YAW\", \"Z\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to type.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_coordinate"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetDecoratePotSherd(variable: Any, location: Any, side: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetDecoratePotSherd:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В variableGetDecoratePotSherd:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
if (side != null) {
    if (side.value !in setOf("BACK", "FRONT", "LEFT", "RIGHT")) {
        errorPrint("${currentScope.scope}: В функции variableGetDecoratePotSherd для аргумента side получено значение = \"${side.value}\", ожидалось одно из: \"BACK\", \"FRONT\", \"LEFT\", \"RIGHT\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("side"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to side.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_decorate_pot_sherd"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetIndexOfSubtext(variable: Any, text: Any, subtext: Any, startIndex: Any, searchMode: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetIndexOfSubtext:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val textARG: JString = when (text) {
                is String -> JString(text)
is JString -> text
                else -> {
                    errorPrint("${currentScope.scope}: В variableGetIndexOfSubtext:text получен тип ${text.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val subtextARG: JString = when (subtext) {
                is String -> JString(subtext)
is JString -> subtext
                else -> {
                    errorPrint("${currentScope.scope}: В variableGetIndexOfSubtext:subtext получен тип ${subtext.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val startIndexARG: JNumber = when (startIndex) {
                is Number -> JNumber(startIndex)
is JNumber -> startIndex
                else -> {
                    errorPrint("${currentScope.scope}: В variableGetIndexOfSubtext:startIndex получен тип ${startIndex.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("text"),
    "value" to textARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("subtext"),
    "value" to subtextARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("start_index"),
    "value" to startIndexARG.parse()
)))
if (searchMode != null) {
    if (searchMode.value !in setOf("FIRST", "LAST")) {
        errorPrint("${currentScope.scope}: В функции variableGetIndexOfSubtext для аргумента search_mode получено значение = \"${searchMode.value}\", ожидалось одно из: \"FIRST\", \"LAST\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("search_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to searchMode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_index_of_subtext"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetItemAmount(variable: Any, item: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetItemAmount:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В variableGetItemAmount:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_item_amount"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetItemAttribute(variable: Any, item: Any, name: Any, attribute: JString? = null, slot: JString? = null, operation: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetItemAttribute:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В variableGetItemAttribute:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
            val nameARG: JString = when (name) {
                is String -> JString(name)
is JString -> name
                else -> {
                    errorPrint("${currentScope.scope}: В variableGetItemAttribute:name получен тип ${name.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }



    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("name"),
    "value" to nameARG.parse()
)))
if (attribute != null) {
    if (attribute.value !in setOf("ARMOR", "ARMOR_TOUGHNESS", "ATTACK_DAMAGE", "ATTACK_KNOCKBACK", "ATTACK_SPEED", "FLYING_SPEED", "FOLLOW_RANGE", "GENERIC_ARMOR", "GENERIC_ARMOR_TOUGHNESS", "GENERIC_ATTACK_DAMAGE", "GENERIC_ATTACK_KNOCKBACK", "GENERIC_ATTACK_SPEED", "GENERIC_BURNING_TIME", "GENERIC_EXPLOSION_KNOCKBACK_RESISTANCE", "GENERIC_FALL_DAMAGE_MULTIPLIER", "GENERIC_FLYING_SPEED", "GENERIC_FOLLOW_RANGE", "GENERIC_GRAVITY", "GENERIC_JUMP_STRENGTH", "GENERIC_KNOCKBACK_RESISTANCE", "GENERIC_LUCK", "GENERIC_MAX_ABSORPTION", "GENERIC_MAX_HEALTH", "GENERIC_MOVEMENT_EFFICIENCY", "GENERIC_MOVEMENT_SPEED", "GENERIC_OXYGEN_BONUS", "GENERIC_SAFE_FALL_DISTANCE", "GENERIC_SCALE", "GENERIC_STEP_HEIGHT", "GENERIC_WATER_MOVEMENT_EFFICIENCY", "HORSE_JUMP_STRENGTH", "KNOCKBACK_RESISTANCE", "LUCK", "MAX_ABSORPTION", "MAX_HEALTH", "MOVEMENT_SPEED", "PLAYER_BLOCK_BREAK_SPEED", "PLAYER_BLOCK_INTERACTION_RANGE", "PLAYER_ENTITY_INTERACTION_RANGE", "PLAYER_MINING_EFFICIENCY", "PLAYER_SNEAKING_SPEED", "PLAYER_SUBMERGED_MINING_SPEED", "PLAYER_SWEEPING_DAMAGE_RATIO", "ZOMBIE_SPAWN_REINFORCEMENTS")) {
        errorPrint("${currentScope.scope}: В функции variableGetItemAttribute для аргумента attribute получено значение = \"${attribute.value}\", ожидалось одно из: \"ARMOR\", \"ARMOR_TOUGHNESS\", \"ATTACK_DAMAGE\", \"ATTACK_KNOCKBACK\", \"ATTACK_SPEED\", \"FLYING_SPEED\", \"FOLLOW_RANGE\", \"GENERIC_ARMOR\", \"GENERIC_ARMOR_TOUGHNESS\", \"GENERIC_ATTACK_DAMAGE\", \"GENERIC_ATTACK_KNOCKBACK\", \"GENERIC_ATTACK_SPEED\", \"GENERIC_BURNING_TIME\", \"GENERIC_EXPLOSION_KNOCKBACK_RESISTANCE\", \"GENERIC_FALL_DAMAGE_MULTIPLIER\", \"GENERIC_FLYING_SPEED\", \"GENERIC_FOLLOW_RANGE\", \"GENERIC_GRAVITY\", \"GENERIC_JUMP_STRENGTH\", \"GENERIC_KNOCKBACK_RESISTANCE\", \"GENERIC_LUCK\", \"GENERIC_MAX_ABSORPTION\", \"GENERIC_MAX_HEALTH\", \"GENERIC_MOVEMENT_EFFICIENCY\", \"GENERIC_MOVEMENT_SPEED\", \"GENERIC_OXYGEN_BONUS\", \"GENERIC_SAFE_FALL_DISTANCE\", \"GENERIC_SCALE\", \"GENERIC_STEP_HEIGHT\", \"GENERIC_WATER_MOVEMENT_EFFICIENCY\", \"HORSE_JUMP_STRENGTH\", \"KNOCKBACK_RESISTANCE\", \"LUCK\", \"MAX_ABSORPTION\", \"MAX_HEALTH\", \"MOVEMENT_SPEED\", \"PLAYER_BLOCK_BREAK_SPEED\", \"PLAYER_BLOCK_INTERACTION_RANGE\", \"PLAYER_ENTITY_INTERACTION_RANGE\", \"PLAYER_MINING_EFFICIENCY\", \"PLAYER_SNEAKING_SPEED\", \"PLAYER_SUBMERGED_MINING_SPEED\", \"PLAYER_SWEEPING_DAMAGE_RATIO\", \"ZOMBIE_SPAWN_REINFORCEMENTS\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("attribute"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to attribute.jsonValue()
        ))
    )))
}
if (slot != null) {
    if (slot.value !in setOf("ALL", "ARMOR", "BODY", "BOOTS", "CHEST", "HAND", "HEAD", "LEGGINGS", "MAIN_HAND", "OFF_HAND")) {
        errorPrint("${currentScope.scope}: В функции variableGetItemAttribute для аргумента slot получено значение = \"${slot.value}\", ожидалось одно из: \"ALL\", \"ARMOR\", \"BODY\", \"BOOTS\", \"CHEST\", \"HAND\", \"HEAD\", \"LEGGINGS\", \"MAIN_HAND\", \"OFF_HAND\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("slot"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to slot.jsonValue()
        ))
    )))
}
if (operation != null) {
    if (operation.value !in setOf("ADD_NUMBER", "ADD_SCALAR", "MULTIPLY_SCALAR_1")) {
        errorPrint("${currentScope.scope}: В функции variableGetItemAttribute для аргумента operation получено значение = \"${operation.value}\", ожидалось одно из: \"ADD_NUMBER\", \"ADD_SCALAR\", \"MULTIPLY_SCALAR_1\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("operation"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to operation.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_item_attribute"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetItemColor(variable: Any, item: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetItemColor:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В variableGetItemColor:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_item_color"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetItemCustomModelData(variable: Any, item: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetItemCustomModelData:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В variableGetItemCustomModelData:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_item_custom_model_data"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetItemCustomTag(variable: Any, item: Any, tagName: Any, defaultValue: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetItemCustomTag:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В variableGetItemCustomTag:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
            val tagNameARG: JString = when (tagName) {
                is String -> JString(tagName)
is JString -> tagName
                else -> {
                    errorPrint("${currentScope.scope}: В variableGetItemCustomTag:tagName получен тип ${tagName.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
val defaultValueARG: JAny = when (defaultValue) {
    is JAny -> defaultValue
    else -> {
        errorPrint("${currentScope.scope}: В variableGetItemCustomTag:defaultValue получен тип ${defaultValue.javaClass.kotlin.simpleName}, ожидалось: JAny")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("tag_name"),
    "value" to tagNameARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("default_value"),
    "value" to defaultValueARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_item_custom_tag"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetItemCustomTags(variable: Any, item: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetItemCustomTags:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В variableGetItemCustomTags:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_item_custom_tags"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetItemDestroyableBlocks(variable: Any, item: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetItemDestroyableBlocks:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В variableGetItemDestroyableBlocks:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_item_destroyable_blocks"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetItemDurability(variable: Any, item: Any, durabilityType: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetItemDurability:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В variableGetItemDurability:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
if (durabilityType != null) {
    if (durabilityType.value !in setOf("DAMAGE", "DAMAGE_PERCENTAGE", "MAXIMUM", "REMAINING", "REMAINING_PERCENTAGE")) {
        errorPrint("${currentScope.scope}: В функции variableGetItemDurability для аргумента durability_type получено значение = \"${durabilityType.value}\", ожидалось одно из: \"DAMAGE\", \"DAMAGE_PERCENTAGE\", \"MAXIMUM\", \"REMAINING\", \"REMAINING_PERCENTAGE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("durability_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to durabilityType.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_item_durability"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetItemEnchantments(variable: Any, item: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetItemEnchantments:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В variableGetItemEnchantments:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_item_enchantments"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetItemLore(variable: Any, item: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetItemLore:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В variableGetItemLore:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_item_lore"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetItemLoreLine(variable: Any, item: Any, line: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetItemLoreLine:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В variableGetItemLoreLine:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
            val lineARG: JNumber = when (line) {
                is Number -> JNumber(line)
is JNumber -> line
                else -> {
                    errorPrint("${currentScope.scope}: В variableGetItemLoreLine:line получен тип ${line.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("line"),
    "value" to lineARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_item_lore_line"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetItemMaxStackSize(variable: Any, item: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetItemMaxStackSize:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В variableGetItemMaxStackSize:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_item_max_stack_size"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetItemName(variable: Any, item: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetItemName:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В variableGetItemName:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_item_name"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetItemNbtTags(variable: Any, item: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetItemNbtTags:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В variableGetItemNbtTags:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_item_nbt_tags"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetItemPlaceableBlocks(variable: Any, item: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetItemPlaceableBlocks:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В variableGetItemPlaceableBlocks:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_item_placeable_blocks"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetItemPotionEffects(variable: Any, item: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetItemPotionEffects:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В variableGetItemPotionEffects:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_item_potion_effects"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetItemRarity(variable: Any, item: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetItemRarity:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В variableGetItemRarity:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_item_rarity"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetItemType(variable: Any, type: Any, value: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetItemType:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val typeARG: JItem = when (type) {
    is JItem -> type
    else -> {
        errorPrint("${currentScope.scope}: В variableGetItemType:type получен тип ${type.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("type"),
    "value" to typeARG.parse()
)))
if (value != null) {
    if (value.value !in setOf("ID", "ITEM", "NAME")) {
        errorPrint("${currentScope.scope}: В функции variableGetItemType для аргумента value получено значение = \"${value.value}\", ожидалось одно из: \"ID\", \"ITEM\", \"NAME\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("value"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to value.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_item_type"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetLecternBook(variable: Any, location: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetLecternBook:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В variableGetLecternBook:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_lectern_book"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetLecternPage(variable: Any, location: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetLecternPage:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В variableGetLecternPage:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_lectern_page"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetLightLevel(variable: Any, location: Any, valueType: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetLightLevel:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В variableGetLightLevel:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
if (valueType != null) {
    if (valueType.value !in setOf("BLOCKS", "SKY", "TOTAL")) {
        errorPrint("${currentScope.scope}: В функции variableGetLightLevel для аргумента value_type получено значение = \"${valueType.value}\", ожидалось одно из: \"BLOCKS\", \"SKY\", \"TOTAL\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("value_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to valueType.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_light_level"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetListIndexOfValue(variable: Any, list: Any, value: Any, searchMode: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetListIndexOfValue:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val listARG: JArray = when (list) {
    is JArray -> list
    else -> {
        errorPrint("${currentScope.scope}: В variableGetListIndexOfValue:list получен тип ${list.javaClass.kotlin.simpleName}, ожидалось: JArray")
        throw Exception()
    }
}
val valueARG: JAny = when (value) {
    is JAny -> value
    else -> {
        errorPrint("${currentScope.scope}: В variableGetListIndexOfValue:value получен тип ${value.javaClass.kotlin.simpleName}, ожидалось: JAny")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("list"),
    "value" to listARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("value"),
    "value" to valueARG.parse()
)))
if (searchMode != null) {
    if (searchMode.value !in setOf("FIRST", "LAST")) {
        errorPrint("${currentScope.scope}: В функции variableGetListIndexOfValue для аргумента search_mode получено значение = \"${searchMode.value}\", ожидалось одно из: \"FIRST\", \"LAST\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("search_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to searchMode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_list_index_of_value"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetListLength(variable: Any, list: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetListLength:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val listARG: JArray = when (list) {
    is JArray -> list
    else -> {
        errorPrint("${currentScope.scope}: В variableGetListLength:list получен тип ${list.javaClass.kotlin.simpleName}, ожидалось: JArray")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("list"),
    "value" to listARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_list_length"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetListRandomValue(variable: Any, list: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetListRandomValue:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val listARG: JArray = when (list) {
    is JArray -> list
    else -> {
        errorPrint("${currentScope.scope}: В variableGetListRandomValue:list получен тип ${list.javaClass.kotlin.simpleName}, ожидалось: JArray")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("list"),
    "value" to listARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_list_random_value"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetListValue(variable: Any, list: Any, number: Any, defaultValue: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetListValue:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val listARG: JArray = when (list) {
    is JArray -> list
    else -> {
        errorPrint("${currentScope.scope}: В variableGetListValue:list получен тип ${list.javaClass.kotlin.simpleName}, ожидалось: JArray")
        throw Exception()
    }
}
            val numberARG: JNumber = when (number) {
                is Number -> JNumber(number)
is JNumber -> number
                else -> {
                    errorPrint("${currentScope.scope}: В variableGetListValue:number получен тип ${number.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
val defaultValueARG: JAny = when (defaultValue) {
    is JAny -> defaultValue
    else -> {
        errorPrint("${currentScope.scope}: В variableGetListValue:defaultValue получен тип ${defaultValue.javaClass.kotlin.simpleName}, ожидалось: JAny")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("list"),
    "value" to listARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("number"),
    "value" to numberARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("default_value"),
    "value" to defaultValueARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_list_value"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetListVariables(variable: Any, scope: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetListVariables:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
if (scope != null) {
    if (scope.value !in setOf("GAME", "LOCAL", "SAVE")) {
        errorPrint("${currentScope.scope}: В функции variableGetListVariables для аргумента scope получено значение = \"${scope.value}\", ожидалось одно из: \"GAME\", \"LOCAL\", \"SAVE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("scope"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to scope.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_list_variables"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetLocationDirection(variable: Any, location: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetLocationDirection:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В variableGetLocationDirection:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_location_direction"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetMapKeyByIndex(variable: Any, map: Any, index: Any, defaultValue: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetMapKeyByIndex:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val mapARG: JMap = when (map) {
    is JMap -> map
    else -> {
        errorPrint("${currentScope.scope}: В variableGetMapKeyByIndex:map получен тип ${map.javaClass.kotlin.simpleName}, ожидалось: JMap")
        throw Exception()
    }
}
            val indexARG: JNumber = when (index) {
                is Number -> JNumber(index)
is JNumber -> index
                else -> {
                    errorPrint("${currentScope.scope}: В variableGetMapKeyByIndex:index получен тип ${index.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
val defaultValueARG: JAny = when (defaultValue) {
    is JAny -> defaultValue
    else -> {
        errorPrint("${currentScope.scope}: В variableGetMapKeyByIndex:defaultValue получен тип ${defaultValue.javaClass.kotlin.simpleName}, ожидалось: JAny")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("map"),
    "value" to mapARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("index"),
    "value" to indexARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("default_value"),
    "value" to defaultValueARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_map_key_by_index"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetMapKeys(variable: Any, map: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetMapKeys:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val mapARG: JMap = when (map) {
    is JMap -> map
    else -> {
        errorPrint("${currentScope.scope}: В variableGetMapKeys:map получен тип ${map.javaClass.kotlin.simpleName}, ожидалось: JMap")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("map"),
    "value" to mapARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_map_keys"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetMapKeysByValue(variable: Any, map: Any, value: Any, defaultValue: Any, findMode: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetMapKeysByValue:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val mapARG: JMap = when (map) {
    is JMap -> map
    else -> {
        errorPrint("${currentScope.scope}: В variableGetMapKeysByValue:map получен тип ${map.javaClass.kotlin.simpleName}, ожидалось: JMap")
        throw Exception()
    }
}
val valueARG: JAny = when (value) {
    is JAny -> value
    else -> {
        errorPrint("${currentScope.scope}: В variableGetMapKeysByValue:value получен тип ${value.javaClass.kotlin.simpleName}, ожидалось: JAny")
        throw Exception()
    }
}
val defaultValueARG: JAny = when (defaultValue) {
    is JAny -> defaultValue
    else -> {
        errorPrint("${currentScope.scope}: В variableGetMapKeysByValue:defaultValue получен тип ${defaultValue.javaClass.kotlin.simpleName}, ожидалось: JAny")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("map"),
    "value" to mapARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("value"),
    "value" to valueARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("default_value"),
    "value" to defaultValueARG.parse()
)))
if (findMode != null) {
    if (findMode.value !in setOf("ALL", "FIRST", "LAST")) {
        errorPrint("${currentScope.scope}: В функции variableGetMapKeysByValue для аргумента find_mode получено значение = \"${findMode.value}\", ожидалось одно из: \"ALL\", \"FIRST\", \"LAST\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("find_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to findMode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_map_keys_by_value"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetMapSize(variable: Any, map: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetMapSize:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val mapARG: JMap = when (map) {
    is JMap -> map
    else -> {
        errorPrint("${currentScope.scope}: В variableGetMapSize:map получен тип ${map.javaClass.kotlin.simpleName}, ожидалось: JMap")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("map"),
    "value" to mapARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_map_size"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetMapValue(variable: Any, map: Any, key: Any, defaultValue: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetMapValue:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val mapARG: JMap = when (map) {
    is JMap -> map
    else -> {
        errorPrint("${currentScope.scope}: В variableGetMapValue:map получен тип ${map.javaClass.kotlin.simpleName}, ожидалось: JMap")
        throw Exception()
    }
}
val keyARG: JAny = when (key) {
    is JAny -> key
    else -> {
        errorPrint("${currentScope.scope}: В variableGetMapValue:key получен тип ${key.javaClass.kotlin.simpleName}, ожидалось: JAny")
        throw Exception()
    }
}
val defaultValueARG: JAny = when (defaultValue) {
    is JAny -> defaultValue
    else -> {
        errorPrint("${currentScope.scope}: В variableGetMapValue:defaultValue получен тип ${defaultValue.javaClass.kotlin.simpleName}, ожидалось: JAny")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("map"),
    "value" to mapARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("key"),
    "value" to keyARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("default_value"),
    "value" to defaultValueARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_map_value"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetMapValueByIndex(variable: Any, map: Any, index: Any, defaultValue: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetMapValueByIndex:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val mapARG: JMap = when (map) {
    is JMap -> map
    else -> {
        errorPrint("${currentScope.scope}: В variableGetMapValueByIndex:map получен тип ${map.javaClass.kotlin.simpleName}, ожидалось: JMap")
        throw Exception()
    }
}
            val indexARG: JNumber = when (index) {
                is Number -> JNumber(index)
is JNumber -> index
                else -> {
                    errorPrint("${currentScope.scope}: В variableGetMapValueByIndex:index получен тип ${index.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
val defaultValueARG: JAny = when (defaultValue) {
    is JAny -> defaultValue
    else -> {
        errorPrint("${currentScope.scope}: В variableGetMapValueByIndex:defaultValue получен тип ${defaultValue.javaClass.kotlin.simpleName}, ожидалось: JAny")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("map"),
    "value" to mapARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("index"),
    "value" to indexARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("default_value"),
    "value" to defaultValueARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_map_value_by_index"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetMapValues(variable: Any, map: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetMapValues:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val mapARG: JMap = when (map) {
    is JMap -> map
    else -> {
        errorPrint("${currentScope.scope}: В variableGetMapValues:map получен тип ${map.javaClass.kotlin.simpleName}, ожидалось: JMap")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("map"),
    "value" to mapARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_map_values"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetMidpointBetweenVectors(variable: Any, vector1: Any, vector2: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetMidpointBetweenVectors:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val vector1ARG: JVector = when (vector1) {
    is JVector -> vector1
    else -> {
        errorPrint("${currentScope.scope}: В variableGetMidpointBetweenVectors:vector1 получен тип ${vector1.javaClass.kotlin.simpleName}, ожидалось: JVector")
        throw Exception()
    }
}
val vector2ARG: JVector = when (vector2) {
    is JVector -> vector2
    else -> {
        errorPrint("${currentScope.scope}: В variableGetMidpointBetweenVectors:vector2 получен тип ${vector2.javaClass.kotlin.simpleName}, ожидалось: JVector")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("vector_1"),
    "value" to vector1ARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("vector_2"),
    "value" to vector2ARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_midpoint_between_vectors"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetParticleAmount(variable: Any, particle: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetParticleAmount:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val particleARG: JParticle = when (particle) {
    is JParticle -> particle
    else -> {
        errorPrint("${currentScope.scope}: В variableGetParticleAmount:particle получен тип ${particle.javaClass.kotlin.simpleName}, ожидалось: JParticle")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("particle"),
    "value" to particleARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_particle_amount"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetParticleColor(variable: Any, particle: Any, colorType: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetParticleColor:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val particleARG: JParticle = when (particle) {
    is JParticle -> particle
    else -> {
        errorPrint("${currentScope.scope}: В variableGetParticleColor:particle получен тип ${particle.javaClass.kotlin.simpleName}, ожидалось: JParticle")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("particle"),
    "value" to particleARG.parse()
)))
if (colorType != null) {
    if (colorType.value !in setOf("COLOR", "TO_COLOR")) {
        errorPrint("${currentScope.scope}: В функции variableGetParticleColor для аргумента color_type получено значение = \"${colorType.value}\", ожидалось одно из: \"COLOR\", \"TO_COLOR\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("color_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to colorType.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_particle_color"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetParticleMaterial(variable: Any, particle: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetParticleMaterial:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val particleARG: JParticle = when (particle) {
    is JParticle -> particle
    else -> {
        errorPrint("${currentScope.scope}: В variableGetParticleMaterial:particle получен тип ${particle.javaClass.kotlin.simpleName}, ожидалось: JParticle")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("particle"),
    "value" to particleARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_particle_material"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetParticleOffset(variable: Any, particle: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetParticleOffset:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val particleARG: JParticle = when (particle) {
    is JParticle -> particle
    else -> {
        errorPrint("${currentScope.scope}: В variableGetParticleOffset:particle получен тип ${particle.javaClass.kotlin.simpleName}, ожидалось: JParticle")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("particle"),
    "value" to particleARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_particle_offset"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetParticleSize(variable: Any, particle: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetParticleSize:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val particleARG: JParticle = when (particle) {
    is JParticle -> particle
    else -> {
        errorPrint("${currentScope.scope}: В variableGetParticleSize:particle получен тип ${particle.javaClass.kotlin.simpleName}, ожидалось: JParticle")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("particle"),
    "value" to particleARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_particle_size"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetParticleSpread(variable: Any, particle: Any, type: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetParticleSpread:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val particleARG: JParticle = when (particle) {
    is JParticle -> particle
    else -> {
        errorPrint("${currentScope.scope}: В variableGetParticleSpread:particle получен тип ${particle.javaClass.kotlin.simpleName}, ожидалось: JParticle")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("particle"),
    "value" to particleARG.parse()
)))
if (type != null) {
    if (type.value !in setOf("HORIZONTAL", "VERTICAL")) {
        errorPrint("${currentScope.scope}: В функции variableGetParticleSpread для аргумента type получено значение = \"${type.value}\", ожидалось одно из: \"HORIZONTAL\", \"VERTICAL\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to type.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_particle_spread"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetParticleType(variable: Any, particle: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetParticleType:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val particleARG: JParticle = when (particle) {
    is JParticle -> particle
    else -> {
        errorPrint("${currentScope.scope}: В variableGetParticleType:particle получен тип ${particle.javaClass.kotlin.simpleName}, ожидалось: JParticle")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("particle"),
    "value" to particleARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_particle_type"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetPlayerHead(variable: Any, nameOrUuid: Any, receiveType: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetPlayerHead:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val nameOrUuidARG: JString = when (nameOrUuid) {
                is String -> JString(nameOrUuid)
is JString -> nameOrUuid
                else -> {
                    errorPrint("${currentScope.scope}: В variableGetPlayerHead:nameOrUuid получен тип ${nameOrUuid.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("name_or_uuid"),
    "value" to nameOrUuidARG.parse()
)))
if (receiveType != null) {
    if (receiveType.value !in setOf("NAME_OR_UUID", "VALUE")) {
        errorPrint("${currentScope.scope}: В функции variableGetPlayerHead для аргумента receive_type получено значение = \"${receiveType.value}\", ожидалось одно из: \"NAME_OR_UUID\", \"VALUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("receive_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to receiveType.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_player_head"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetPlayerHeadOwner(variable: Any, head: Any, returnValue: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetPlayerHeadOwner:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val headARG: JItem = when (head) {
    is JItem -> head
    else -> {
        errorPrint("${currentScope.scope}: В variableGetPlayerHeadOwner:head получен тип ${head.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("head"),
    "value" to headARG.parse()
)))
if (returnValue != null) {
    if (returnValue.value !in setOf("NAME", "UUID", "VALUE")) {
        errorPrint("${currentScope.scope}: В функции variableGetPlayerHeadOwner для аргумента return_value получено значение = \"${returnValue.value}\", ожидалось одно из: \"NAME\", \"UUID\", \"VALUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("return_value"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to returnValue.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_player_head_owner"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetPlayerHeadValue(variable: Any, location: Any, returnValue: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetPlayerHeadValue:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В variableGetPlayerHeadValue:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
if (returnValue != null) {
    if (returnValue.value !in setOf("NAME", "UUID", "VALUE")) {
        errorPrint("${currentScope.scope}: В функции variableGetPlayerHeadValue для аргумента return_value получено значение = \"${returnValue.value}\", ожидалось одно из: \"NAME\", \"UUID\", \"VALUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("return_value"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to returnValue.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_player_head_value"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetPotionEffectAmplifier(variable: Any, potion: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetPotionEffectAmplifier:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val potionARG: JPotion = when (potion) {
    is JPotion -> potion
    else -> {
        errorPrint("${currentScope.scope}: В variableGetPotionEffectAmplifier:potion получен тип ${potion.javaClass.kotlin.simpleName}, ожидалось: JPotion")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("potion"),
    "value" to potionARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_potion_effect_amplifier"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetPotionEffectDuration(variable: Any, potion: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetPotionEffectDuration:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val potionARG: JPotion = when (potion) {
    is JPotion -> potion
    else -> {
        errorPrint("${currentScope.scope}: В variableGetPotionEffectDuration:potion получен тип ${potion.javaClass.kotlin.simpleName}, ожидалось: JPotion")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("potion"),
    "value" to potionARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_potion_effect_duration"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetPotionEffectType(variable: Any, potion: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetPotionEffectType:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val potionARG: JPotion = when (potion) {
    is JPotion -> potion
    else -> {
        errorPrint("${currentScope.scope}: В variableGetPotionEffectType:potion получен тип ${potion.javaClass.kotlin.simpleName}, ожидалось: JPotion")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("potion"),
    "value" to potionARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_potion_effect_type"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetSculkShriekerWarningLevel(variable: Any, location: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetSculkShriekerWarningLevel:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В variableGetSculkShriekerWarningLevel:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_sculk_shrieker_warning_level"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetSignText(variable: Any, location: Any, checkSide: JString? = null, signLine: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetSignText:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В variableGetSignText:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}


    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
if (checkSide != null) {
    if (checkSide.value !in setOf("ALL", "BACK", "FRONT")) {
        errorPrint("${currentScope.scope}: В функции variableGetSignText для аргумента check_side получено значение = \"${checkSide.value}\", ожидалось одно из: \"ALL\", \"BACK\", \"FRONT\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("check_side"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to checkSide.jsonValue()
        ))
    )))
}
if (signLine != null) {
    if (signLine.value !in setOf("ALL", "FIRST", "FOURTH", "SECOND", "THIRD")) {
        errorPrint("${currentScope.scope}: В функции variableGetSignText для аргумента sign_line получено значение = \"${signLine.value}\", ожидалось одно из: \"ALL\", \"FIRST\", \"FOURTH\", \"SECOND\", \"THIRD\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("sign_line"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to signLine.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_sign_text"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetSoundPitch(variable: Any, sound: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetSoundPitch:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val soundARG: JSound = when (sound) {
    is JSound -> sound
    else -> {
        errorPrint("${currentScope.scope}: В variableGetSoundPitch:sound получен тип ${sound.javaClass.kotlin.simpleName}, ожидалось: JSound")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("sound"),
    "value" to soundARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_sound_pitch"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetSoundSource(variable: Any, sound: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetSoundSource:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val soundARG: JSound = when (sound) {
    is JSound -> sound
    else -> {
        errorPrint("${currentScope.scope}: В variableGetSoundSource:sound получен тип ${sound.javaClass.kotlin.simpleName}, ожидалось: JSound")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("sound"),
    "value" to soundARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_sound_source"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetSoundType(variable: Any, sound: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetSoundType:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val soundARG: JSound = when (sound) {
    is JSound -> sound
    else -> {
        errorPrint("${currentScope.scope}: В variableGetSoundType:sound получен тип ${sound.javaClass.kotlin.simpleName}, ожидалось: JSound")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("sound"),
    "value" to soundARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_sound_type"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetSoundVariation(variable: Any, sound: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetSoundVariation:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val soundARG: JSound = when (sound) {
    is JSound -> sound
    else -> {
        errorPrint("${currentScope.scope}: В variableGetSoundVariation:sound получен тип ${sound.javaClass.kotlin.simpleName}, ожидалось: JSound")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("sound"),
    "value" to soundARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_sound_variation"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetSoundVariations(variable: Any, sound: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetSoundVariations:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val soundARG: JSound = when (sound) {
    is JSound -> sound
    else -> {
        errorPrint("${currentScope.scope}: В variableGetSoundVariations:sound получен тип ${sound.javaClass.kotlin.simpleName}, ожидалось: JSound")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("sound"),
    "value" to soundARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_sound_variations"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetSoundVolumeAction(variable: Any, sound: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetSoundVolumeAction:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val soundARG: JSound = when (sound) {
    is JSound -> sound
    else -> {
        errorPrint("${currentScope.scope}: В variableGetSoundVolumeAction:sound получен тип ${sound.javaClass.kotlin.simpleName}, ожидалось: JSound")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("sound"),
    "value" to soundARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_sound_volume_action"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetTemplateCode(variable: Any, template: Any, returnType: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetTemplateCode:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val templateARG: JItem = when (template) {
    is JItem -> template
    else -> {
        errorPrint("${currentScope.scope}: В variableGetTemplateCode:template получен тип ${template.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("template"),
    "value" to templateARG.parse()
)))
if (returnType != null) {
    if (returnType.value !in setOf("MAP", "TEXT")) {
        errorPrint("${currentScope.scope}: В функции variableGetTemplateCode для аргумента return_type получено значение = \"${returnType.value}\", ожидалось одно из: \"MAP\", \"TEXT\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("return_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to returnType.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_template_code"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetTextWidth(variable: Any, text: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetTextWidth:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val textARG: JString = when (text) {
                is String -> JString(text)
is JString -> text
                else -> {
                    errorPrint("${currentScope.scope}: В variableGetTextWidth:text получен тип ${text.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("text"),
    "value" to textARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_text_width"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetVectorAllComponents(x: Any, y: Any, z: Any, vector: Any) {
val xARG: Var = when (x) {
    is Var -> x
    else -> {
        errorPrint("${currentScope.scope}: В variableGetVectorAllComponents:x получен тип ${x.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val yARG: Var = when (y) {
    is Var -> y
    else -> {
        errorPrint("${currentScope.scope}: В variableGetVectorAllComponents:y получен тип ${y.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val zARG: Var = when (z) {
    is Var -> z
    else -> {
        errorPrint("${currentScope.scope}: В variableGetVectorAllComponents:z получен тип ${z.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val vectorARG: JVector = when (vector) {
    is JVector -> vector
    else -> {
        errorPrint("${currentScope.scope}: В variableGetVectorAllComponents:vector получен тип ${vector.javaClass.kotlin.simpleName}, ожидалось: JVector")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("x"),
    "value" to xARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("y"),
    "value" to yARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("z"),
    "value" to zARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("vector"),
    "value" to vectorARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_vector_all_components"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetVectorBetweenLocations(variable: Any, endLocation: Any, startLocation: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetVectorBetweenLocations:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val endLocationARG: JLocation = when (endLocation) {
    is JLocation -> endLocation
    else -> {
        errorPrint("${currentScope.scope}: В variableGetVectorBetweenLocations:endLocation получен тип ${endLocation.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
val startLocationARG: JLocation = when (startLocation) {
    is JLocation -> startLocation
    else -> {
        errorPrint("${currentScope.scope}: В variableGetVectorBetweenLocations:startLocation получен тип ${startLocation.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("end_location"),
    "value" to endLocationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("start_location"),
    "value" to startLocationARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_vector_between_locations"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetVectorComponent(variable: Any, vector: Any, vectorComponent: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetVectorComponent:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val vectorARG: JVector = when (vector) {
    is JVector -> vector
    else -> {
        errorPrint("${currentScope.scope}: В variableGetVectorComponent:vector получен тип ${vector.javaClass.kotlin.simpleName}, ожидалось: JVector")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("vector"),
    "value" to vectorARG.parse()
)))
if (vectorComponent != null) {
    if (vectorComponent.value !in setOf("X", "Y", "Z")) {
        errorPrint("${currentScope.scope}: В функции variableGetVectorComponent для аргумента vector_component получено значение = \"${vectorComponent.value}\", ожидалось одно из: \"X\", \"Y\", \"Z\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("vector_component"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to vectorComponent.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_vector_component"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetVectorFromBlockFace(variable: Any, blockFace: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetVectorFromBlockFace:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val blockFaceARG: JString = when (blockFace) {
                is String -> JString(blockFace)
is JString -> blockFace
                else -> {
                    errorPrint("${currentScope.scope}: В variableGetVectorFromBlockFace:blockFace получен тип ${blockFace.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("block_face"),
    "value" to blockFaceARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_vector_from_block_face"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetVectorLength(variable: Any, vector: Any, lengthType: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetVectorLength:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val vectorARG: JVector = when (vector) {
    is JVector -> vector
    else -> {
        errorPrint("${currentScope.scope}: В variableGetVectorLength:vector получен тип ${vector.javaClass.kotlin.simpleName}, ожидалось: JVector")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("vector"),
    "value" to vectorARG.parse()
)))
if (lengthType != null) {
    if (lengthType.value !in setOf("LENGTH", "LENGTH_SQUARED")) {
        errorPrint("${currentScope.scope}: В функции variableGetVectorLength для аргумента length_type получено значение = \"${lengthType.value}\", ожидалось одно из: \"LENGTH\", \"LENGTH_SQUARED\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("length_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to lengthType.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_get_vector_length"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetTextHash(variable: Any, text: Any, algorithm: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetTextHash:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val textARG: JString = when (text) {
                is String -> JString(text)
is JString -> text
                else -> {
                    errorPrint("${currentScope.scope}: В variableGetTextHash:text получен тип ${text.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("text"),
    "value" to textARG.parse()
)))
if (algorithm != null) {
    if (algorithm.value !in setOf("MD5", "SHA1", "SHA256")) {
        errorPrint("${currentScope.scope}: В функции variableGetTextHash для аргумента algorithm получено значение = \"${algorithm.value}\", ожидалось одно из: \"MD5\", \"SHA1\", \"SHA256\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("algorithm"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to algorithm.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_hash"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableIncrement(variable: Any, number: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableIncrement:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val numberARG: JNumber = when (number) {
                is Number -> JNumber(number)
is JNumber -> number
                else -> {
                    errorPrint("${currentScope.scope}: В variableIncrement:number получен тип ${number.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("number"),
    "value" to numberARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_increment"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableInsertListValue(variable: Any, list: Any, number: Any, value: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableInsertListValue:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val listARG: JArray = when (list) {
    is JArray -> list
    else -> {
        errorPrint("${currentScope.scope}: В variableInsertListValue:list получен тип ${list.javaClass.kotlin.simpleName}, ожидалось: JArray")
        throw Exception()
    }
}
            val numberARG: JNumber = when (number) {
                is Number -> JNumber(number)
is JNumber -> number
                else -> {
                    errorPrint("${currentScope.scope}: В variableInsertListValue:number получен тип ${number.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
val valueARG: JAny = when (value) {
    is JAny -> value
    else -> {
        errorPrint("${currentScope.scope}: В variableInsertListValue:value получен тип ${value.javaClass.kotlin.simpleName}, ожидалось: JAny")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("list"),
    "value" to listARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("number"),
    "value" to numberARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("value"),
    "value" to valueARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_insert_list_value"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableJoinText(variable: Any, list: Any, separator: Any, prefix: Any, postfix: Any, limit: Any, truncated: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableJoinText:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val listARG: JArray = when (list) {
    is JArray -> list
    else -> {
        errorPrint("${currentScope.scope}: В variableJoinText:list получен тип ${list.javaClass.kotlin.simpleName}, ожидалось: JArray")
        throw Exception()
    }
}
            val separatorARG: JString = when (separator) {
                is String -> JString(separator)
is JString -> separator
                else -> {
                    errorPrint("${currentScope.scope}: В variableJoinText:separator получен тип ${separator.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val prefixARG: JString = when (prefix) {
                is String -> JString(prefix)
is JString -> prefix
                else -> {
                    errorPrint("${currentScope.scope}: В variableJoinText:prefix получен тип ${prefix.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val postfixARG: JString = when (postfix) {
                is String -> JString(postfix)
is JString -> postfix
                else -> {
                    errorPrint("${currentScope.scope}: В variableJoinText:postfix получен тип ${postfix.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val limitARG: JNumber = when (limit) {
                is Number -> JNumber(limit)
is JNumber -> limit
                else -> {
                    errorPrint("${currentScope.scope}: В variableJoinText:limit получен тип ${limit.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val truncatedARG: JString = when (truncated) {
                is String -> JString(truncated)
is JString -> truncated
                else -> {
                    errorPrint("${currentScope.scope}: В variableJoinText:truncated получен тип ${truncated.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("list"),
    "value" to listARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("separator"),
    "value" to separatorARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("prefix"),
    "value" to prefixARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("postfix"),
    "value" to postfixARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("limit"),
    "value" to limitARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("truncated"),
    "value" to truncatedARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_join_text"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableLerpNumber(variable: Any, start: Any, stop: Any, amount: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableLerpNumber:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val startARG: JNumber = when (start) {
                is Number -> JNumber(start)
is JNumber -> start
                else -> {
                    errorPrint("${currentScope.scope}: В variableLerpNumber:start получен тип ${start.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val stopARG: JNumber = when (stop) {
                is Number -> JNumber(stop)
is JNumber -> stop
                else -> {
                    errorPrint("${currentScope.scope}: В variableLerpNumber:stop получен тип ${stop.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val amountARG: JNumber = when (amount) {
                is Number -> JNumber(amount)
is JNumber -> amount
                else -> {
                    errorPrint("${currentScope.scope}: В variableLerpNumber:amount получен тип ${amount.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("start"),
    "value" to startARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("stop"),
    "value" to stopARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("amount"),
    "value" to amountARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_lerp_number"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableLocationRelative(variable: Any, location: Any, distance: Any, blockFace: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableLocationRelative:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В variableLocationRelative:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val distanceARG: JNumber = when (distance) {
                is Number -> JNumber(distance)
is JNumber -> distance
                else -> {
                    errorPrint("${currentScope.scope}: В variableLocationRelative:distance получен тип ${distance.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("distance"),
    "value" to distanceARG.parse()
)))
if (blockFace != null) {
    if (blockFace.value !in setOf("DOWN", "EAST", "EAST_NORTH_EAST", "EAST_SOUTH_EAST", "NORTH", "NORTH_EAST", "NORTH_NORTH_EAST", "NORTH_NORTH_WEST", "NORTH_WEST", "SELF", "SOUTH", "SOUTH_EAST", "SOUTH_SOUTH_EAST", "SOUTH_SOUTH_WEST", "SOUTH_WEST", "UP", "WEST", "WEST_NORTH_WEST", "WEST_SOUTH_WEST")) {
        errorPrint("${currentScope.scope}: В функции variableLocationRelative для аргумента block_face получено значение = \"${blockFace.value}\", ожидалось одно из: \"DOWN\", \"EAST\", \"EAST_NORTH_EAST\", \"EAST_SOUTH_EAST\", \"NORTH\", \"NORTH_EAST\", \"NORTH_NORTH_EAST\", \"NORTH_NORTH_WEST\", \"NORTH_WEST\", \"SELF\", \"SOUTH\", \"SOUTH_EAST\", \"SOUTH_SOUTH_EAST\", \"SOUTH_SOUTH_WEST\", \"SOUTH_WEST\", \"UP\", \"WEST\", \"WEST_NORTH_WEST\", \"WEST_SOUTH_WEST\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("block_face"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to blockFace.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_location_relative"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableLocationsDistance(variable: Any, location1: Any, location2: Any, type: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableLocationsDistance:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val location1ARG: JLocation = when (location1) {
    is JLocation -> location1
    else -> {
        errorPrint("${currentScope.scope}: В variableLocationsDistance:location1 получен тип ${location1.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
val location2ARG: JLocation = when (location2) {
    is JLocation -> location2
    else -> {
        errorPrint("${currentScope.scope}: В variableLocationsDistance:location2 получен тип ${location2.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location_1"),
    "value" to location1ARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location_2"),
    "value" to location2ARG.parse()
)))
if (type != null) {
    if (type.value !in setOf("ALTITUDE", "THREE_D", "TWO_D")) {
        errorPrint("${currentScope.scope}: В функции variableLocationsDistance для аргумента type получено значение = \"${type.value}\", ожидалось одно из: \"ALTITUDE\", \"THREE_D\", \"TWO_D\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to type.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_locations_distance"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableLog(variable: Any, number: Any, base: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableLog:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val numberARG: JNumber = when (number) {
                is Number -> JNumber(number)
is JNumber -> number
                else -> {
                    errorPrint("${currentScope.scope}: В variableLog:number получен тип ${number.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val baseARG: JNumber = when (base) {
                is Number -> JNumber(base)
is JNumber -> base
                else -> {
                    errorPrint("${currentScope.scope}: В variableLog:base получен тип ${base.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("number"),
    "value" to numberARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("base"),
    "value" to baseARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_log"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableMapRange(variable: Any, number: Any, fromStart: Any, fromStop: Any, toStart: Any, toStop: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableMapRange:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val numberARG: JNumber = when (number) {
                is Number -> JNumber(number)
is JNumber -> number
                else -> {
                    errorPrint("${currentScope.scope}: В variableMapRange:number получен тип ${number.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val fromStartARG: JNumber = when (fromStart) {
                is Number -> JNumber(fromStart)
is JNumber -> fromStart
                else -> {
                    errorPrint("${currentScope.scope}: В variableMapRange:fromStart получен тип ${fromStart.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val fromStopARG: JNumber = when (fromStop) {
                is Number -> JNumber(fromStop)
is JNumber -> fromStop
                else -> {
                    errorPrint("${currentScope.scope}: В variableMapRange:fromStop получен тип ${fromStop.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val toStartARG: JNumber = when (toStart) {
                is Number -> JNumber(toStart)
is JNumber -> toStart
                else -> {
                    errorPrint("${currentScope.scope}: В variableMapRange:toStart получен тип ${toStart.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val toStopARG: JNumber = when (toStop) {
                is Number -> JNumber(toStop)
is JNumber -> toStop
                else -> {
                    errorPrint("${currentScope.scope}: В variableMapRange:toStop получен тип ${toStop.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("number"),
    "value" to numberARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("from_start"),
    "value" to fromStartARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("from_stop"),
    "value" to fromStopARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("to_start"),
    "value" to toStartARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("to_stop"),
    "value" to toStopARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_map_range"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableMax(variable: Any, value: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableMax:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val valueARG: JNumber = when (value) {
                is Number -> JNumber(value)
is JNumber -> value
                else -> {
                    errorPrint("${currentScope.scope}: В variableMax:value получен тип ${value.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("value"),
    "value" to valueARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_max"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableMin(variable: Any, value: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableMin:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val valueARG: JNumber = when (value) {
                is Number -> JNumber(value)
is JNumber -> value
                else -> {
                    errorPrint("${currentScope.scope}: В variableMin:value получен тип ${value.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("value"),
    "value" to valueARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_min"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableMultiply(variable: Any, value: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableMultiply:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val valueARG: JNumber = when (value) {
                is Number -> JNumber(value)
is JNumber -> value
                else -> {
                    errorPrint("${currentScope.scope}: В variableMultiply:value получен тип ${value.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("value"),
    "value" to valueARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_multiply"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableMultiplyVector(variable: Any, vector: Any, multiplier: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableMultiplyVector:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val vectorARG: JVector = when (vector) {
    is JVector -> vector
    else -> {
        errorPrint("${currentScope.scope}: В variableMultiplyVector:vector получен тип ${vector.javaClass.kotlin.simpleName}, ожидалось: JVector")
        throw Exception()
    }
}
            val multiplierARG: JNumber = when (multiplier) {
                is Number -> JNumber(multiplier)
is JNumber -> multiplier
                else -> {
                    errorPrint("${currentScope.scope}: В variableMultiplyVector:multiplier получен тип ${multiplier.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("vector"),
    "value" to vectorARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("multiplier"),
    "value" to multiplierARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_multiply_vector"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableParseJson(variable: Any, json: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableParseJson:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val jsonARG: JString = when (json) {
                is String -> JString(json)
is JString -> json
                else -> {
                    errorPrint("${currentScope.scope}: В variableParseJson:json получен тип ${json.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("json"),
    "value" to jsonARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_parse_json"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableParseToComponent(variable: Any, text: Any, parsing: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableParseToComponent:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val textARG: JString = when (text) {
                is String -> JString(text)
is JString -> text
                else -> {
                    errorPrint("${currentScope.scope}: В variableParseToComponent:text получен тип ${text.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("text"),
    "value" to textARG.parse()
)))
if (parsing != null) {
    if (parsing.value !in setOf("JSON", "LEGACY", "MINIMESSAGE", "PLAIN")) {
        errorPrint("${currentScope.scope}: В функции variableParseToComponent для аргумента parsing получено значение = \"${parsing.value}\", ожидалось одно из: \"JSON\", \"LEGACY\", \"MINIMESSAGE\", \"PLAIN\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("parsing"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to parsing.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_parse_to_component"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variablePerlinNoise3d(variable: Any, location: Any, seed: Any, locFrequency: Any, octaves: Any, frequency: Any, amplitude: Any, rangeMode: JString? = null, normalized: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variablePerlinNoise3d:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В variablePerlinNoise3d:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val seedARG: JNumber = when (seed) {
                is Number -> JNumber(seed)
is JNumber -> seed
                else -> {
                    errorPrint("${currentScope.scope}: В variablePerlinNoise3d:seed получен тип ${seed.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val locFrequencyARG: JNumber = when (locFrequency) {
                is Number -> JNumber(locFrequency)
is JNumber -> locFrequency
                else -> {
                    errorPrint("${currentScope.scope}: В variablePerlinNoise3d:locFrequency получен тип ${locFrequency.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val octavesARG: JNumber = when (octaves) {
                is Number -> JNumber(octaves)
is JNumber -> octaves
                else -> {
                    errorPrint("${currentScope.scope}: В variablePerlinNoise3d:octaves получен тип ${octaves.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val frequencyARG: JNumber = when (frequency) {
                is Number -> JNumber(frequency)
is JNumber -> frequency
                else -> {
                    errorPrint("${currentScope.scope}: В variablePerlinNoise3d:frequency получен тип ${frequency.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val amplitudeARG: JNumber = when (amplitude) {
                is Number -> JNumber(amplitude)
is JNumber -> amplitude
                else -> {
                    errorPrint("${currentScope.scope}: В variablePerlinNoise3d:amplitude получен тип ${amplitude.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }


    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("seed"),
    "value" to seedARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("loc_frequency"),
    "value" to locFrequencyARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("octaves"),
    "value" to octavesARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("frequency"),
    "value" to frequencyARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("amplitude"),
    "value" to amplitudeARG.parse()
)))
if (rangeMode != null) {
    if (rangeMode.value !in setOf("FULL_RANGE", "ZERO_TO_ONE")) {
        errorPrint("${currentScope.scope}: В функции variablePerlinNoise3d для аргумента range_mode получено значение = \"${rangeMode.value}\", ожидалось одно из: \"FULL_RANGE\", \"ZERO_TO_ONE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("range_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to rangeMode.jsonValue()
        ))
    )))
}
if (normalized != null) {
    if (normalized.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции variablePerlinNoise3d для аргумента normalized получено значение = \"${normalized.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("normalized"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to normalized.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_perlin_noise_3d"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variablePow(variable: Any, base: Any, power: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variablePow:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val baseARG: JNumber = when (base) {
                is Number -> JNumber(base)
is JNumber -> base
                else -> {
                    errorPrint("${currentScope.scope}: В variablePow:base получен тип ${base.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val powerARG: JNumber = when (power) {
                is Number -> JNumber(power)
is JNumber -> power
                else -> {
                    errorPrint("${currentScope.scope}: В variablePow:power получен тип ${power.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("base"),
    "value" to baseARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("power"),
    "value" to powerARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_pow"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variablePurge(names: Any, scope: JString? = null, match: JString? = null, ignoreCase: JString? = null) {
            val namesARG: JString = when (names) {
                is String -> JString(names)
is JString -> names
                else -> {
                    errorPrint("${currentScope.scope}: В variablePurge:names получен тип ${names.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }



    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("names"),
    "value" to namesARG.parse()
)))
if (scope != null) {
    if (scope.value !in setOf("GAME", "LOCAL", "SAVE")) {
        errorPrint("${currentScope.scope}: В функции variablePurge для аргумента scope получено значение = \"${scope.value}\", ожидалось одно из: \"GAME\", \"LOCAL\", \"SAVE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("scope"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to scope.jsonValue()
        ))
    )))
}
if (match != null) {
    if (match.value !in setOf("EQUALS", "NAME_CONTAINS", "PART_CONTAINS")) {
        errorPrint("${currentScope.scope}: В функции variablePurge для аргумента match получено значение = \"${match.value}\", ожидалось одно из: \"EQUALS\", \"NAME_CONTAINS\", \"PART_CONTAINS\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("match"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to match.jsonValue()
        ))
    )))
}
if (ignoreCase != null) {
    if (ignoreCase.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции variablePurge для аргумента ignore_case получено значение = \"${ignoreCase.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("ignore_case"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to ignoreCase.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_purge"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableRandom(variable: Any, values: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableRandom:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val valuesARG: JAny = when (values) {
    is JAny -> values
    else -> {
        errorPrint("${currentScope.scope}: В variableRandom:values получен тип ${values.javaClass.kotlin.simpleName}, ожидалось: JAny")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("values"),
    "value" to valuesARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_random"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableRandomLocation(variable: Any, location1: Any, location2: Any, integer: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableRandomLocation:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val location1ARG: JLocation = when (location1) {
    is JLocation -> location1
    else -> {
        errorPrint("${currentScope.scope}: В variableRandomLocation:location1 получен тип ${location1.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
val location2ARG: JLocation = when (location2) {
    is JLocation -> location2
    else -> {
        errorPrint("${currentScope.scope}: В variableRandomLocation:location2 получен тип ${location2.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location_1"),
    "value" to location1ARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location_2"),
    "value" to location2ARG.parse()
)))
if (integer != null) {
    if (integer.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции variableRandomLocation для аргумента integer получено значение = \"${integer.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("integer"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to integer.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_random_location"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableRandomNumber(variable: Any, min: Any, max: Any, integer: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableRandomNumber:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val minARG: JNumber = when (min) {
                is Number -> JNumber(min)
is JNumber -> min
                else -> {
                    errorPrint("${currentScope.scope}: В variableRandomNumber:min получен тип ${min.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val maxARG: JNumber = when (max) {
                is Number -> JNumber(max)
is JNumber -> max
                else -> {
                    errorPrint("${currentScope.scope}: В variableRandomNumber:max получен тип ${max.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("min"),
    "value" to minARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("max"),
    "value" to maxARG.parse()
)))
if (integer != null) {
    if (integer.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции variableRandomNumber для аргумента integer получено значение = \"${integer.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("integer"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to integer.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_random_number"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableRandomizeListOrder(variable: Any, list: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableRandomizeListOrder:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val listARG: JArray = when (list) {
    is JArray -> list
    else -> {
        errorPrint("${currentScope.scope}: В variableRandomizeListOrder:list получен тип ${list.javaClass.kotlin.simpleName}, ожидалось: JArray")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("list"),
    "value" to listARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_randomize_list_order"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableRayTraceResult(variableForHitLocation: Any, variableForHitBlockLocation: Any, variableForHitBlockFace: Any, variableForHitEntityUuid: Any, start: Any, raySize: Any, maxDistance: Any, entities: Any, rayCollisionMode: JString? = null, ignorePassableBlocks: JString? = null, fluidCollisionMode: JString? = null) {
val variableForHitLocationARG: Var = when (variableForHitLocation) {
    is Var -> variableForHitLocation
    else -> {
        errorPrint("${currentScope.scope}: В variableRayTraceResult:variableForHitLocation получен тип ${variableForHitLocation.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val variableForHitBlockLocationARG: Var = when (variableForHitBlockLocation) {
    is Var -> variableForHitBlockLocation
    else -> {
        errorPrint("${currentScope.scope}: В variableRayTraceResult:variableForHitBlockLocation получен тип ${variableForHitBlockLocation.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val variableForHitBlockFaceARG: Var = when (variableForHitBlockFace) {
    is Var -> variableForHitBlockFace
    else -> {
        errorPrint("${currentScope.scope}: В variableRayTraceResult:variableForHitBlockFace получен тип ${variableForHitBlockFace.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val variableForHitEntityUuidARG: Var = when (variableForHitEntityUuid) {
    is Var -> variableForHitEntityUuid
    else -> {
        errorPrint("${currentScope.scope}: В variableRayTraceResult:variableForHitEntityUuid получен тип ${variableForHitEntityUuid.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val startARG: JLocation = when (start) {
    is JLocation -> start
    else -> {
        errorPrint("${currentScope.scope}: В variableRayTraceResult:start получен тип ${start.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val raySizeARG: JNumber = when (raySize) {
                is Number -> JNumber(raySize)
is JNumber -> raySize
                else -> {
                    errorPrint("${currentScope.scope}: В variableRayTraceResult:raySize получен тип ${raySize.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val maxDistanceARG: JNumber = when (maxDistance) {
                is Number -> JNumber(maxDistance)
is JNumber -> maxDistance
                else -> {
                    errorPrint("${currentScope.scope}: В variableRayTraceResult:maxDistance получен тип ${maxDistance.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
val entitiesARG: JArray = when (entities) {
    is JArray -> entities
    else -> {
        errorPrint("${currentScope.scope}: В variableRayTraceResult:entities получен тип ${entities.javaClass.kotlin.simpleName}, ожидалось: JArray")
        throw Exception()
    }
}



    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable_for_hit_location"),
    "value" to variableForHitLocationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable_for_hit_block_location"),
    "value" to variableForHitBlockLocationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable_for_hit_block_face"),
    "value" to variableForHitBlockFaceARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable_for_hit_entity_uuid"),
    "value" to variableForHitEntityUuidARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("start"),
    "value" to startARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("ray_size"),
    "value" to raySizeARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("max_distance"),
    "value" to maxDistanceARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("entities"),
    "value" to entitiesARG.parse()
)))
if (rayCollisionMode != null) {
    if (rayCollisionMode.value !in setOf("BLOCKS_AND_ENTITIES", "ONLY_BLOCKS", "ONLY_ENTITIES")) {
        errorPrint("${currentScope.scope}: В функции variableRayTraceResult для аргумента ray_collision_mode получено значение = \"${rayCollisionMode.value}\", ожидалось одно из: \"BLOCKS_AND_ENTITIES\", \"ONLY_BLOCKS\", \"ONLY_ENTITIES\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("ray_collision_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to rayCollisionMode.jsonValue()
        ))
    )))
}
if (ignorePassableBlocks != null) {
    if (ignorePassableBlocks.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции variableRayTraceResult для аргумента ignore_passable_blocks получено значение = \"${ignorePassableBlocks.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("ignore_passable_blocks"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to ignorePassableBlocks.jsonValue()
        ))
    )))
}
if (fluidCollisionMode != null) {
    if (fluidCollisionMode.value !in setOf("ALWAYS", "NEVER", "SOURCE_ONLY")) {
        errorPrint("${currentScope.scope}: В функции variableRayTraceResult для аргумента fluid_collision_mode получено значение = \"${fluidCollisionMode.value}\", ожидалось одно из: \"ALWAYS\", \"NEVER\", \"SOURCE_ONLY\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("fluid_collision_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to fluidCollisionMode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_ray_trace_result"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableReflectVectorProduct(variable: Any, vector1: Any, vector2: Any, bounce: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableReflectVectorProduct:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val vector1ARG: JVector = when (vector1) {
    is JVector -> vector1
    else -> {
        errorPrint("${currentScope.scope}: В variableReflectVectorProduct:vector1 получен тип ${vector1.javaClass.kotlin.simpleName}, ожидалось: JVector")
        throw Exception()
    }
}
val vector2ARG: JVector = when (vector2) {
    is JVector -> vector2
    else -> {
        errorPrint("${currentScope.scope}: В variableReflectVectorProduct:vector2 получен тип ${vector2.javaClass.kotlin.simpleName}, ожидалось: JVector")
        throw Exception()
    }
}
            val bounceARG: JNumber = when (bounce) {
                is Number -> JNumber(bounce)
is JNumber -> bounce
                else -> {
                    errorPrint("${currentScope.scope}: В variableReflectVectorProduct:bounce получен тип ${bounce.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("vector_1"),
    "value" to vector1ARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("vector_2"),
    "value" to vector2ARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("bounce"),
    "value" to bounceARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_reflect_vector_product"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableRegexReplaceText(variable: Any, text: Any, regex: Any, replacement: Any, first: JString? = null, ignoreCase: JString? = null, multiline: JString? = null, literal: JString? = null, unixLines: JString? = null, comments: JString? = null, dotMatchesAll: JString? = null, cannonEq: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableRegexReplaceText:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val textARG: JString = when (text) {
                is String -> JString(text)
is JString -> text
                else -> {
                    errorPrint("${currentScope.scope}: В variableRegexReplaceText:text получен тип ${text.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val regexARG: JString = when (regex) {
                is String -> JString(regex)
is JString -> regex
                else -> {
                    errorPrint("${currentScope.scope}: В variableRegexReplaceText:regex получен тип ${regex.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val replacementARG: JString = when (replacement) {
                is String -> JString(replacement)
is JString -> replacement
                else -> {
                    errorPrint("${currentScope.scope}: В variableRegexReplaceText:replacement получен тип ${replacement.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }








    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("text"),
    "value" to textARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("regex"),
    "value" to regexARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("replacement"),
    "value" to replacementARG.parse()
)))
if (first != null) {
    if (first.value !in setOf("ANY", "FIRST")) {
        errorPrint("${currentScope.scope}: В функции variableRegexReplaceText для аргумента first получено значение = \"${first.value}\", ожидалось одно из: \"ANY\", \"FIRST\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("first"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to first.jsonValue()
        ))
    )))
}
if (ignoreCase != null) {
    if (ignoreCase.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции variableRegexReplaceText для аргумента ignore_case получено значение = \"${ignoreCase.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("ignore_case"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to ignoreCase.jsonValue()
        ))
    )))
}
if (multiline != null) {
    if (multiline.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции variableRegexReplaceText для аргумента multiline получено значение = \"${multiline.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("multiline"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to multiline.jsonValue()
        ))
    )))
}
if (literal != null) {
    if (literal.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции variableRegexReplaceText для аргумента literal получено значение = \"${literal.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("literal"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to literal.jsonValue()
        ))
    )))
}
if (unixLines != null) {
    if (unixLines.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции variableRegexReplaceText для аргумента unix_lines получено значение = \"${unixLines.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("unix_lines"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to unixLines.jsonValue()
        ))
    )))
}
if (comments != null) {
    if (comments.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции variableRegexReplaceText для аргумента comments получено значение = \"${comments.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("comments"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to comments.jsonValue()
        ))
    )))
}
if (dotMatchesAll != null) {
    if (dotMatchesAll.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции variableRegexReplaceText для аргумента dot_matches_all получено значение = \"${dotMatchesAll.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("dot_matches_all"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to dotMatchesAll.jsonValue()
        ))
    )))
}
if (cannonEq != null) {
    if (cannonEq.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции variableRegexReplaceText для аргумента cannon_eq получено значение = \"${cannonEq.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("cannon_eq"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to cannonEq.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_regex_replace_text"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableRemainder(variable: Any, dividend: Any, divisor: Any, remainderMode: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableRemainder:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val dividendARG: JNumber = when (dividend) {
                is Number -> JNumber(dividend)
is JNumber -> dividend
                else -> {
                    errorPrint("${currentScope.scope}: В variableRemainder:dividend получен тип ${dividend.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val divisorARG: JNumber = when (divisor) {
                is Number -> JNumber(divisor)
is JNumber -> divisor
                else -> {
                    errorPrint("${currentScope.scope}: В variableRemainder:divisor получен тип ${divisor.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("dividend"),
    "value" to dividendARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("divisor"),
    "value" to divisorARG.parse()
)))
if (remainderMode != null) {
    if (remainderMode.value !in setOf("MODULO", "REMAINDER")) {
        errorPrint("${currentScope.scope}: В функции variableRemainder для аргумента remainder_mode получено значение = \"${remainderMode.value}\", ожидалось одно из: \"MODULO\", \"REMAINDER\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("remainder_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to remainderMode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_remainder"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableRemoveCompassLodestone(variable: Any, item: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableRemoveCompassLodestone:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В variableRemoveCompassLodestone:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_remove_compass_lodestone"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableRemoveEnchantment(variable: Any, item: Any, enchantment: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableRemoveEnchantment:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В variableRemoveEnchantment:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
            val enchantmentARG: JString = when (enchantment) {
                is String -> JString(enchantment)
is JString -> enchantment
                else -> {
                    errorPrint("${currentScope.scope}: В variableRemoveEnchantment:enchantment получен тип ${enchantment.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("enchantment"),
    "value" to enchantmentARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_remove_enchantment"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableRemoveItemAttribute(variable: Any, item: Any, nameOrUuid: Any, attribute: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableRemoveItemAttribute:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В variableRemoveItemAttribute:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
            val nameOrUuidARG: JString = when (nameOrUuid) {
                is String -> JString(nameOrUuid)
is JString -> nameOrUuid
                else -> {
                    errorPrint("${currentScope.scope}: В variableRemoveItemAttribute:nameOrUuid получен тип ${nameOrUuid.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("name_or_uuid"),
    "value" to nameOrUuidARG.parse()
)))
if (attribute != null) {
    if (attribute.value !in setOf("ARMOR", "ARMOR_TOUGHNESS", "ATTACK_DAMAGE", "ATTACK_KNOCKBACK", "ATTACK_SPEED", "FLYING_SPEED", "FOLLOW_RANGE", "GENERIC_ARMOR", "GENERIC_ARMOR_TOUGHNESS", "GENERIC_ATTACK_DAMAGE", "GENERIC_ATTACK_KNOCKBACK", "GENERIC_ATTACK_SPEED", "GENERIC_BURNING_TIME", "GENERIC_EXPLOSION_KNOCKBACK_RESISTANCE", "GENERIC_FALL_DAMAGE_MULTIPLIER", "GENERIC_FLYING_SPEED", "GENERIC_FOLLOW_RANGE", "GENERIC_GRAVITY", "GENERIC_JUMP_STRENGTH", "GENERIC_KNOCKBACK_RESISTANCE", "GENERIC_LUCK", "GENERIC_MAX_ABSORPTION", "GENERIC_MAX_HEALTH", "GENERIC_MOVEMENT_EFFICIENCY", "GENERIC_MOVEMENT_SPEED", "GENERIC_OXYGEN_BONUS", "GENERIC_SAFE_FALL_DISTANCE", "GENERIC_SCALE", "GENERIC_STEP_HEIGHT", "GENERIC_WATER_MOVEMENT_EFFICIENCY", "HORSE_JUMP_STRENGTH", "KNOCKBACK_RESISTANCE", "LUCK", "MAX_ABSORPTION", "MAX_HEALTH", "MOVEMENT_SPEED", "PLAYER_BLOCK_BREAK_SPEED", "PLAYER_BLOCK_INTERACTION_RANGE", "PLAYER_ENTITY_INTERACTION_RANGE", "PLAYER_MINING_EFFICIENCY", "PLAYER_SNEAKING_SPEED", "PLAYER_SUBMERGED_MINING_SPEED", "PLAYER_SWEEPING_DAMAGE_RATIO", "ZOMBIE_SPAWN_REINFORCEMENTS")) {
        errorPrint("${currentScope.scope}: В функции variableRemoveItemAttribute для аргумента attribute получено значение = \"${attribute.value}\", ожидалось одно из: \"ARMOR\", \"ARMOR_TOUGHNESS\", \"ATTACK_DAMAGE\", \"ATTACK_KNOCKBACK\", \"ATTACK_SPEED\", \"FLYING_SPEED\", \"FOLLOW_RANGE\", \"GENERIC_ARMOR\", \"GENERIC_ARMOR_TOUGHNESS\", \"GENERIC_ATTACK_DAMAGE\", \"GENERIC_ATTACK_KNOCKBACK\", \"GENERIC_ATTACK_SPEED\", \"GENERIC_BURNING_TIME\", \"GENERIC_EXPLOSION_KNOCKBACK_RESISTANCE\", \"GENERIC_FALL_DAMAGE_MULTIPLIER\", \"GENERIC_FLYING_SPEED\", \"GENERIC_FOLLOW_RANGE\", \"GENERIC_GRAVITY\", \"GENERIC_JUMP_STRENGTH\", \"GENERIC_KNOCKBACK_RESISTANCE\", \"GENERIC_LUCK\", \"GENERIC_MAX_ABSORPTION\", \"GENERIC_MAX_HEALTH\", \"GENERIC_MOVEMENT_EFFICIENCY\", \"GENERIC_MOVEMENT_SPEED\", \"GENERIC_OXYGEN_BONUS\", \"GENERIC_SAFE_FALL_DISTANCE\", \"GENERIC_SCALE\", \"GENERIC_STEP_HEIGHT\", \"GENERIC_WATER_MOVEMENT_EFFICIENCY\", \"HORSE_JUMP_STRENGTH\", \"KNOCKBACK_RESISTANCE\", \"LUCK\", \"MAX_ABSORPTION\", \"MAX_HEALTH\", \"MOVEMENT_SPEED\", \"PLAYER_BLOCK_BREAK_SPEED\", \"PLAYER_BLOCK_INTERACTION_RANGE\", \"PLAYER_ENTITY_INTERACTION_RANGE\", \"PLAYER_MINING_EFFICIENCY\", \"PLAYER_SNEAKING_SPEED\", \"PLAYER_SUBMERGED_MINING_SPEED\", \"PLAYER_SWEEPING_DAMAGE_RATIO\", \"ZOMBIE_SPAWN_REINFORCEMENTS\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("attribute"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to attribute.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_remove_item_attribute"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableRemoveItemCustomModelData(variable: Any, item: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableRemoveItemCustomModelData:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В variableRemoveItemCustomModelData:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_remove_item_custom_model_data"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableRemoveItemCustomTag(variable: Any, item: Any, tagName: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableRemoveItemCustomTag:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В variableRemoveItemCustomTag:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
            val tagNameARG: JString = when (tagName) {
                is String -> JString(tagName)
is JString -> tagName
                else -> {
                    errorPrint("${currentScope.scope}: В variableRemoveItemCustomTag:tagName получен тип ${tagName.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("tag_name"),
    "value" to tagNameARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_remove_item_custom_tag"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableRemoveItemLoreLine(variable: Any, item: Any, line: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableRemoveItemLoreLine:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В variableRemoveItemLoreLine:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
            val lineARG: JNumber = when (line) {
                is Number -> JNumber(line)
is JNumber -> line
                else -> {
                    errorPrint("${currentScope.scope}: В variableRemoveItemLoreLine:line получен тип ${line.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("line"),
    "value" to lineARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_remove_item_lore_line"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableRemoveItemPotionEffects(variable: Any, effects: Any, item: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableRemoveItemPotionEffects:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val effectsARG: JPotion = when (effects) {
    is JPotion -> effects
    else -> {
        errorPrint("${currentScope.scope}: В variableRemoveItemPotionEffects:effects получен тип ${effects.javaClass.kotlin.simpleName}, ожидалось: JPotion")
        throw Exception()
    }
}
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В variableRemoveItemPotionEffects:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("effects"),
    "value" to effectsARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_remove_item_potion_effects"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableRemoveListDuplicates(variable: Any, list: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableRemoveListDuplicates:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val listARG: JArray = when (list) {
    is JArray -> list
    else -> {
        errorPrint("${currentScope.scope}: В variableRemoveListDuplicates:list получен тип ${list.javaClass.kotlin.simpleName}, ожидалось: JArray")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("list"),
    "value" to listARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_remove_list_duplicates"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableRemoveListValue(variable: Any, list: Any, value: Any, removeMode: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableRemoveListValue:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val listARG: JArray = when (list) {
    is JArray -> list
    else -> {
        errorPrint("${currentScope.scope}: В variableRemoveListValue:list получен тип ${list.javaClass.kotlin.simpleName}, ожидалось: JArray")
        throw Exception()
    }
}
val valueARG: JAny = when (value) {
    is JAny -> value
    else -> {
        errorPrint("${currentScope.scope}: В variableRemoveListValue:value получен тип ${value.javaClass.kotlin.simpleName}, ожидалось: JAny")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("list"),
    "value" to listARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("value"),
    "value" to valueARG.parse()
)))
if (removeMode != null) {
    if (removeMode.value !in setOf("ALL", "FIRST", "LAST")) {
        errorPrint("${currentScope.scope}: В функции variableRemoveListValue для аргумента remove_mode получено значение = \"${removeMode.value}\", ожидалось одно из: \"ALL\", \"FIRST\", \"LAST\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("remove_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to removeMode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_remove_list_value"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableRemoveListValueAtIndex(removedValue: Any, variable: Any, list: Any, index: Any) {
val removedValueARG: Var = when (removedValue) {
    is Var -> removedValue
    else -> {
        errorPrint("${currentScope.scope}: В variableRemoveListValueAtIndex:removedValue получен тип ${removedValue.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableRemoveListValueAtIndex:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val listARG: JArray = when (list) {
    is JArray -> list
    else -> {
        errorPrint("${currentScope.scope}: В variableRemoveListValueAtIndex:list получен тип ${list.javaClass.kotlin.simpleName}, ожидалось: JArray")
        throw Exception()
    }
}
            val indexARG: JNumber = when (index) {
                is Number -> JNumber(index)
is JNumber -> index
                else -> {
                    errorPrint("${currentScope.scope}: В variableRemoveListValueAtIndex:index получен тип ${index.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("removed_value"),
    "value" to removedValueARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("list"),
    "value" to listARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("index"),
    "value" to indexARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_remove_list_value_at_index"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableRemoveMapEntry(removedValue: Any, variable: Any, map: Any, values: Any, key: Any) {
val removedValueARG: Var = when (removedValue) {
    is Var -> removedValue
    else -> {
        errorPrint("${currentScope.scope}: В variableRemoveMapEntry:removedValue получен тип ${removedValue.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableRemoveMapEntry:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val mapARG: JMap = when (map) {
    is JMap -> map
    else -> {
        errorPrint("${currentScope.scope}: В variableRemoveMapEntry:map получен тип ${map.javaClass.kotlin.simpleName}, ожидалось: JMap")
        throw Exception()
    }
}
val valuesARG: JAny = when (values) {
    is JAny -> values
    else -> {
        errorPrint("${currentScope.scope}: В variableRemoveMapEntry:values получен тип ${values.javaClass.kotlin.simpleName}, ожидалось: JAny")
        throw Exception()
    }
}
val keyARG: JAny = when (key) {
    is JAny -> key
    else -> {
        errorPrint("${currentScope.scope}: В variableRemoveMapEntry:key получен тип ${key.javaClass.kotlin.simpleName}, ожидалось: JAny")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("removed_value"),
    "value" to removedValueARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("map"),
    "value" to mapARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("values"),
    "value" to valuesARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("key"),
    "value" to keyARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_remove_map_entry"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableRemoveText(variable: Any, remove: Any, text: Any, regex: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableRemoveText:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val removeARG: JString = when (remove) {
                is String -> JString(remove)
is JString -> remove
                else -> {
                    errorPrint("${currentScope.scope}: В variableRemoveText:remove получен тип ${remove.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val textARG: JString = when (text) {
                is String -> JString(text)
is JString -> text
                else -> {
                    errorPrint("${currentScope.scope}: В variableRemoveText:text получен тип ${text.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("remove"),
    "value" to removeARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("text"),
    "value" to textARG.parse()
)))
if (regex != null) {
    if (regex.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции variableRemoveText для аргумента regex получено значение = \"${regex.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("regex"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to regex.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_remove_text"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableRepeatText(variable: Any, text: Any, repeat: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableRepeatText:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val textARG: JString = when (text) {
                is String -> JString(text)
is JString -> text
                else -> {
                    errorPrint("${currentScope.scope}: В variableRepeatText:text получен тип ${text.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val repeatARG: JNumber = when (repeat) {
                is Number -> JNumber(repeat)
is JNumber -> repeat
                else -> {
                    errorPrint("${currentScope.scope}: В variableRepeatText:repeat получен тип ${repeat.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("text"),
    "value" to textARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("repeat"),
    "value" to repeatARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_repeat_text"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableReplaceText(variable: Any, text: Any, replace: Any, replacement: Any, first: JString? = null, ignoreCase: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableReplaceText:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val textARG: JString = when (text) {
                is String -> JString(text)
is JString -> text
                else -> {
                    errorPrint("${currentScope.scope}: В variableReplaceText:text получен тип ${text.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val replaceARG: JString = when (replace) {
                is String -> JString(replace)
is JString -> replace
                else -> {
                    errorPrint("${currentScope.scope}: В variableReplaceText:replace получен тип ${replace.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val replacementARG: JString = when (replacement) {
                is String -> JString(replacement)
is JString -> replacement
                else -> {
                    errorPrint("${currentScope.scope}: В variableReplaceText:replacement получен тип ${replacement.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }


    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("text"),
    "value" to textARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("replace"),
    "value" to replaceARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("replacement"),
    "value" to replacementARG.parse()
)))
if (first != null) {
    if (first.value !in setOf("ANY", "FIRST")) {
        errorPrint("${currentScope.scope}: В функции variableReplaceText для аргумента first получено значение = \"${first.value}\", ожидалось одно из: \"ANY\", \"FIRST\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("first"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to first.jsonValue()
        ))
    )))
}
if (ignoreCase != null) {
    if (ignoreCase.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции variableReplaceText для аргумента ignore_case получено значение = \"${ignoreCase.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("ignore_case"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to ignoreCase.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_replace_text"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableReverseList(variable: Any, list: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableReverseList:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val listARG: JArray = when (list) {
    is JArray -> list
    else -> {
        errorPrint("${currentScope.scope}: В variableReverseList:list получен тип ${list.javaClass.kotlin.simpleName}, ожидалось: JArray")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("list"),
    "value" to listARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_reverse_list"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableRoot(variable: Any, base: Any, root: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableRoot:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val baseARG: JNumber = when (base) {
                is Number -> JNumber(base)
is JNumber -> base
                else -> {
                    errorPrint("${currentScope.scope}: В variableRoot:base получен тип ${base.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val rootARG: JNumber = when (root) {
                is Number -> JNumber(root)
is JNumber -> root
                else -> {
                    errorPrint("${currentScope.scope}: В variableRoot:root получен тип ${root.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("base"),
    "value" to baseARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("root"),
    "value" to rootARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_root"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableRotateVectorAroundAxis(variable: Any, vector: Any, angle: Any, axis: JString? = null, angleUnits: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableRotateVectorAroundAxis:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val vectorARG: JVector = when (vector) {
    is JVector -> vector
    else -> {
        errorPrint("${currentScope.scope}: В variableRotateVectorAroundAxis:vector получен тип ${vector.javaClass.kotlin.simpleName}, ожидалось: JVector")
        throw Exception()
    }
}
            val angleARG: JNumber = when (angle) {
                is Number -> JNumber(angle)
is JNumber -> angle
                else -> {
                    errorPrint("${currentScope.scope}: В variableRotateVectorAroundAxis:angle получен тип ${angle.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }


    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("vector"),
    "value" to vectorARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("angle"),
    "value" to angleARG.parse()
)))
if (axis != null) {
    if (axis.value !in setOf("X", "Y", "Z")) {
        errorPrint("${currentScope.scope}: В функции variableRotateVectorAroundAxis для аргумента axis получено значение = \"${axis.value}\", ожидалось одно из: \"X\", \"Y\", \"Z\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("axis"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to axis.jsonValue()
        ))
    )))
}
if (angleUnits != null) {
    if (angleUnits.value !in setOf("DEGREES", "RADIANS")) {
        errorPrint("${currentScope.scope}: В функции variableRotateVectorAroundAxis для аргумента angle_units получено значение = \"${angleUnits.value}\", ожидалось одно из: \"DEGREES\", \"RADIANS\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("angle_units"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to angleUnits.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_rotate_vector_around_axis"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableRotateVectorAroundVector(variable: Any, rotatingVector: Any, axisVector: Any, angle: Any, angleUnits: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableRotateVectorAroundVector:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val rotatingVectorARG: JVector = when (rotatingVector) {
    is JVector -> rotatingVector
    else -> {
        errorPrint("${currentScope.scope}: В variableRotateVectorAroundVector:rotatingVector получен тип ${rotatingVector.javaClass.kotlin.simpleName}, ожидалось: JVector")
        throw Exception()
    }
}
val axisVectorARG: JVector = when (axisVector) {
    is JVector -> axisVector
    else -> {
        errorPrint("${currentScope.scope}: В variableRotateVectorAroundVector:axisVector получен тип ${axisVector.javaClass.kotlin.simpleName}, ожидалось: JVector")
        throw Exception()
    }
}
            val angleARG: JNumber = when (angle) {
                is Number -> JNumber(angle)
is JNumber -> angle
                else -> {
                    errorPrint("${currentScope.scope}: В variableRotateVectorAroundVector:angle получен тип ${angle.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("rotating_vector"),
    "value" to rotatingVectorARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("axis_vector"),
    "value" to axisVectorARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("angle"),
    "value" to angleARG.parse()
)))
if (angleUnits != null) {
    if (angleUnits.value !in setOf("DEGREES", "RADIANS")) {
        errorPrint("${currentScope.scope}: В функции variableRotateVectorAroundVector для аргумента angle_units получено значение = \"${angleUnits.value}\", ожидалось одно из: \"DEGREES\", \"RADIANS\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("angle_units"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to angleUnits.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_rotate_vector_around_vector"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableRound(variable: Any, number: Any, precision: Any, roundType: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableRound:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val numberARG: JNumber = when (number) {
                is Number -> JNumber(number)
is JNumber -> number
                else -> {
                    errorPrint("${currentScope.scope}: В variableRound:number получен тип ${number.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val precisionARG: JNumber = when (precision) {
                is Number -> JNumber(precision)
is JNumber -> precision
                else -> {
                    errorPrint("${currentScope.scope}: В variableRound:precision получен тип ${precision.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("number"),
    "value" to numberARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("precision"),
    "value" to precisionARG.parse()
)))
if (roundType != null) {
    if (roundType.value !in setOf("CEIL", "FLOOR", "ROUND")) {
        errorPrint("${currentScope.scope}: В функции variableRound для аргумента round_type получено значение = \"${roundType.value}\", ожидалось одно из: \"CEIL\", \"FLOOR\", \"ROUND\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("round_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to roundType.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_round"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetAllCoordinates(variable: Any, x: Any, y: Any, z: Any, yaw: Any, pitch: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetAllCoordinates:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val xARG: JNumber = when (x) {
                is Number -> JNumber(x)
is JNumber -> x
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetAllCoordinates:x получен тип ${x.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val yARG: JNumber = when (y) {
                is Number -> JNumber(y)
is JNumber -> y
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetAllCoordinates:y получен тип ${y.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val zARG: JNumber = when (z) {
                is Number -> JNumber(z)
is JNumber -> z
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetAllCoordinates:z получен тип ${z.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val yawARG: JNumber = when (yaw) {
                is Number -> JNumber(yaw)
is JNumber -> yaw
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetAllCoordinates:yaw получен тип ${yaw.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val pitchARG: JNumber = when (pitch) {
                is Number -> JNumber(pitch)
is JNumber -> pitch
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetAllCoordinates:pitch получен тип ${pitch.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("x"),
    "value" to xARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("y"),
    "value" to yARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("z"),
    "value" to zARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("yaw"),
    "value" to yawARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("pitch"),
    "value" to pitchARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_all_coordinates"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetArmorTrim(variable: Any, armor: Any, material: Any, pattern: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetArmorTrim:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val armorARG: JItem = when (armor) {
    is JItem -> armor
    else -> {
        errorPrint("${currentScope.scope}: В variableSetArmorTrim:armor получен тип ${armor.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
val materialARG: JItem = when (material) {
    is JItem -> material
    else -> {
        errorPrint("${currentScope.scope}: В variableSetArmorTrim:material получен тип ${material.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
val patternARG: JItem = when (pattern) {
    is JItem -> pattern
    else -> {
        errorPrint("${currentScope.scope}: В variableSetArmorTrim:pattern получен тип ${pattern.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("armor"),
    "value" to armorARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("material"),
    "value" to materialARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("pattern"),
    "value" to patternARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_armor_trim"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetBookPage(variable: Any, book: Any, text: Any, page: Any, mode: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetBookPage:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val bookARG: JItem = when (book) {
    is JItem -> book
    else -> {
        errorPrint("${currentScope.scope}: В variableSetBookPage:book получен тип ${book.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
            val textARG: JString = when (text) {
                is String -> JString(text)
is JString -> text
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetBookPage:text получен тип ${text.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val pageARG: JNumber = when (page) {
                is Number -> JNumber(page)
is JNumber -> page
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetBookPage:page получен тип ${page.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("book"),
    "value" to bookARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("text"),
    "value" to textARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("page"),
    "value" to pageARG.parse()
)))
if (mode != null) {
    if (mode.value !in setOf("APPEND", "MERGE")) {
        errorPrint("${currentScope.scope}: В функции variableSetBookPage для аргумента mode получено значение = \"${mode.value}\", ожидалось одно из: \"APPEND\", \"MERGE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to mode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_book_page"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetBookPages(variable: Any, book: Any, text: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetBookPages:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val bookARG: JItem = when (book) {
    is JItem -> book
    else -> {
        errorPrint("${currentScope.scope}: В variableSetBookPages:book получен тип ${book.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
            val textARG: JString = when (text) {
                is String -> JString(text)
is JString -> text
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetBookPages:text получен тип ${text.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("book"),
    "value" to bookARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("text"),
    "value" to textARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_book_pages"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetBundleItems(variable: Any, items: Any, bundle: Any, settingMode: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetBundleItems:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val itemsARG: JItem = when (items) {
    is JItem -> items
    else -> {
        errorPrint("${currentScope.scope}: В variableSetBundleItems:items получен тип ${items.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
val bundleARG: JItem = when (bundle) {
    is JItem -> bundle
    else -> {
        errorPrint("${currentScope.scope}: В variableSetBundleItems:bundle получен тип ${bundle.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("items"),
    "value" to itemsARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("bundle"),
    "value" to bundleARG.parse()
)))
if (settingMode != null) {
    if (settingMode.value !in setOf("ADD", "REMOVE", "SET")) {
        errorPrint("${currentScope.scope}: В функции variableSetBundleItems для аргумента setting_mode получено значение = \"${settingMode.value}\", ожидалось одно из: \"ADD\", \"REMOVE\", \"SET\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("setting_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to settingMode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_bundle_items"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetCompassLodestone(variable: Any, item: Any, location: Any, tracked: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetCompassLodestone:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В variableSetCompassLodestone:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В variableSetCompassLodestone:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
if (tracked != null) {
    if (tracked.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции variableSetCompassLodestone для аргумента tracked получено значение = \"${tracked.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("tracked"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to tracked.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_compass_lodestone"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetComponentChildren(variable: Any, component: Any, children: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetComponentChildren:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val componentARG: JString = when (component) {
                is String -> JString(component)
is JString -> component
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetComponentChildren:component получен тип ${component.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val childrenARG: JString = when (children) {
                is String -> JString(children)
is JString -> children
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetComponentChildren:children получен тип ${children.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("component"),
    "value" to componentARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("children"),
    "value" to childrenARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_component_children"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetComponentClick(variable: Any, component: Any, value: Any, clickAction: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetComponentClick:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val componentARG: JString = when (component) {
                is String -> JString(component)
is JString -> component
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetComponentClick:component получен тип ${component.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val valueARG: JString = when (value) {
                is String -> JString(value)
is JString -> value
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetComponentClick:value получен тип ${value.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("component"),
    "value" to componentARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("value"),
    "value" to valueARG.parse()
)))
if (clickAction != null) {
    if (clickAction.value !in setOf("CHANGE_PAGE", "COPY_TO_CLIPBOARD", "COPY_TO_CLIPBORD", "OPEN_URL", "SUGGEST_COMMAND")) {
        errorPrint("${currentScope.scope}: В функции variableSetComponentClick для аргумента click_action получено значение = \"${clickAction.value}\", ожидалось одно из: \"CHANGE_PAGE\", \"COPY_TO_CLIPBOARD\", \"COPY_TO_CLIPBORD\", \"OPEN_URL\", \"SUGGEST_COMMAND\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("click_action"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to clickAction.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_component_click"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetComponentDecorations(variable: Any, component: Any, bold: JString? = null, italic: JString? = null, underlined: JString? = null, strikethrough: JString? = null, obfuscated: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetComponentDecorations:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val componentARG: JString = when (component) {
                is String -> JString(component)
is JString -> component
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetComponentDecorations:component получен тип ${component.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }





    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("component"),
    "value" to componentARG.parse()
)))
if (bold != null) {
    if (bold.value !in setOf("FALSE", "NOT_SET", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции variableSetComponentDecorations для аргумента bold получено значение = \"${bold.value}\", ожидалось одно из: \"FALSE\", \"NOT_SET\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("bold"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to bold.jsonValue()
        ))
    )))
}
if (italic != null) {
    if (italic.value !in setOf("FALSE", "NOT_SET", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции variableSetComponentDecorations для аргумента italic получено значение = \"${italic.value}\", ожидалось одно из: \"FALSE\", \"NOT_SET\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("italic"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to italic.jsonValue()
        ))
    )))
}
if (underlined != null) {
    if (underlined.value !in setOf("FALSE", "NOT_SET", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции variableSetComponentDecorations для аргумента underlined получено значение = \"${underlined.value}\", ожидалось одно из: \"FALSE\", \"NOT_SET\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("underlined"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to underlined.jsonValue()
        ))
    )))
}
if (strikethrough != null) {
    if (strikethrough.value !in setOf("FALSE", "NOT_SET", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции variableSetComponentDecorations для аргумента strikethrough получено значение = \"${strikethrough.value}\", ожидалось одно из: \"FALSE\", \"NOT_SET\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("strikethrough"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to strikethrough.jsonValue()
        ))
    )))
}
if (obfuscated != null) {
    if (obfuscated.value !in setOf("FALSE", "NOT_SET", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции variableSetComponentDecorations для аргумента obfuscated получено значение = \"${obfuscated.value}\", ожидалось одно из: \"FALSE\", \"NOT_SET\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("obfuscated"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to obfuscated.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_component_decorations"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetComponentEntityHover(variable: Any, component: Any, nameOrUuid: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetComponentEntityHover:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val componentARG: JString = when (component) {
                is String -> JString(component)
is JString -> component
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetComponentEntityHover:component получен тип ${component.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val nameOrUuidARG: JString = when (nameOrUuid) {
                is String -> JString(nameOrUuid)
is JString -> nameOrUuid
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetComponentEntityHover:nameOrUuid получен тип ${nameOrUuid.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("component"),
    "value" to componentARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("name_or_uuid"),
    "value" to nameOrUuidARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_component_entity_hover"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetComponentFont(variable: Any, component: Any, namespace: Any, value: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetComponentFont:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val componentARG: JString = when (component) {
                is String -> JString(component)
is JString -> component
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetComponentFont:component получен тип ${component.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val namespaceARG: JString = when (namespace) {
                is String -> JString(namespace)
is JString -> namespace
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetComponentFont:namespace получен тип ${namespace.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val valueARG: JString = when (value) {
                is String -> JString(value)
is JString -> value
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetComponentFont:value получен тип ${value.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("component"),
    "value" to componentARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("namespace"),
    "value" to namespaceARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("value"),
    "value" to valueARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_component_font"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetComponentHexColor(variable: Any, component: Any, color: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetComponentHexColor:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val componentARG: JString = when (component) {
                is String -> JString(component)
is JString -> component
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetComponentHexColor:component получен тип ${component.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val colorARG: JString = when (color) {
                is String -> JString(color)
is JString -> color
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetComponentHexColor:color получен тип ${color.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("component"),
    "value" to componentARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("color"),
    "value" to colorARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_component_hex_color"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetComponentHover(variable: Any, component: Any, hover: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetComponentHover:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val componentARG: JString = when (component) {
                is String -> JString(component)
is JString -> component
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetComponentHover:component получен тип ${component.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val hoverARG: JString = when (hover) {
                is String -> JString(hover)
is JString -> hover
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetComponentHover:hover получен тип ${hover.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("component"),
    "value" to componentARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("hover"),
    "value" to hoverARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_component_hover"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetComponentInsertion(variable: Any, component: Any, insertion: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetComponentInsertion:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val componentARG: JString = when (component) {
                is String -> JString(component)
is JString -> component
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetComponentInsertion:component получен тип ${component.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val insertionARG: JString = when (insertion) {
                is String -> JString(insertion)
is JString -> insertion
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetComponentInsertion:insertion получен тип ${insertion.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("component"),
    "value" to componentARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("insertion"),
    "value" to insertionARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_component_insertion"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetComponentItemHover(variable: Any, component: Any, hover: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetComponentItemHover:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val componentARG: JString = when (component) {
                is String -> JString(component)
is JString -> component
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetComponentItemHover:component получен тип ${component.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
val hoverARG: JItem = when (hover) {
    is JItem -> hover
    else -> {
        errorPrint("${currentScope.scope}: В variableSetComponentItemHover:hover получен тип ${hover.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("component"),
    "value" to componentARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("hover"),
    "value" to hoverARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_component_item_hover"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetCoordinate(variable: Any, location: Any, coordinate: Any, type: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetCoordinate:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В variableSetCoordinate:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val coordinateARG: JNumber = when (coordinate) {
                is Number -> JNumber(coordinate)
is JNumber -> coordinate
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetCoordinate:coordinate получен тип ${coordinate.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("coordinate"),
    "value" to coordinateARG.parse()
)))
if (type != null) {
    if (type.value !in setOf("PITCH", "X", "Y", "YAW", "Z")) {
        errorPrint("${currentScope.scope}: В функции variableSetCoordinate для аргумента type получено значение = \"${type.value}\", ожидалось одно из: \"PITCH\", \"X\", \"Y\", \"YAW\", \"Z\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to type.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_coordinate"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetItemAmount(variable: Any, item: Any, amount: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetItemAmount:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В variableSetItemAmount:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
            val amountARG: JNumber = when (amount) {
                is Number -> JNumber(amount)
is JNumber -> amount
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetItemAmount:amount получен тип ${amount.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("amount"),
    "value" to amountARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_item_amount"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetItemAttribute(variable: Any, item: Any, amount: Any, name: Any, attribute: JString? = null, slot: JString? = null, operation: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetItemAttribute:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В variableSetItemAttribute:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
            val amountARG: JNumber = when (amount) {
                is Number -> JNumber(amount)
is JNumber -> amount
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetItemAttribute:amount получен тип ${amount.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val nameARG: JString = when (name) {
                is String -> JString(name)
is JString -> name
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetItemAttribute:name получен тип ${name.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }



    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("amount"),
    "value" to amountARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("name"),
    "value" to nameARG.parse()
)))
if (attribute != null) {
    if (attribute.value !in setOf("ARMOR", "ARMOR_TOUGHNESS", "ATTACK_DAMAGE", "ATTACK_KNOCKBACK", "ATTACK_SPEED", "FLYING_SPEED", "FOLLOW_RANGE", "GENERIC_ARMOR", "GENERIC_ARMOR_TOUGHNESS", "GENERIC_ATTACK_DAMAGE", "GENERIC_ATTACK_KNOCKBACK", "GENERIC_ATTACK_SPEED", "GENERIC_BURNING_TIME", "GENERIC_EXPLOSION_KNOCKBACK_RESISTANCE", "GENERIC_FALL_DAMAGE_MULTIPLIER", "GENERIC_FLYING_SPEED", "GENERIC_FOLLOW_RANGE", "GENERIC_GRAVITY", "GENERIC_JUMP_STRENGTH", "GENERIC_KNOCKBACK_RESISTANCE", "GENERIC_LUCK", "GENERIC_MAX_ABSORPTION", "GENERIC_MAX_HEALTH", "GENERIC_MOVEMENT_EFFICIENCY", "GENERIC_MOVEMENT_SPEED", "GENERIC_OXYGEN_BONUS", "GENERIC_SAFE_FALL_DISTANCE", "GENERIC_SCALE", "GENERIC_STEP_HEIGHT", "GENERIC_WATER_MOVEMENT_EFFICIENCY", "HORSE_JUMP_STRENGTH", "KNOCKBACK_RESISTANCE", "LUCK", "MAX_ABSORPTION", "MAX_HEALTH", "MOVEMENT_SPEED", "PLAYER_BLOCK_BREAK_SPEED", "PLAYER_BLOCK_INTERACTION_RANGE", "PLAYER_ENTITY_INTERACTION_RANGE", "PLAYER_MINING_EFFICIENCY", "PLAYER_SNEAKING_SPEED", "PLAYER_SUBMERGED_MINING_SPEED", "PLAYER_SWEEPING_DAMAGE_RATIO", "ZOMBIE_SPAWN_REINFORCEMENTS")) {
        errorPrint("${currentScope.scope}: В функции variableSetItemAttribute для аргумента attribute получено значение = \"${attribute.value}\", ожидалось одно из: \"ARMOR\", \"ARMOR_TOUGHNESS\", \"ATTACK_DAMAGE\", \"ATTACK_KNOCKBACK\", \"ATTACK_SPEED\", \"FLYING_SPEED\", \"FOLLOW_RANGE\", \"GENERIC_ARMOR\", \"GENERIC_ARMOR_TOUGHNESS\", \"GENERIC_ATTACK_DAMAGE\", \"GENERIC_ATTACK_KNOCKBACK\", \"GENERIC_ATTACK_SPEED\", \"GENERIC_BURNING_TIME\", \"GENERIC_EXPLOSION_KNOCKBACK_RESISTANCE\", \"GENERIC_FALL_DAMAGE_MULTIPLIER\", \"GENERIC_FLYING_SPEED\", \"GENERIC_FOLLOW_RANGE\", \"GENERIC_GRAVITY\", \"GENERIC_JUMP_STRENGTH\", \"GENERIC_KNOCKBACK_RESISTANCE\", \"GENERIC_LUCK\", \"GENERIC_MAX_ABSORPTION\", \"GENERIC_MAX_HEALTH\", \"GENERIC_MOVEMENT_EFFICIENCY\", \"GENERIC_MOVEMENT_SPEED\", \"GENERIC_OXYGEN_BONUS\", \"GENERIC_SAFE_FALL_DISTANCE\", \"GENERIC_SCALE\", \"GENERIC_STEP_HEIGHT\", \"GENERIC_WATER_MOVEMENT_EFFICIENCY\", \"HORSE_JUMP_STRENGTH\", \"KNOCKBACK_RESISTANCE\", \"LUCK\", \"MAX_ABSORPTION\", \"MAX_HEALTH\", \"MOVEMENT_SPEED\", \"PLAYER_BLOCK_BREAK_SPEED\", \"PLAYER_BLOCK_INTERACTION_RANGE\", \"PLAYER_ENTITY_INTERACTION_RANGE\", \"PLAYER_MINING_EFFICIENCY\", \"PLAYER_SNEAKING_SPEED\", \"PLAYER_SUBMERGED_MINING_SPEED\", \"PLAYER_SWEEPING_DAMAGE_RATIO\", \"ZOMBIE_SPAWN_REINFORCEMENTS\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("attribute"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to attribute.jsonValue()
        ))
    )))
}
if (slot != null) {
    if (slot.value !in setOf("ALL", "ARMOR", "BODY", "BOOTS", "CHEST", "HAND", "HEAD", "LEGGINGS", "MAIN_HAND", "OFF_HAND")) {
        errorPrint("${currentScope.scope}: В функции variableSetItemAttribute для аргумента slot получено значение = \"${slot.value}\", ожидалось одно из: \"ALL\", \"ARMOR\", \"BODY\", \"BOOTS\", \"CHEST\", \"HAND\", \"HEAD\", \"LEGGINGS\", \"MAIN_HAND\", \"OFF_HAND\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("slot"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to slot.jsonValue()
        ))
    )))
}
if (operation != null) {
    if (operation.value !in setOf("ADD_NUMBER", "ADD_SCALAR", "MULTIPLY_SCALAR_1")) {
        errorPrint("${currentScope.scope}: В функции variableSetItemAttribute для аргумента operation получено значение = \"${operation.value}\", ожидалось одно из: \"ADD_NUMBER\", \"ADD_SCALAR\", \"MULTIPLY_SCALAR_1\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("operation"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to operation.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_item_attribute"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetItemColor(variable: Any, item: Any, color: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetItemColor:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В variableSetItemColor:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
            val colorARG: JString = when (color) {
                is String -> JString(color)
is JString -> color
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetItemColor:color получен тип ${color.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("color"),
    "value" to colorARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_item_color"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetItemComponent(variable: Any, item: Any, component: Any, value: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetItemComponent:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В variableSetItemComponent:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
            val componentARG: JString = when (component) {
                is String -> JString(component)
is JString -> component
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetItemComponent:component получен тип ${component.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
val valueARG: JAny = when (value) {
    is JAny -> value
    else -> {
        errorPrint("${currentScope.scope}: В variableSetItemComponent:value получен тип ${value.javaClass.kotlin.simpleName}, ожидалось: JAny")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("component"),
    "value" to componentARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("value"),
    "value" to valueARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_item_component"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetItemCustomModelData(variable: Any, item: Any, model: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetItemCustomModelData:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В variableSetItemCustomModelData:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
            val modelARG: JNumber = when (model) {
                is Number -> JNumber(model)
is JNumber -> model
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetItemCustomModelData:model получен тип ${model.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("model"),
    "value" to modelARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_item_custom_model_data"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetItemCustomTag(variable: Any, item: Any, tagName: Any, tagValue: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetItemCustomTag:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В variableSetItemCustomTag:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
            val tagNameARG: JString = when (tagName) {
                is String -> JString(tagName)
is JString -> tagName
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetItemCustomTag:tagName получен тип ${tagName.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val tagValueARG: JString = when (tagValue) {
                is String -> JString(tagValue)
is JString -> tagValue
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetItemCustomTag:tagValue получен тип ${tagValue.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("tag_name"),
    "value" to tagNameARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("tag_value"),
    "value" to tagValueARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_item_custom_tag"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetItemDestroyableBlocks(variable: Any, destroyable: Any, item: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetItemDestroyableBlocks:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val destroyableARG: JItem = when (destroyable) {
    is JItem -> destroyable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetItemDestroyableBlocks:destroyable получен тип ${destroyable.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В variableSetItemDestroyableBlocks:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("destroyable"),
    "value" to destroyableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_item_destroyable_blocks"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetItemDurability(variable: Any, item: Any, durability: Any, durabilityType: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetItemDurability:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В variableSetItemDurability:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
            val durabilityARG: JNumber = when (durability) {
                is Number -> JNumber(durability)
is JNumber -> durability
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetItemDurability:durability получен тип ${durability.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("durability"),
    "value" to durabilityARG.parse()
)))
if (durabilityType != null) {
    if (durabilityType.value !in setOf("DAMAGE", "DAMAGE_PERCENTAGE", "MAXIMUM", "REMAINING", "REMAINING_PERCENTAGE")) {
        errorPrint("${currentScope.scope}: В функции variableSetItemDurability для аргумента durability_type получено значение = \"${durabilityType.value}\", ожидалось одно из: \"DAMAGE\", \"DAMAGE_PERCENTAGE\", \"MAXIMUM\", \"REMAINING\", \"REMAINING_PERCENTAGE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("durability_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to durabilityType.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_item_durability"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetItemEnchantments(variable: Any, item: Any, enchantments: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetItemEnchantments:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В variableSetItemEnchantments:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
val enchantmentsARG: JMap = when (enchantments) {
    is JMap -> enchantments
    else -> {
        errorPrint("${currentScope.scope}: В variableSetItemEnchantments:enchantments получен тип ${enchantments.javaClass.kotlin.simpleName}, ожидалось: JMap")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("enchantments"),
    "value" to enchantmentsARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_item_enchantments"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetItemLore(variable: Any, lore: Any, item: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetItemLore:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val loreARG: JString = when (lore) {
                is String -> JString(lore)
is JString -> lore
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetItemLore:lore получен тип ${lore.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В variableSetItemLore:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("lore"),
    "value" to loreARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_item_lore"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetItemLoreLine(variable: Any, item: Any, text: Any, line: Any, mode: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetItemLoreLine:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В variableSetItemLoreLine:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
            val textARG: JString = when (text) {
                is String -> JString(text)
is JString -> text
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetItemLoreLine:text получен тип ${text.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val lineARG: JNumber = when (line) {
                is Number -> JNumber(line)
is JNumber -> line
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetItemLoreLine:line получен тип ${line.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("text"),
    "value" to textARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("line"),
    "value" to lineARG.parse()
)))
if (mode != null) {
    if (mode.value !in setOf("APPEND", "MERGE")) {
        errorPrint("${currentScope.scope}: В функции variableSetItemLoreLine для аргумента mode получено значение = \"${mode.value}\", ожидалось одно из: \"APPEND\", \"MERGE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to mode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_item_lore_line"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetItemMaxStackSize(variable: Any, item: Any, size: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetItemMaxStackSize:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В variableSetItemMaxStackSize:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
            val sizeARG: JNumber = when (size) {
                is Number -> JNumber(size)
is JNumber -> size
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetItemMaxStackSize:size получен тип ${size.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("size"),
    "value" to sizeARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_item_max_stack_size"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetItemName(variable: Any, item: Any, text: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetItemName:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В variableSetItemName:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
            val textARG: JString = when (text) {
                is String -> JString(text)
is JString -> text
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetItemName:text получен тип ${text.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("text"),
    "value" to textARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_item_name"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetItemPlaceableBlocks(variable: Any, placeable: Any, item: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetItemPlaceableBlocks:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val placeableARG: JItem = when (placeable) {
    is JItem -> placeable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetItemPlaceableBlocks:placeable получен тип ${placeable.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В variableSetItemPlaceableBlocks:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("placeable"),
    "value" to placeableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_item_placeable_blocks"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetItemType(variable: Any, item: Any, type: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetItemType:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В variableSetItemType:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
            val typeARG: JString = when (type) {
                is String -> JString(type)
is JString -> type
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetItemType:type получен тип ${type.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("type"),
    "value" to typeARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_item_type"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetItemUnbreakable(variable: Any, item: Any, unbreakable: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetItemUnbreakable:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В variableSetItemUnbreakable:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
if (unbreakable != null) {
    if (unbreakable.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции variableSetItemUnbreakable для аргумента unbreakable получено значение = \"${unbreakable.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("unbreakable"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to unbreakable.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_item_unbreakable"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetItemVisibilityFlags(variable: Any, item: Any, hideDye: JString? = null, hideEnchantments: JString? = null, hideAttributes: JString? = null, hideUnbreakable: JString? = null, hidePlaceOn: JString? = null, hideDestroys: JString? = null, hidePotionEffects: JString? = null, hideArmorTrim: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetItemVisibilityFlags:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val itemARG: JItem = when (item) {
    is JItem -> item
    else -> {
        errorPrint("${currentScope.scope}: В variableSetItemVisibilityFlags:item получен тип ${item.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}








    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("item"),
    "value" to itemARG.parse()
)))
if (hideDye != null) {
    if (hideDye.value !in setOf("NO_CHANGE", "OFF", "ON")) {
        errorPrint("${currentScope.scope}: В функции variableSetItemVisibilityFlags для аргумента hide_dye получено значение = \"${hideDye.value}\", ожидалось одно из: \"NO_CHANGE\", \"OFF\", \"ON\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("hide_dye"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to hideDye.jsonValue()
        ))
    )))
}
if (hideEnchantments != null) {
    if (hideEnchantments.value !in setOf("NO_CHANGE", "OFF", "ON")) {
        errorPrint("${currentScope.scope}: В функции variableSetItemVisibilityFlags для аргумента hide_enchantments получено значение = \"${hideEnchantments.value}\", ожидалось одно из: \"NO_CHANGE\", \"OFF\", \"ON\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("hide_enchantments"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to hideEnchantments.jsonValue()
        ))
    )))
}
if (hideAttributes != null) {
    if (hideAttributes.value !in setOf("NO_CHANGE", "OFF", "ON")) {
        errorPrint("${currentScope.scope}: В функции variableSetItemVisibilityFlags для аргумента hide_attributes получено значение = \"${hideAttributes.value}\", ожидалось одно из: \"NO_CHANGE\", \"OFF\", \"ON\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("hide_attributes"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to hideAttributes.jsonValue()
        ))
    )))
}
if (hideUnbreakable != null) {
    if (hideUnbreakable.value !in setOf("NO_CHANGE", "OFF", "ON")) {
        errorPrint("${currentScope.scope}: В функции variableSetItemVisibilityFlags для аргумента hide_unbreakable получено значение = \"${hideUnbreakable.value}\", ожидалось одно из: \"NO_CHANGE\", \"OFF\", \"ON\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("hide_unbreakable"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to hideUnbreakable.jsonValue()
        ))
    )))
}
if (hidePlaceOn != null) {
    if (hidePlaceOn.value !in setOf("NO_CHANGE", "OFF", "ON")) {
        errorPrint("${currentScope.scope}: В функции variableSetItemVisibilityFlags для аргумента hide_place_on получено значение = \"${hidePlaceOn.value}\", ожидалось одно из: \"NO_CHANGE\", \"OFF\", \"ON\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("hide_place_on"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to hidePlaceOn.jsonValue()
        ))
    )))
}
if (hideDestroys != null) {
    if (hideDestroys.value !in setOf("NO_CHANGE", "OFF", "ON")) {
        errorPrint("${currentScope.scope}: В функции variableSetItemVisibilityFlags для аргумента hide_destroys получено значение = \"${hideDestroys.value}\", ожидалось одно из: \"NO_CHANGE\", \"OFF\", \"ON\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("hide_destroys"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to hideDestroys.jsonValue()
        ))
    )))
}
if (hidePotionEffects != null) {
    if (hidePotionEffects.value !in setOf("NO_CHANGE", "OFF", "ON")) {
        errorPrint("${currentScope.scope}: В функции variableSetItemVisibilityFlags для аргумента hide_potion_effects получено значение = \"${hidePotionEffects.value}\", ожидалось одно из: \"NO_CHANGE\", \"OFF\", \"ON\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("hide_potion_effects"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to hidePotionEffects.jsonValue()
        ))
    )))
}
if (hideArmorTrim != null) {
    if (hideArmorTrim.value !in setOf("NO_CHANGE", "OFF", "ON")) {
        errorPrint("${currentScope.scope}: В функции variableSetItemVisibilityFlags для аргумента hide_armor_trim получено значение = \"${hideArmorTrim.value}\", ожидалось одно из: \"NO_CHANGE\", \"OFF\", \"ON\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("hide_armor_trim"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to hideArmorTrim.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_item_visibility_flags"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetListValue(variable: Any, list: Any, number: Any, value: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetListValue:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val listARG: JArray = when (list) {
    is JArray -> list
    else -> {
        errorPrint("${currentScope.scope}: В variableSetListValue:list получен тип ${list.javaClass.kotlin.simpleName}, ожидалось: JArray")
        throw Exception()
    }
}
            val numberARG: JNumber = when (number) {
                is Number -> JNumber(number)
is JNumber -> number
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetListValue:number получен тип ${number.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
val valueARG: JAny = when (value) {
    is JAny -> value
    else -> {
        errorPrint("${currentScope.scope}: В variableSetListValue:value получен тип ${value.javaClass.kotlin.simpleName}, ожидалось: JAny")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("list"),
    "value" to listARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("number"),
    "value" to numberARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("value"),
    "value" to valueARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_list_value"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetLocationDirection(variable: Any, location: Any, vector: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetLocationDirection:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В variableSetLocationDirection:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
val vectorARG: JVector = when (vector) {
    is JVector -> vector
    else -> {
        errorPrint("${currentScope.scope}: В variableSetLocationDirection:vector получен тип ${vector.javaClass.kotlin.simpleName}, ожидалось: JVector")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("vector"),
    "value" to vectorARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_location_direction"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetMapValue(variable: Any, map: Any, key: Any, value: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetMapValue:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val mapARG: JMap = when (map) {
    is JMap -> map
    else -> {
        errorPrint("${currentScope.scope}: В variableSetMapValue:map получен тип ${map.javaClass.kotlin.simpleName}, ожидалось: JMap")
        throw Exception()
    }
}
val keyARG: JAny = when (key) {
    is JAny -> key
    else -> {
        errorPrint("${currentScope.scope}: В variableSetMapValue:key получен тип ${key.javaClass.kotlin.simpleName}, ожидалось: JAny")
        throw Exception()
    }
}
val valueARG: JAny = when (value) {
    is JAny -> value
    else -> {
        errorPrint("${currentScope.scope}: В variableSetMapValue:value получен тип ${value.javaClass.kotlin.simpleName}, ожидалось: JAny")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("map"),
    "value" to mapARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("key"),
    "value" to keyARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("value"),
    "value" to valueARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_map_value"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetParticleAmount(variable: Any, particle: Any, amount: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetParticleAmount:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val particleARG: JParticle = when (particle) {
    is JParticle -> particle
    else -> {
        errorPrint("${currentScope.scope}: В variableSetParticleAmount:particle получен тип ${particle.javaClass.kotlin.simpleName}, ожидалось: JParticle")
        throw Exception()
    }
}
            val amountARG: JNumber = when (amount) {
                is Number -> JNumber(amount)
is JNumber -> amount
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetParticleAmount:amount получен тип ${amount.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("particle"),
    "value" to particleARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("amount"),
    "value" to amountARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_particle_amount"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetParticleColor(variable: Any, particle: Any, hexColor: Any, colorType: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetParticleColor:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val particleARG: JParticle = when (particle) {
    is JParticle -> particle
    else -> {
        errorPrint("${currentScope.scope}: В variableSetParticleColor:particle получен тип ${particle.javaClass.kotlin.simpleName}, ожидалось: JParticle")
        throw Exception()
    }
}
            val hexColorARG: JString = when (hexColor) {
                is String -> JString(hexColor)
is JString -> hexColor
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetParticleColor:hexColor получен тип ${hexColor.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("particle"),
    "value" to particleARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("hex_color"),
    "value" to hexColorARG.parse()
)))
if (colorType != null) {
    if (colorType.value !in setOf("COLOR", "TO_COLOR")) {
        errorPrint("${currentScope.scope}: В функции variableSetParticleColor для аргумента color_type получено значение = \"${colorType.value}\", ожидалось одно из: \"COLOR\", \"TO_COLOR\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("color_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to colorType.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_particle_color"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetParticleMaterial(variable: Any, particle: Any, material: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetParticleMaterial:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val particleARG: JParticle = when (particle) {
    is JParticle -> particle
    else -> {
        errorPrint("${currentScope.scope}: В variableSetParticleMaterial:particle получен тип ${particle.javaClass.kotlin.simpleName}, ожидалось: JParticle")
        throw Exception()
    }
}
val materialARG: JItem = when (material) {
    is JItem -> material
    else -> {
        errorPrint("${currentScope.scope}: В variableSetParticleMaterial:material получен тип ${material.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("particle"),
    "value" to particleARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("material"),
    "value" to materialARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_particle_material"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetParticleOffset(variable: Any, particle: Any, offset: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetParticleOffset:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val particleARG: JParticle = when (particle) {
    is JParticle -> particle
    else -> {
        errorPrint("${currentScope.scope}: В variableSetParticleOffset:particle получен тип ${particle.javaClass.kotlin.simpleName}, ожидалось: JParticle")
        throw Exception()
    }
}
val offsetARG: JVector = when (offset) {
    is JVector -> offset
    else -> {
        errorPrint("${currentScope.scope}: В variableSetParticleOffset:offset получен тип ${offset.javaClass.kotlin.simpleName}, ожидалось: JVector")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("particle"),
    "value" to particleARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("offset"),
    "value" to offsetARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_particle_offset"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetParticleSize(variable: Any, particle: Any, size: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetParticleSize:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val particleARG: JParticle = when (particle) {
    is JParticle -> particle
    else -> {
        errorPrint("${currentScope.scope}: В variableSetParticleSize:particle получен тип ${particle.javaClass.kotlin.simpleName}, ожидалось: JParticle")
        throw Exception()
    }
}
            val sizeARG: JNumber = when (size) {
                is Number -> JNumber(size)
is JNumber -> size
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetParticleSize:size получен тип ${size.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("particle"),
    "value" to particleARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("size"),
    "value" to sizeARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_particle_size"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetParticleSpread(variable: Any, particle: Any, horizontal: Any, vertical: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetParticleSpread:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val particleARG: JParticle = when (particle) {
    is JParticle -> particle
    else -> {
        errorPrint("${currentScope.scope}: В variableSetParticleSpread:particle получен тип ${particle.javaClass.kotlin.simpleName}, ожидалось: JParticle")
        throw Exception()
    }
}
            val horizontalARG: JNumber = when (horizontal) {
                is Number -> JNumber(horizontal)
is JNumber -> horizontal
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetParticleSpread:horizontal получен тип ${horizontal.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val verticalARG: JNumber = when (vertical) {
                is Number -> JNumber(vertical)
is JNumber -> vertical
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetParticleSpread:vertical получен тип ${vertical.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("particle"),
    "value" to particleARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("horizontal"),
    "value" to horizontalARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("vertical"),
    "value" to verticalARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_particle_spread"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetParticleType(variable: Any, particle: Any, type: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetParticleType:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val particleARG: JParticle = when (particle) {
    is JParticle -> particle
    else -> {
        errorPrint("${currentScope.scope}: В variableSetParticleType:particle получен тип ${particle.javaClass.kotlin.simpleName}, ожидалось: JParticle")
        throw Exception()
    }
}
            val typeARG: JString = when (type) {
                is String -> JString(type)
is JString -> type
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetParticleType:type получен тип ${type.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("particle"),
    "value" to particleARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("type"),
    "value" to typeARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_particle_type"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetPotionEffectAmplifier(variable: Any, potion: Any, amplifier: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetPotionEffectAmplifier:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val potionARG: JPotion = when (potion) {
    is JPotion -> potion
    else -> {
        errorPrint("${currentScope.scope}: В variableSetPotionEffectAmplifier:potion получен тип ${potion.javaClass.kotlin.simpleName}, ожидалось: JPotion")
        throw Exception()
    }
}
            val amplifierARG: JNumber = when (amplifier) {
                is Number -> JNumber(amplifier)
is JNumber -> amplifier
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetPotionEffectAmplifier:amplifier получен тип ${amplifier.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("potion"),
    "value" to potionARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("amplifier"),
    "value" to amplifierARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_potion_effect_amplifier"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetPotionEffectDuration(variable: Any, potion: Any, duration: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetPotionEffectDuration:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val potionARG: JPotion = when (potion) {
    is JPotion -> potion
    else -> {
        errorPrint("${currentScope.scope}: В variableSetPotionEffectDuration:potion получен тип ${potion.javaClass.kotlin.simpleName}, ожидалось: JPotion")
        throw Exception()
    }
}
            val durationARG: JNumber = when (duration) {
                is Number -> JNumber(duration)
is JNumber -> duration
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetPotionEffectDuration:duration получен тип ${duration.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("potion"),
    "value" to potionARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("duration"),
    "value" to durationARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_potion_effect_duration"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetPotionEffectType(variable: Any, potion: Any, effectType: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetPotionEffectType:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val potionARG: JPotion = when (potion) {
    is JPotion -> potion
    else -> {
        errorPrint("${currentScope.scope}: В variableSetPotionEffectType:potion получен тип ${potion.javaClass.kotlin.simpleName}, ожидалось: JPotion")
        throw Exception()
    }
}
            val effectTypeARG: JString = when (effectType) {
                is String -> JString(effectType)
is JString -> effectType
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetPotionEffectType:effectType получен тип ${effectType.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("potion"),
    "value" to potionARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("effect_type"),
    "value" to effectTypeARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_potion_effect_type"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetSoundPitch(variable: Any, sound: Any, pitch: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetSoundPitch:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val soundARG: JSound = when (sound) {
    is JSound -> sound
    else -> {
        errorPrint("${currentScope.scope}: В variableSetSoundPitch:sound получен тип ${sound.javaClass.kotlin.simpleName}, ожидалось: JSound")
        throw Exception()
    }
}
            val pitchARG: JNumber = when (pitch) {
                is Number -> JNumber(pitch)
is JNumber -> pitch
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetSoundPitch:pitch получен тип ${pitch.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("sound"),
    "value" to soundARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("pitch"),
    "value" to pitchARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_sound_pitch"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetSoundSource(variable: Any, sound: Any, source: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetSoundSource:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val soundARG: JSound = when (sound) {
    is JSound -> sound
    else -> {
        errorPrint("${currentScope.scope}: В variableSetSoundSource:sound получен тип ${sound.javaClass.kotlin.simpleName}, ожидалось: JSound")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("sound"),
    "value" to soundARG.parse()
)))
if (source != null) {
    if (source.value !in setOf("AMBIENT", "BLOCK", "HOSTILE", "MASTER", "MUSIC", "NEUTRAL", "PLAYER", "RECORD", "VOICE", "WEATHER")) {
        errorPrint("${currentScope.scope}: В функции variableSetSoundSource для аргумента source получено значение = \"${source.value}\", ожидалось одно из: \"AMBIENT\", \"BLOCK\", \"HOSTILE\", \"MASTER\", \"MUSIC\", \"NEUTRAL\", \"PLAYER\", \"RECORD\", \"VOICE\", \"WEATHER\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("source"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to source.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_sound_source"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetSoundType(variable: Any, sound: Any, namespace: Any, value: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetSoundType:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val soundARG: JSound = when (sound) {
    is JSound -> sound
    else -> {
        errorPrint("${currentScope.scope}: В variableSetSoundType:sound получен тип ${sound.javaClass.kotlin.simpleName}, ожидалось: JSound")
        throw Exception()
    }
}
            val namespaceARG: JString = when (namespace) {
                is String -> JString(namespace)
is JString -> namespace
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetSoundType:namespace получен тип ${namespace.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val valueARG: JString = when (value) {
                is String -> JString(value)
is JString -> value
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetSoundType:value получен тип ${value.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("sound"),
    "value" to soundARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("namespace"),
    "value" to namespaceARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("value"),
    "value" to valueARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_sound_type"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetSoundVariation(variable: Any, sound: Any, variation: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetSoundVariation:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val soundARG: JSound = when (sound) {
    is JSound -> sound
    else -> {
        errorPrint("${currentScope.scope}: В variableSetSoundVariation:sound получен тип ${sound.javaClass.kotlin.simpleName}, ожидалось: JSound")
        throw Exception()
    }
}
            val variationARG: JString = when (variation) {
                is String -> JString(variation)
is JString -> variation
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetSoundVariation:variation получен тип ${variation.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("sound"),
    "value" to soundARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variation"),
    "value" to variationARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_sound_variation"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetSoundVolumeAction(variable: Any, sound: Any, volume: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetSoundVolumeAction:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val soundARG: JSound = when (sound) {
    is JSound -> sound
    else -> {
        errorPrint("${currentScope.scope}: В variableSetSoundVolumeAction:sound получен тип ${sound.javaClass.kotlin.simpleName}, ожидалось: JSound")
        throw Exception()
    }
}
            val volumeARG: JNumber = when (volume) {
                is Number -> JNumber(volume)
is JNumber -> volume
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetSoundVolumeAction:volume получен тип ${volume.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("sound"),
    "value" to soundARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("volume"),
    "value" to volumeARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_sound_volume_action"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetTemplateCode(variable: Any, template: Any, code: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetTemplateCode:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val templateARG: JItem = when (template) {
    is JItem -> template
    else -> {
        errorPrint("${currentScope.scope}: В variableSetTemplateCode:template получен тип ${template.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
val codeARG: JAny = when (code) {
    is JAny -> code
    else -> {
        errorPrint("${currentScope.scope}: В variableSetTemplateCode:code получен тип ${code.javaClass.kotlin.simpleName}, ожидалось: JAny")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("template"),
    "value" to templateARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("code"),
    "value" to codeARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_template_code"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetTextureToMap(variable: Any, map: Any, url: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetTextureToMap:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val mapARG: JItem = when (map) {
    is JItem -> map
    else -> {
        errorPrint("${currentScope.scope}: В variableSetTextureToMap:map получен тип ${map.javaClass.kotlin.simpleName}, ожидалось: JItem")
        throw Exception()
    }
}
            val urlARG: JString = when (url) {
                is String -> JString(url)
is JString -> url
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetTextureToMap:url получен тип ${url.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("map"),
    "value" to mapARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("url"),
    "value" to urlARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_texture_to_map"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetVectorComponent(variable: Any, vector: Any, value: Any, vectorComponent: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetVectorComponent:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val vectorARG: JVector = when (vector) {
    is JVector -> vector
    else -> {
        errorPrint("${currentScope.scope}: В variableSetVectorComponent:vector получен тип ${vector.javaClass.kotlin.simpleName}, ожидалось: JVector")
        throw Exception()
    }
}
            val valueARG: JNumber = when (value) {
                is Number -> JNumber(value)
is JNumber -> value
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetVectorComponent:value получен тип ${value.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("vector"),
    "value" to vectorARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("value"),
    "value" to valueARG.parse()
)))
if (vectorComponent != null) {
    if (vectorComponent.value !in setOf("X", "Y", "Z")) {
        errorPrint("${currentScope.scope}: В функции variableSetVectorComponent для аргумента vector_component получено значение = \"${vectorComponent.value}\", ожидалось одно из: \"X\", \"Y\", \"Z\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("vector_component"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to vectorComponent.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_vector_component"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetVectorLength(variable: Any, vector: Any, length: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetVectorLength:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val vectorARG: JVector = when (vector) {
    is JVector -> vector
    else -> {
        errorPrint("${currentScope.scope}: В variableSetVectorLength:vector получен тип ${vector.javaClass.kotlin.simpleName}, ожидалось: JVector")
        throw Exception()
    }
}
            val lengthARG: JNumber = when (length) {
                is Number -> JNumber(length)
is JNumber -> length
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetVectorLength:length получен тип ${length.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("vector"),
    "value" to vectorARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("length"),
    "value" to lengthARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_set_vector_length"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableShiftAllCoordinates(variable: Any, location: Any, x: Any, y: Any, z: Any, yaw: Any, pitch: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableShiftAllCoordinates:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В variableShiftAllCoordinates:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val xARG: JNumber = when (x) {
                is Number -> JNumber(x)
is JNumber -> x
                else -> {
                    errorPrint("${currentScope.scope}: В variableShiftAllCoordinates:x получен тип ${x.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val yARG: JNumber = when (y) {
                is Number -> JNumber(y)
is JNumber -> y
                else -> {
                    errorPrint("${currentScope.scope}: В variableShiftAllCoordinates:y получен тип ${y.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val zARG: JNumber = when (z) {
                is Number -> JNumber(z)
is JNumber -> z
                else -> {
                    errorPrint("${currentScope.scope}: В variableShiftAllCoordinates:z получен тип ${z.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val yawARG: JNumber = when (yaw) {
                is Number -> JNumber(yaw)
is JNumber -> yaw
                else -> {
                    errorPrint("${currentScope.scope}: В variableShiftAllCoordinates:yaw получен тип ${yaw.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val pitchARG: JNumber = when (pitch) {
                is Number -> JNumber(pitch)
is JNumber -> pitch
                else -> {
                    errorPrint("${currentScope.scope}: В variableShiftAllCoordinates:pitch получен тип ${pitch.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("x"),
    "value" to xARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("y"),
    "value" to yARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("z"),
    "value" to zARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("yaw"),
    "value" to yawARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("pitch"),
    "value" to pitchARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_shift_all_coordinates"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableShiftCoordinate(variable: Any, location: Any, distance: Any, type: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableShiftCoordinate:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В variableShiftCoordinate:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val distanceARG: JNumber = when (distance) {
                is Number -> JNumber(distance)
is JNumber -> distance
                else -> {
                    errorPrint("${currentScope.scope}: В variableShiftCoordinate:distance получен тип ${distance.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("distance"),
    "value" to distanceARG.parse()
)))
if (type != null) {
    if (type.value !in setOf("PITCH", "X", "Y", "YAW", "Z")) {
        errorPrint("${currentScope.scope}: В функции variableShiftCoordinate для аргумента type получено значение = \"${type.value}\", ожидалось одно из: \"PITCH\", \"X\", \"Y\", \"YAW\", \"Z\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to type.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_shift_coordinate"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableShiftLocationInDirection(variable: Any, location: Any, shift: Any, direction: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableShiftLocationInDirection:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В variableShiftLocationInDirection:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val shiftARG: JNumber = when (shift) {
                is Number -> JNumber(shift)
is JNumber -> shift
                else -> {
                    errorPrint("${currentScope.scope}: В variableShiftLocationInDirection:shift получен тип ${shift.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("shift"),
    "value" to shiftARG.parse()
)))
if (direction != null) {
    if (direction.value !in setOf("FORWARD", "SIDEWAYS", "UPWARD")) {
        errorPrint("${currentScope.scope}: В функции variableShiftLocationInDirection для аргумента direction получено значение = \"${direction.value}\", ожидалось одно из: \"FORWARD\", \"SIDEWAYS\", \"UPWARD\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("direction"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to direction.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_shift_location_in_direction"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableShiftLocationOnVector(variable: Any, location: Any, vector: Any, length: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableShiftLocationOnVector:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В variableShiftLocationOnVector:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
val vectorARG: JVector = when (vector) {
    is JVector -> vector
    else -> {
        errorPrint("${currentScope.scope}: В variableShiftLocationOnVector:vector получен тип ${vector.javaClass.kotlin.simpleName}, ожидалось: JVector")
        throw Exception()
    }
}
            val lengthARG: JNumber = when (length) {
                is Number -> JNumber(length)
is JNumber -> length
                else -> {
                    errorPrint("${currentScope.scope}: В variableShiftLocationOnVector:length получен тип ${length.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("vector"),
    "value" to vectorARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("length"),
    "value" to lengthARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_shift_location_on_vector"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableShiftLocationTowardsLocation(variable: Any, locationFrom: Any, locationTo: Any, distance: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableShiftLocationTowardsLocation:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val locationFromARG: JLocation = when (locationFrom) {
    is JLocation -> locationFrom
    else -> {
        errorPrint("${currentScope.scope}: В variableShiftLocationTowardsLocation:locationFrom получен тип ${locationFrom.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
val locationToARG: JLocation = when (locationTo) {
    is JLocation -> locationTo
    else -> {
        errorPrint("${currentScope.scope}: В variableShiftLocationTowardsLocation:locationTo получен тип ${locationTo.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val distanceARG: JNumber = when (distance) {
                is Number -> JNumber(distance)
is JNumber -> distance
                else -> {
                    errorPrint("${currentScope.scope}: В variableShiftLocationTowardsLocation:distance получен тип ${distance.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location_from"),
    "value" to locationFromARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location_to"),
    "value" to locationToARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("distance"),
    "value" to distanceARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_shift_location_towards_location"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSimplexNoise3d(variable: Any, location: Any, seed: Any, locFrequency: Any, octaves: Any, frequency: Any, amplitude: Any, rangeMode: JString? = null, normalized: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSimplexNoise3d:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В variableSimplexNoise3d:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val seedARG: JNumber = when (seed) {
                is Number -> JNumber(seed)
is JNumber -> seed
                else -> {
                    errorPrint("${currentScope.scope}: В variableSimplexNoise3d:seed получен тип ${seed.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val locFrequencyARG: JNumber = when (locFrequency) {
                is Number -> JNumber(locFrequency)
is JNumber -> locFrequency
                else -> {
                    errorPrint("${currentScope.scope}: В variableSimplexNoise3d:locFrequency получен тип ${locFrequency.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val octavesARG: JNumber = when (octaves) {
                is Number -> JNumber(octaves)
is JNumber -> octaves
                else -> {
                    errorPrint("${currentScope.scope}: В variableSimplexNoise3d:octaves получен тип ${octaves.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val frequencyARG: JNumber = when (frequency) {
                is Number -> JNumber(frequency)
is JNumber -> frequency
                else -> {
                    errorPrint("${currentScope.scope}: В variableSimplexNoise3d:frequency получен тип ${frequency.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val amplitudeARG: JNumber = when (amplitude) {
                is Number -> JNumber(amplitude)
is JNumber -> amplitude
                else -> {
                    errorPrint("${currentScope.scope}: В variableSimplexNoise3d:amplitude получен тип ${amplitude.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }


    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("seed"),
    "value" to seedARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("loc_frequency"),
    "value" to locFrequencyARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("octaves"),
    "value" to octavesARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("frequency"),
    "value" to frequencyARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("amplitude"),
    "value" to amplitudeARG.parse()
)))
if (rangeMode != null) {
    if (rangeMode.value !in setOf("FULL_RANGE", "ZERO_TO_ONE")) {
        errorPrint("${currentScope.scope}: В функции variableSimplexNoise3d для аргумента range_mode получено значение = \"${rangeMode.value}\", ожидалось одно из: \"FULL_RANGE\", \"ZERO_TO_ONE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("range_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to rangeMode.jsonValue()
        ))
    )))
}
if (normalized != null) {
    if (normalized.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции variableSimplexNoise3d для аргумента normalized получено значение = \"${normalized.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("normalized"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to normalized.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_simplex_noise_3d"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSine(variable: Any, number: Any, variant: JString? = null, input: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSine:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val numberARG: JNumber = when (number) {
                is Number -> JNumber(number)
is JNumber -> number
                else -> {
                    errorPrint("${currentScope.scope}: В variableSine:number получен тип ${number.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }


    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("number"),
    "value" to numberARG.parse()
)))
if (variant != null) {
    if (variant.value !in setOf("ARCSINE", "HYPERBOLIC_SINE", "SINE")) {
        errorPrint("${currentScope.scope}: В функции variableSine для аргумента variant получено значение = \"${variant.value}\", ожидалось одно из: \"ARCSINE\", \"HYPERBOLIC_SINE\", \"SINE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("variant"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to variant.jsonValue()
        ))
    )))
}
if (input != null) {
    if (input.value !in setOf("DEGREES", "RADIANS")) {
        errorPrint("${currentScope.scope}: В функции variableSine для аргумента input получено значение = \"${input.value}\", ожидалось одно из: \"DEGREES\", \"RADIANS\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("input"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to input.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_sine"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSortList(variable: Any, list: Any, sortMode: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSortList:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val listARG: JArray = when (list) {
    is JArray -> list
    else -> {
        errorPrint("${currentScope.scope}: В variableSortList:list получен тип ${list.javaClass.kotlin.simpleName}, ожидалось: JArray")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("list"),
    "value" to listARG.parse()
)))
if (sortMode != null) {
    if (sortMode.value !in setOf("ASCENDING", "DESCENDING")) {
        errorPrint("${currentScope.scope}: В функции variableSortList для аргумента sort_mode получено значение = \"${sortMode.value}\", ожидалось одно из: \"ASCENDING\", \"DESCENDING\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("sort_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to sortMode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_sort_any_list"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSortMap(variable: Any, map: Any, sortOrder: JString? = null, sortType: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSortMap:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val mapARG: JMap = when (map) {
    is JMap -> map
    else -> {
        errorPrint("${currentScope.scope}: В variableSortMap:map получен тип ${map.javaClass.kotlin.simpleName}, ожидалось: JMap")
        throw Exception()
    }
}


    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("map"),
    "value" to mapARG.parse()
)))
if (sortOrder != null) {
    if (sortOrder.value !in setOf("ASCENDING", "DESCENDING")) {
        errorPrint("${currentScope.scope}: В функции variableSortMap для аргумента sort_order получено значение = \"${sortOrder.value}\", ожидалось одно из: \"ASCENDING\", \"DESCENDING\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("sort_order"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to sortOrder.jsonValue()
        ))
    )))
}
if (sortType != null) {
    if (sortType.value !in setOf("KEYS", "VALUES")) {
        errorPrint("${currentScope.scope}: В функции variableSortMap для аргумента sort_type получено значение = \"${sortType.value}\", ожидалось одно из: \"KEYS\", \"VALUES\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("sort_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to sortType.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_sort_any_map"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSplitText(variable: Any, text: Any, delimiter: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSplitText:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val textARG: JString = when (text) {
                is String -> JString(text)
is JString -> text
                else -> {
                    errorPrint("${currentScope.scope}: В variableSplitText:text получен тип ${text.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val delimiterARG: JString = when (delimiter) {
                is String -> JString(delimiter)
is JString -> delimiter
                else -> {
                    errorPrint("${currentScope.scope}: В variableSplitText:delimiter получен тип ${delimiter.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("text"),
    "value" to textARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("delimiter"),
    "value" to delimiterARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_split_text"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableStripText(variable: Any, text: Any, stripType: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableStripText:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val textARG: JString = when (text) {
                is String -> JString(text)
is JString -> text
                else -> {
                    errorPrint("${currentScope.scope}: В variableStripText:text получен тип ${text.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("text"),
    "value" to textARG.parse()
)))
if (stripType != null) {
    if (stripType.value !in setOf("ALL", "END", "INDENT", "START")) {
        errorPrint("${currentScope.scope}: В функции variableStripText для аргумента strip_type получено значение = \"${stripType.value}\", ожидалось одно из: \"ALL\", \"END\", \"INDENT\", \"START\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("strip_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to stripType.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_strip_text"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSubtract(variable: Any, value: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSubtract:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val valueARG: JNumber = when (value) {
                is Number -> JNumber(value)
is JNumber -> value
                else -> {
                    errorPrint("${currentScope.scope}: В variableSubtract:value получен тип ${value.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("value"),
    "value" to valueARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_subtract"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSubtractVectors(variable: Any, vectors: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSubtractVectors:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val vectorsARG: JVector = when (vectors) {
    is JVector -> vectors
    else -> {
        errorPrint("${currentScope.scope}: В variableSubtractVectors:vectors получен тип ${vectors.javaClass.kotlin.simpleName}, ожидалось: JVector")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("vectors"),
    "value" to vectorsARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_subtract_vectors"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableTangent(variable: Any, number: Any, variant: JString? = null, input: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableTangent:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val numberARG: JNumber = when (number) {
                is Number -> JNumber(number)
is JNumber -> number
                else -> {
                    errorPrint("${currentScope.scope}: В variableTangent:number получен тип ${number.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }


    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("number"),
    "value" to numberARG.parse()
)))
if (variant != null) {
    if (variant.value !in setOf("ARCTANGENT", "HYPERBOLIC_TANGENT", "TANGENT")) {
        errorPrint("${currentScope.scope}: В функции variableTangent для аргумента variant получено значение = \"${variant.value}\", ожидалось одно из: \"ARCTANGENT\", \"HYPERBOLIC_TANGENT\", \"TANGENT\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("variant"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to variant.jsonValue()
        ))
    )))
}
if (input != null) {
    if (input.value !in setOf("DEGREES", "RADIANS")) {
        errorPrint("${currentScope.scope}: В функции variableTangent для аргумента input получено значение = \"${input.value}\", ожидалось одно из: \"DEGREES\", \"RADIANS\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("input"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to input.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_tangent"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetText(variable: Any, text: Any, merging: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetText:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val textARG: JString = when (text) {
                is String -> JString(text)
is JString -> text
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetText:text получен тип ${text.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("text"),
    "value" to textARG.parse()
)))
if (merging != null) {
    if (merging.value !in setOf("CONCATENATION", "SEPARATE_LINES", "SPACES")) {
        errorPrint("${currentScope.scope}: В функции variableSetText для аргумента merging получено значение = \"${merging.value}\", ожидалось одно из: \"CONCATENATION\", \"SEPARATE_LINES\", \"SPACES\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("merging"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to merging.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_text"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetTextCase(variable: Any, text: Any, caseType: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetTextCase:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val textARG: JString = when (text) {
                is String -> JString(text)
is JString -> text
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetTextCase:text получен тип ${text.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("text"),
    "value" to textARG.parse()
)))
if (caseType != null) {
    if (caseType.value !in setOf("INVERT", "LOWER", "PROPER", "RANDOM", "UPPER")) {
        errorPrint("${currentScope.scope}: В функции variableSetTextCase для аргумента case_type получено значение = \"${caseType.value}\", ожидалось одно из: \"INVERT\", \"LOWER\", \"PROPER\", \"RANDOM\", \"UPPER\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("case_type"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to caseType.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_text_case"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableGetTextLength(variable: Any, text: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableGetTextLength:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val textARG: JString = when (text) {
                is String -> JString(text)
is JString -> text
                else -> {
                    errorPrint("${currentScope.scope}: В variableGetTextLength:text получен тип ${text.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("text"),
    "value" to textARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_text_length"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableToChar(variable: Any, number: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableToChar:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val numberARG: JNumber = when (number) {
                is Number -> JNumber(number)
is JNumber -> number
                else -> {
                    errorPrint("${currentScope.scope}: В variableToChar:number получен тип ${number.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("number"),
    "value" to numberARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_to_char"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableToHsb(variable: Any, hue: Any, saturation: Any, brightness: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableToHsb:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val hueARG: JNumber = when (hue) {
                is Number -> JNumber(hue)
is JNumber -> hue
                else -> {
                    errorPrint("${currentScope.scope}: В variableToHsb:hue получен тип ${hue.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val saturationARG: JNumber = when (saturation) {
                is Number -> JNumber(saturation)
is JNumber -> saturation
                else -> {
                    errorPrint("${currentScope.scope}: В variableToHsb:saturation получен тип ${saturation.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val brightnessARG: JNumber = when (brightness) {
                is Number -> JNumber(brightness)
is JNumber -> brightness
                else -> {
                    errorPrint("${currentScope.scope}: В variableToHsb:brightness получен тип ${brightness.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("hue"),
    "value" to hueARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("saturation"),
    "value" to saturationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("brightness"),
    "value" to brightnessARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_to_hsb"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableToHsl(variable: Any, hue: Any, saturation: Any, lightness: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableToHsl:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val hueARG: JNumber = when (hue) {
                is Number -> JNumber(hue)
is JNumber -> hue
                else -> {
                    errorPrint("${currentScope.scope}: В variableToHsl:hue получен тип ${hue.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val saturationARG: JNumber = when (saturation) {
                is Number -> JNumber(saturation)
is JNumber -> saturation
                else -> {
                    errorPrint("${currentScope.scope}: В variableToHsl:saturation получен тип ${saturation.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val lightnessARG: JNumber = when (lightness) {
                is Number -> JNumber(lightness)
is JNumber -> lightness
                else -> {
                    errorPrint("${currentScope.scope}: В variableToHsl:lightness получен тип ${lightness.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("hue"),
    "value" to hueARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("saturation"),
    "value" to saturationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("lightness"),
    "value" to lightnessARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_to_hsl"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableToJson(variable: Any, value: Any, prettyPrint: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableToJson:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val valueARG: JAny = when (value) {
    is JAny -> value
    else -> {
        errorPrint("${currentScope.scope}: В variableToJson:value получен тип ${value.javaClass.kotlin.simpleName}, ожидалось: JAny")
        throw Exception()
    }
}

    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("value"),
    "value" to valueARG.parse()
)))
if (prettyPrint != null) {
    if (prettyPrint.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции variableToJson для аргумента pretty_print получено значение = \"${prettyPrint.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("pretty_print"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to prettyPrint.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_to_json"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableToRgb(variable: Any, red: Any, green: Any, blue: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableToRgb:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val redARG: JNumber = when (red) {
                is Number -> JNumber(red)
is JNumber -> red
                else -> {
                    errorPrint("${currentScope.scope}: В variableToRgb:red получен тип ${red.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val greenARG: JNumber = when (green) {
                is Number -> JNumber(green)
is JNumber -> green
                else -> {
                    errorPrint("${currentScope.scope}: В variableToRgb:green получен тип ${green.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val blueARG: JNumber = when (blue) {
                is Number -> JNumber(blue)
is JNumber -> blue
                else -> {
                    errorPrint("${currentScope.scope}: В variableToRgb:blue получен тип ${blue.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("red"),
    "value" to redARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("green"),
    "value" to greenARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("blue"),
    "value" to blueARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_to_rgb"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableTrimList(variable: Any, list: Any, start: Any, end: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableTrimList:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val listARG: JArray = when (list) {
    is JArray -> list
    else -> {
        errorPrint("${currentScope.scope}: В variableTrimList:list получен тип ${list.javaClass.kotlin.simpleName}, ожидалось: JArray")
        throw Exception()
    }
}
            val startARG: JNumber = when (start) {
                is Number -> JNumber(start)
is JNumber -> start
                else -> {
                    errorPrint("${currentScope.scope}: В variableTrimList:start получен тип ${start.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val endARG: JNumber = when (end) {
                is Number -> JNumber(end)
is JNumber -> end
                else -> {
                    errorPrint("${currentScope.scope}: В variableTrimList:end получен тип ${end.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("list"),
    "value" to listARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("start"),
    "value" to startARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("end"),
    "value" to endARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_trim_list"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableTrimText(variable: Any, text: Any, start: Any, end: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableTrimText:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val textARG: JString = when (text) {
                is String -> JString(text)
is JString -> text
                else -> {
                    errorPrint("${currentScope.scope}: В variableTrimText:text получен тип ${text.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }
            val startARG: JNumber = when (start) {
                is Number -> JNumber(start)
is JNumber -> start
                else -> {
                    errorPrint("${currentScope.scope}: В variableTrimText:start получен тип ${start.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val endARG: JNumber = when (end) {
                is Number -> JNumber(end)
is JNumber -> end
                else -> {
                    errorPrint("${currentScope.scope}: В variableTrimText:end получен тип ${end.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("text"),
    "value" to textARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("start"),
    "value" to startARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("end"),
    "value" to endARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_trim_text"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetValue(variable: Any, value: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetValue:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val valueARG: JAny = when (value) {
    is JAny -> value
    else -> {
        errorPrint("${currentScope.scope}: В variableSetValue:value получен тип ${value.javaClass.kotlin.simpleName}, ожидалось: JAny")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("value"),
    "value" to valueARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_value"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableSetVector(variable: Any, x: Any, y: Any, z: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableSetVector:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val xARG: JNumber = when (x) {
                is Number -> JNumber(x)
is JNumber -> x
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetVector:x получен тип ${x.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val yARG: JNumber = when (y) {
                is Number -> JNumber(y)
is JNumber -> y
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetVector:y получен тип ${y.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val zARG: JNumber = when (z) {
                is Number -> JNumber(z)
is JNumber -> z
                else -> {
                    errorPrint("${currentScope.scope}: В variableSetVector:z получен тип ${z.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("x"),
    "value" to xARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("y"),
    "value" to yARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("z"),
    "value" to zARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_vector"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableVectorCrossProduct(variable: Any, vector1: Any, vector2: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableVectorCrossProduct:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val vector1ARG: JVector = when (vector1) {
    is JVector -> vector1
    else -> {
        errorPrint("${currentScope.scope}: В variableVectorCrossProduct:vector1 получен тип ${vector1.javaClass.kotlin.simpleName}, ожидалось: JVector")
        throw Exception()
    }
}
val vector2ARG: JVector = when (vector2) {
    is JVector -> vector2
    else -> {
        errorPrint("${currentScope.scope}: В variableVectorCrossProduct:vector2 получен тип ${vector2.javaClass.kotlin.simpleName}, ожидалось: JVector")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("vector_1"),
    "value" to vector1ARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("vector_2"),
    "value" to vector2ARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_vector_cross_product"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableVectorDotProduct(variable: Any, vector1: Any, vector2: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableVectorDotProduct:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val vector1ARG: JVector = when (vector1) {
    is JVector -> vector1
    else -> {
        errorPrint("${currentScope.scope}: В variableVectorDotProduct:vector1 получен тип ${vector1.javaClass.kotlin.simpleName}, ожидалось: JVector")
        throw Exception()
    }
}
val vector2ARG: JVector = when (vector2) {
    is JVector -> vector2
    else -> {
        errorPrint("${currentScope.scope}: В variableVectorDotProduct:vector2 получен тип ${vector2.javaClass.kotlin.simpleName}, ожидалось: JVector")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("vector_1"),
    "value" to vector1ARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("vector_2"),
    "value" to vector2ARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_vector_dot_product"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableVectorToDirectionName(variable: Any, vector: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableVectorToDirectionName:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val vectorARG: JVector = when (vector) {
    is JVector -> vector
    else -> {
        errorPrint("${currentScope.scope}: В variableVectorToDirectionName:vector получен тип ${vector.javaClass.kotlin.simpleName}, ожидалось: JVector")
        throw Exception()
    }
}
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("vector"),
    "value" to vectorARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_vector_to_direction_name"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableVoronoiNoise3d(variable: Any, location: Any, seed: Any, frequency: Any, displacement: Any, rangeMode: JString? = null, enableDistance: JString? = null) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableVoronoiNoise3d:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
val locationARG: JLocation = when (location) {
    is JLocation -> location
    else -> {
        errorPrint("${currentScope.scope}: В variableVoronoiNoise3d:location получен тип ${location.javaClass.kotlin.simpleName}, ожидалось: JLocation")
        throw Exception()
    }
}
            val seedARG: JNumber = when (seed) {
                is Number -> JNumber(seed)
is JNumber -> seed
                else -> {
                    errorPrint("${currentScope.scope}: В variableVoronoiNoise3d:seed получен тип ${seed.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val frequencyARG: JNumber = when (frequency) {
                is Number -> JNumber(frequency)
is JNumber -> frequency
                else -> {
                    errorPrint("${currentScope.scope}: В variableVoronoiNoise3d:frequency получен тип ${frequency.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val displacementARG: JNumber = when (displacement) {
                is Number -> JNumber(displacement)
is JNumber -> displacement
                else -> {
                    errorPrint("${currentScope.scope}: В variableVoronoiNoise3d:displacement получен тип ${displacement.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }


    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("location"),
    "value" to locationARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("seed"),
    "value" to seedARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("frequency"),
    "value" to frequencyARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("displacement"),
    "value" to displacementARG.parse()
)))
if (rangeMode != null) {
    if (rangeMode.value !in setOf("FULL_RANGE", "ZERO_TO_ONE")) {
        errorPrint("${currentScope.scope}: В функции variableVoronoiNoise3d для аргумента range_mode получено значение = \"${rangeMode.value}\", ожидалось одно из: \"FULL_RANGE\", \"ZERO_TO_ONE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("range_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to rangeMode.jsonValue()
        ))
    )))
}
if (enableDistance != null) {
    if (enableDistance.value !in setOf("FALSE", "TRUE")) {
        errorPrint("${currentScope.scope}: В функции variableVoronoiNoise3d для аргумента enable_distance получено значение = \"${enableDistance.value}\", ожидалось одно из: \"FALSE\", \"TRUE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("enable_distance"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to enableDistance.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_voronoi_noise_3d"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun variableWarp(variable: Any, number: Any, min: Any, max: Any) {
val variableARG: Var = when (variable) {
    is Var -> variable
    else -> {
        errorPrint("${currentScope.scope}: В variableWarp:variable получен тип ${variable.javaClass.kotlin.simpleName}, ожидалось: Var")
        throw Exception()
    }
}
            val numberARG: JNumber = when (number) {
                is Number -> JNumber(number)
is JNumber -> number
                else -> {
                    errorPrint("${currentScope.scope}: В variableWarp:number получен тип ${number.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val minARG: JNumber = when (min) {
                is Number -> JNumber(min)
is JNumber -> min
                else -> {
                    errorPrint("${currentScope.scope}: В variableWarp:min получен тип ${min.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
            val maxARG: JNumber = when (max) {
                is Number -> JNumber(max)
is JNumber -> max
                else -> {
                    errorPrint("${currentScope.scope}: В variableWarp:max получен тип ${max.javaClass.kotlin.simpleName}, ожидалось: Number, JNumber")
                    throw Exception()
                }
            }
    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("variable"),
    "value" to variableARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("number"),
    "value" to numberARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("min"),
    "value" to minARG.parse()
)))
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("max"),
    "value" to maxARG.parse()
)))
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("set_variable_warp"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

fun codeStartProcess(processName: Any, localVariablesMode: JString? = null, targetMode: JString? = null) {
            val processNameARG: JString = when (processName) {
                is String -> JString(processName)
is JString -> processName
                else -> {
                    errorPrint("${currentScope.scope}: В codeStartProcess:processName получен тип ${processName.javaClass.kotlin.simpleName}, ожидалось: String, JString")
                    throw Exception()
                }
            }


    val funValues = mutableListOf<JsonObject>()
funValues.add(JsonObject(hashMapOf(
    "name" to JsonPrimitive("process_name"),
    "value" to processNameARG.parse()
)))
if (localVariablesMode != null) {
    if (localVariablesMode.value !in setOf("COPY", "DONT_COPY", "SHARE")) {
        errorPrint("${currentScope.scope}: В функции codeStartProcess для аргумента local_variables_mode получено значение = \"${localVariablesMode.value}\", ожидалось одно из: \"COPY\", \"DONT_COPY\", \"SHARE\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("local_variables_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to localVariablesMode.jsonValue()
        ))
    )))
}
if (targetMode != null) {
    if (targetMode.value !in setOf("CURRENT_SELECTION", "CURRENT_TARGET", "FOR_EACH_IN_SELECTION", "NO_TARGET")) {
        errorPrint("${currentScope.scope}: В функции codeStartProcess для аргумента target_mode получено значение = \"${targetMode.value}\", ожидалось одно из: \"CURRENT_SELECTION\", \"CURRENT_TARGET\", \"FOR_EACH_IN_SELECTION\", \"NO_TARGET\"")
        throw Exception()
    }
    funValues.add(JsonObject(hashMapOf(
        "name" to JsonPrimitive("target_mode"),
        "value" to JsonObject(hashMapOf(
            "type" to JsonPrimitive("enum"),
            "enum" to targetMode.jsonValue()
        ))
    )))
}
    val op = JsonObject(hashMapOf(
        "action" to JsonPrimitive("start_process"),
        "values" to JsonArray(funValues)
    ))
    currentScope.addOperationToScope(op)
}

